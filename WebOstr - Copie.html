<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WebOS (Updated)</title>
<style>
:root{
  --bg:#0b1220;
  --panel:rgba(255,255,255,0.02);
  --panel-2:rgba(255,255,255,0.01);
  --glass:rgba(255,255,255,0.06);
  --accent:#2563eb;
  --muted:#9aa8bf;
  --win-radius:14px;
  --shadow-1:0 8px 30px rgba(2,6,23,0.6);
  --shadow-2:0 6px 18px rgba(2,6,23,0.45);
}
.terminal-frame {
  background: #1e1e1e;
  border-radius: 8px;
  height: 100%;
  padding: 0;
  display: flex;
  flex-direction: column;
  border: 1px solid #2d2d2d;
  box-shadow: 0 4px 18px rgba(0,0,0,0.4);
}

.terminal-toolbar {
  display: flex;
  justify-content: flex-end;
  gap: 6px;
  padding: 6px 10px;
  background: #252526;
  border-bottom: 1px solid #2d2d2d;
}

.terminal-zoom-btn {
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 12px;
  background: #3c3c3c;
  color: #ccc;
  border: none;
  cursor: pointer;
  transition: 0.15s;
}

.terminal-zoom-btn:hover {
  background: #505050;
}

.terminal-output {
  flex: 1;
  overflow-y: auto;
  padding: 12px;
  font-family: "Consolas", "Fira Code", monospace;
  font-size: var(--termFont, 13px);
  color: #d4d4d4;
  white-space: pre-wrap;
}

.terminal-input-row {
  display: flex;
  padding: 10px;
  gap: 8px;
  border-top: 1px solid #2d2d2d;
}

.terminal-input {
  flex: 1;
  background: #252526;
  border: 1px solid #3c3c3c;
  color: #d4d4d4;
  font-family: "Consolas", "Fira Code", monospace;
  padding: 8px;
  border-radius: 6px;
  font-size: var(--termFont, 13px);
}

.terminal-input:focus {
  outline: none;
  border-color: #0e639c;
}

.terminal-run-btn {
  background: #0e639c;
  border: none;
  padding: 8px 12px;
  border-radius: 6px;
  color: #fff;
  cursor: pointer;
  font-size: 12px;
  transition: 0.15s;
}

.terminal-run-btn:hover {
  background: #1177bb;
}


*{box-sizing:border-box;font-family:Inter,Segoe UI,sans-serif}
html,body{height:100%;margin:0;background:var(--bg);color:#e6eef8}
#desktop{position:relative;height:100vh;overflow:hidden}
.wallpaper{position:absolute;inset:0;background-size:cover;background-position:center;transition:background 0.5s}
.desktop-cards{position:absolute;top:16px;left:16px;display:flex;flex-direction:column;gap:10px;z-index:2;height:calc(100vh - 80px);overflow-y:auto}
.app-card{width:100px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.03);display:flex;flex-direction:column;align-items:center;gap:4px;cursor:pointer;transition:all .15s}
.app-card:hover{transform:translateY(-3px);background:rgba(255,255,255,0.07)}

.screenshot-clean * {
    backdrop-filter: none !important;
    filter: none !important;
    box-shadow: none !important;
    background-blend-mode: normal !important;
    mix-blend-mode: normal !important;
}
.screenshot-clean .window {
    background: #0b1220 !important;   /* your original panel color */
    opacity: 1 !important;
}

.screenshot-clean .win-title {
    background: rgba(0,0,0,0.3) !important;
    opacity: 1 !important;
}

.screenshot-clean .win-body {
    opacity: 1 !important;
    background: none !important;
}


.window {
  will-change: transform;
}

.file-item {
  will-change: background, transform;
}

.app-card {
  will-change: transform;
}
.app-card:active{transform:scale(0.95)}
.app-card span{font-size:12px;color:var(--muted)}
/* File Manager Styles */
.sidebar-item {
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  margin-bottom: 4px;
  transition: all 0.15s;
}

.sidebar-item:hover {
  background: rgba(59, 130, 246, 0.2);
}

.file-item {
  margin-bottom: 4px;
  transition: all 0.15s;
}

.file-item:hover {
  background: rgba(255, 255, 255, 0.05);
}
.taskbar{
  position:absolute;
  left:16px;
  right:16px;
  bottom:16px;
  height:56px;
  background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  border-radius:14px;
  box-shadow:var(--shadow-2);
  backdrop-filter:blur(14px);
  display:flex;
  align-items:center;
  padding:0 14px;
  gap:12px;
  z-index:1000;
}
.tasks{display:flex;gap:8px;flex:1;justify-content:center;}

.window, .app-card, .task-item, .start-menu, .notification{
  transition:transform .18s cubic-bezier(.2,.9,.2,1), 
             box-shadow .18s, opacity .12s;
}
.window:active{transform:scale(.997);}

.start-btn{
  width:48px;
  height:44px;
  border-radius:10px;
  background:linear-gradient(135deg, var(--panel), var(--panel-2));
  display:flex;
  align-items:center;
  justify-content:center;
  cursor:pointer;
  transition:.15s;
}
.start-btn:hover{background:rgba(255,255,255,0.06);}

.start-btn:hover{background:#1e293b}
.tasks{display:flex;gap:6px;flex:1}
.task-item{height:32px;padding:0 10px;background:rgba(255,255,255,0.04);border-radius:6px;display:flex;align-items:center;cursor:pointer;font-size:12px;transition:all .15s}
.task-item:hover{background:rgba(255,255,255,0.08)}
.task-item.active{background:rgba(59,130,246,0.3)}
.clock{color:var(--muted);font-size:12px}
.start-menu{position:absolute;left:10px;bottom:56px;width:280px;background:rgba(11,18,32,0.95);backdrop-filter:blur(20px);border-radius:10px;padding:10px;box-shadow:0 8px 32px rgba(0,0,0,0.5);z-index:1001;opacity:0;transform:translateY(10px);pointer-events:none;transition:all .2s}
.start-menu.open{opacity:1;transform:translateY(0);pointer-events:auto}
.start-menu input{width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.05);background:rgba(0,0,0,0.3);color:inherit;margin-bottom:10px}
.apps-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px}
.app-card-small{padding:8px;border-radius:6px;background:rgba(255,255,255,0.03);text-align:center;cursor:pointer;font-size:11px;transition:all .15s}
.app-card-small:hover{background:rgba(255,255,255,0.08)}
.window{
  position:absolute;
  background:linear-gradient(180deg, var(--panel), var(--panel-2));
  border-radius:var(--win-radius);
  box-shadow:var(--shadow-1);
  border:1px solid rgba(255,255,255,0.03);
  display:flex;
  flex-direction:column;
  backdrop-filter:blur(10px) saturate(120%);
  z-index:50;
  animation:winOpen .2s ease-out;
  overflow:hidden;
}

@keyframes winOpen{from{opacity:0;transform:scale(0.92)}to{opacity:1;transform:scale(1)}}
.window.closing{animation:winClose .15s ease-out forwards}
.tile {
  position: relative;
  transition: transform 0.15s ease-in-out, background 0.15s;
}

.tile-new {
  animation: tileSpawn 0.2s ease-out;
}

@keyframes tileSpawn {
  from { transform: scale(0.3); opacity: 0; }
  to   { transform: scale(1); opacity: 1; }
}

.tile-merge {
  animation: tileMerge 0.2s ease-out;
}

@keyframes tileMerge {
  from { transform: scale(1); }
  50%  { transform: scale(1.25); }
  to   { transform: scale(1); }
}

@keyframes winClose{to{opacity:0;transform:scale(0.92)}}
.window.minimizing{animation:winMin .2s ease-out forwards}
.game-tile {
  background: rgba(255,255,255,0.06);
  border-radius: 10px;
  padding: 12px;
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  transition: 0.15s;
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
}

.game-tile:hover {
  transform: translateY(-4px);
  background: rgba(255,255,255,0.12);
}

.game-icon {
  font-size: 40px;
  margin-bottom: 6px;
  text-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

.game-title {
  font-size: 15px;
  font-weight: bold;
  margin-bottom: 4px;
}

.game-score {
  font-size: 12px;
  color: #a5b4fc;
}

@keyframes winMin{to{opacity:0;transform:translateY(50px) scale(0.8)}}
.win-title{
  height:44px;
  display:flex;
  align-items:center;
  padding:0 14px;
  background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
  backdrop-filter:blur(10px) saturate(120%);
  cursor:grab;
  border-radius:var(--win-radius) var(--win-radius) 0 0;
  gap:10px;
}

.win-title .title{flex:1;font-size:12px;font-weight:600}
.win-controls{display:flex;gap:4px}
.win-controls button{
  width:36px;
  height:34px;
  border:0;
  background:transparent;
  color:var(--muted);
  cursor:pointer;
  border-radius:8px;
  font-size:14px;
  transition:.15s;
}
.win-controls button:hover{
  background:rgba(255,255,255,0.06);
}
.win-controls button[data-act="close"]:hover{
  background:#ff5555;
  color:white;
}

.win-controls button:hover{background:rgba(255,255,255,0.1)}
.win-controls button[data-act="close"]:hover{background:#ef4444;color:#fff}
.win-body{flex:1;padding:10px;overflow:auto}
.btn{padding:6px 12px;border-radius:6px;background:var(--accent);border:0;color:#fff;cursor:pointer;font-size:12px;transition:all .1s}
.btn:hover{opacity:0.85}
.input{padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.05);background:rgba(0,0,0,0.2);color:inherit;width:100%}
.input:focus{outline:none;border-color:var(--accent)}
.small{font-size:11px;color:var(--muted)}
.resizer{position:absolute;right:2px;bottom:2px;width:12px;height:12px;cursor:se-resize;opacity:0.3}
.file-thumb{height:48px;width:48px;object-fit:cover;border-radius:6px;margin-right:8px;border:1px solid rgba(255,255,255,0.04)}

.file-item.dragging {
  opacity: 0.5;
  cursor: grabbing;
}

.file-item.drag-over {
  background: rgba(59, 130, 246, 0.2);
  border: 2px dashed var(--accent);
}

.drop-zone {
  position: relative;
}

.drop-zone::after {
  content: 'Drop here';
  position: absolute;
  inset: 0;
  background: rgba(59, 130, 246, 0.1);
  border: 3px dashed var(--accent);
  border-radius: 8px;
  display: none;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  color: var(--accent);
  pointer-events: none;
  z-index: 100;
}

.drop-zone.drag-active::after {
  display: flex;
}

/* NEW: Notification System */
.notifications-container {
  position: fixed;
  top: 16px;
  right: 16px;
  width: 320px;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  gap: 10px;
  pointer-events: none;
}

.notification {
  background: rgba(11, 18, 32, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 10px;
  padding: 14px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  gap: 12px;
  transform: translateX(400px);
  opacity: 0;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  pointer-events: all;
  border-left: 4px solid var(--accent);
}

.notification.show {
  transform: translateX(0);
  opacity: 1;
}

.notification.hide {
  transform: translateX(400px);
  opacity: 0;
}

.notification-icon {
  font-size: 20px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  background: rgba(59, 130, 246, 0.2);
}

.notification-content {
  flex: 1;
}

.notification-title {
  font-weight: 600;
  font-size: 13px;
  margin-bottom: 2px;
}

.notification-message {
  font-size: 12px;
  color: var(--muted);
  line-height: 1.4;
}

.notification-close {
  background: none;
  border: none;
  color: var(--muted);
  cursor: pointer;
  font-size: 14px;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: all 0.1s;
}

.sidebar-item {
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  margin-bottom: 4px;
  transition: all 0.2s ease;
}

.sidebar-item:hover {
  background: rgba(59, 130, 246, 0.2);
  transform: translateX(4px);
}

.notification-close:hover {
  background: rgba(255, 255, 255, 0.1);
}

/* Notification types */
.notification.success {
  border-left-color: #10b981;
}

.notification.success .notification-icon {
  background: rgba(16, 185, 129, 0.2);
}

.notification.error {
  border-left-color: #ef4444;
}

.notification.error .notification-icon {
  background: rgba(239, 68, 68, 0.2);
}

.notification.warning {
  border-left-color: #f59e0b;
}

.notification.warning .notification-icon {
  background: rgba(245, 158, 11, 0.2);
}

.notification.info {
  border-left-color: #3b82f6;
}
.setBtn {
    padding: 10px;
    border-radius: 6px;
    cursor: pointer;
    transition: 0.15s;
}

.setBtn:hover {
    background: rgba(255,255,255,0.05);
}

.setBtn.active {
    background: rgba(255,255,255,0.12);
    font-weight: bold;
}

.card {
    background: rgba(255,255,255,0.04);
    border: 1px solid rgba(255,255,255,0.07);
    padding: 15px;
    border-radius: 8px;
    margin-bottom: 15px;
}

.wall-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 8px;
    margin: 10px 0;
}

.wallBox {
    height: 60px;
    border-radius: 8px;
    cursor: pointer;
    transition: 0.15s;
}

.wallBox:hover {
    transform: scale(1.05);
}

.notification.info .notification-icon {
  background: rgba(59, 130, 246, 0.2);
}

/* NEW: Right-click Context Menu */
.context-menu {
  position: fixed;
  background: rgba(11, 18, 32, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 8px;
  padding: 6px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  z-index: 10000;
  min-width: 160px;
  opacity: 0;
  transform: scale(0.95);
  transition: all 0.1s ease;
  pointer-events: none;
}

.context-menu.show {
  opacity: 1;
  transform: scale(1);
  pointer-events: all;
}

.context-item {
  padding: 8px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.1s;
}

.context-item:hover {
  background: rgba(59, 130, 246, 0.2);
}

.context-item:active {
  background: rgba(59, 130, 246, 0.3);
}

.context-divider {
  height: 1px;
  background: rgba(255, 255, 255, 0.1);
  margin: 4px 0;
}

/* Wallpaper Grid */
.wallpaper-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin-top: 8px;
  max-height: 200px;
  overflow-y: auto;
}

.wallpaper-item {
  aspect-ratio: 16/9;
  border-radius: 6px;
  cursor: pointer;
  background-size: cover;
  background-position: center;
  border: 2px solid transparent;
  transition: all 0.15s;
}

.wallpaper-item:hover {
  transform: scale(1.05);
}

.wallpaper-item.active {
  border-color: var(--accent);
}

.wallpaper-item.custom {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.05);
}

.wallpaper-item.custom::before {
  content: '+';
  font-size: 24px;
  color: var(--muted);
}

.wallpaper-item.custom:hover::before {
  color: var(--accent);
}

</style>
</head>
<body>
<div id="fileContextMenu"
     style="
        position:fixed;
        top:0;
        left:0;
        display:none;
        background:#1f1f1f;
        color:white;
        padding:6px 0;
        border:1px solid rgba(255,255,255,0.12);
        border-radius:6px;
        width:140px;
        z-index:999999;
        font-size:13px;
     ">
  
  <div id="ctxOpen"
       style="padding:8px 12px;cursor:pointer;">
       üìÇ Open
  </div>

  <div id="ctxRename"
       style="padding:8px 12px;cursor:pointer;">
       ‚úè Rename
  </div>

  <div id="ctxDelete"
       style="padding:8px 12px;cursor:pointer;">
       üóë Delete
  </div>

</div>


<div id="desktop">
  <div class="wallpaper" id="wallpaper"></div>
  <div class="desktop-cards" id="desktopCards">
    <div class="app-card" data-app="explorer"><span>üìÅ</span><span>Files</span></div>
    <div class="app-card" data-app="editor"><span>üìù</span><span>Editor</span></div>
    <div class="app-card" data-app="terminal"><span>üíª</span><span>Terminal</span></div>
    <div class="app-card" data-app="paint"><span>üé®</span><span>Paint</span></div>
    <div class="app-card" data-app="screenshot"><span>üì∏</span><span>Screenshot</span></div>
    <div class="app-card" data-app="games"><span>üéÆ</span><span>Games</span></div>
	<div class="app-card" data-app="chat"><span>üí¨</span> <span>Chat</span></div>

    <div class="app-card" data-app="calculator"><span>üßÆ</span><span>Calc</span></div>
    <div class="app-card" data-app="browser"><span>üåê</span><span>Browser</span></div>
    <div class="app-card" data-app="settings"><span>‚öôÔ∏è</span><span>Settings</span></div>
  </div>
  <div id="windows"></div>
  <div class="taskbar">
    <div class="start-btn" id="startBtn">‚ò∞</div>
    <div class="tasks" id="taskList"></div>
    <div class="clock" id="clock"></div>
  </div>
  <div class="start-menu" id="startMenu">
    <input id="startSearch" placeholder="Search..." />
    <div class="apps-grid" id="appsGrid">
      <div class="app-card-small" data-app="explorer">üìÅ Files</div>
      <div class="app-card-small" data-app="editor">üìù Editor</div>
      <div class="app-card-small" data-app="terminal">üíª Terminal</div>
      <div class="app-card-small" data-app="paint">üé® Paint</div>
      <div class="app-card-small" data-app="games">üéÆ Games</div>
      <div class="app-card-small" data-app="screenshot">üì∏ Screenshot</div>
      <div class="app-card-small" data-app="calculator">üßÆ Calc</div>
      <div class="app-card-small" data-app="browser">üåê Browser</div>
      <div class="app-card-small" data-app="settings">‚öôÔ∏è Settings</div>
      <div class="app-card-small" data-app="about">‚ÑπÔ∏è About</div>
    </div>
  </div>
  
  <div class="notifications-container" id="notifications"></div>
  
  <div class="context-menu" id="contextMenu">
    <div class="context-item" data-action="refresh">üîÑ Refresh Desktop</div>
    <div class="context-item" data-action="newFile">üìÑ New Text File</div>
    <div class="context-divider"></div>
    <div class="context-item" data-action="terminal">üíª Open Terminal</div>
    <div class="context-item" data-action="snake">üêç Play Snake</div>
    <div class="context-divider"></div>
    <div class="context-item" data-action="settings">‚öôÔ∏è Settings</div>
  </div>
</div>
<script>

const FS_KEY='webos_fs_v2';

function getFS(){
  try{
    const raw = localStorage. getItem(FS_KEY) || '';
    if (!raw) {

    // bootstrap default filesystem with CORRECT structure
    const fs = {
        "/": { type: "dir", children: ["Downloads","Documents","Music","Videos","Pictures"] },
        "/Downloads": { type: "dir", children: [] },
        "/Documents": { type: "dir", children: [] },
        "/Music": { type: "dir", children: [] },
        "/Videos": { type: "dir", children: [] },
        "/Pictures": { type: "dir", children: [] }
    };

      localStorage.setItem(FS_KEY, JSON.stringify(fs));
      return fs;
    }
    
    let fs = JSON.parse(raw);
    
    const requiredFolders = ["/Downloads", "/Documents", "/Music", "/Videos", "/Pictures"];
    let needsSave = false;
    
    if(!fs["/"]) {
      fs["/"] = { type: "dir", children: [] };
      needsSave = true;
    }
    
    requiredFolders. forEach(folder => {
      if(!fs[folder]) {
        fs[folder] = { type: "dir", children: [] };
        if(! fs["/"]. children.includes(folder. slice(1))) {
          fs["/"].children.push(folder. slice(1));
        }
        needsSave = true;
      }
    });
    
    const oldKeys = Object.keys(fs). filter(k => ! k.startsWith('/') && k !== 'type' && k !== 'children');
    oldKeys.forEach(oldKey => {
      const newKey = '/' + oldKey;
      if(! fs[newKey]) {
        fs[newKey] = fs[oldKey];
        delete fs[oldKey];
        needsSave = true;
      }
    });
    
    if(needsSave) {
      localStorage.setItem(FS_KEY, JSON.stringify(fs));
    }
    
    return fs;
  }catch(e){
    console.error("FS read error", e);
    // HARD RESET on corruption
    console.log("Resetting filesystem.. .");
    const freshFS = {
      "/": { type: "dir", children: ["Downloads","Documents","Music","Videos","Pictures"] },
      "/Downloads": { type: "dir", children: [] },
      "/Documents": { type: "dir", children: [] },
      "/Music": { type: "dir", children: [] },
      "/Videos": { type: "dir", children: [] },
      "/Pictures": { type: "dir", children: [] }
    };
    localStorage.setItem(FS_KEY, JSON.stringify(freshFS));
    return freshFS;
  }
}
function setFS(fs){
  try{
    if(!fs["/"] || !fs["/"].type) {
      console.warn("Invalid FS structure, skipping save");
      return;
    }
    localStorage.setItem(FS_KEY, JSON.stringify(fs));
  }catch(e){
    console.error("FS write error", e);
  }
}

function resetFilesystem() {
  const freshFS = {
    "/": { type: "dir", children: ["Downloads","Documents","Music","Videos","Pictures"] },
    "/Downloads": { type: "dir", children: [] },
    "/Documents": { type: "dir", children: [] },
    "/Music": { type: "dir", children: [] },
    "/Videos": { type: "dir", children: [] },
    "/Pictures": { type: "dir", children: [] }
  };
  localStorage.setItem(FS_KEY, JSON.stringify(freshFS));
  showNotification('Filesystem Reset', 'All files cleared', 'warning', 3000);
  location.reload();
}


const $=id=>document.getElementById(id);
const windowsEl=$('windows'),taskList=$('taskList'),startMenu=$('startMenu');
let zIdx=10,winCount=0;
const winTasks=new Map();

function showNotification(title, message, type = 'info', duration = 4000) {
  const notificationsContainer = $('notifications');
  
  if(notificationsContainer.children.length > 3) {
    notificationsContainer.removeChild(notificationsContainer.firstChild);
  }
  
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  
  const icons = {
    success: '‚úÖ',
    error: '‚ùå',
    warning: '‚ö†Ô∏è',
    info: '‚ÑπÔ∏è'
  };
  
  notification. innerHTML = `
    <div class="notification-icon">${icons[type] || icons.info}</div>
    <div class="notification-content">
      <div class="notification-title">${title}</div>
      <div class="notification-message">${message}</div>
    </div>
    <button class="notification-close">√ó</button>
  `;
  
  notificationsContainer.appendChild(notification);
  
  requestAnimationFrame(() => {
    notification.classList.add('show');
  });
  
  let timeoutId = setTimeout(() => {
    hideNotification(notification);
  }, duration);
  
  notification.querySelector('.notification-close').onclick = () => {
    clearTimeout(timeoutId);
    hideNotification(notification);
  };
}

function hideNotification(notification) {
  notification.classList.remove('show');
  notification.classList.add('hide');
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, 300);
}


const contextMenu = $('contextMenu');
let contextMenuTarget = null;


const fmClipboard = { mode: null, path: null }; 


function buildMenu(items) {
  contextMenu.innerHTML = ''; 
  items.forEach(it => {
    const el = document.createElement('div');
    el.className = 'context-item' + (it.disabled ? ' disabled' : '');
    el.textContent = it.label;
    if (it.disabled) el.style.opacity = '0.4';
    if (it.action && !it.disabled) {
      el.dataset.action = it.action;
      el.addEventListener('click', (ev) => {
        ev.stopPropagation();
        handleContextAction(it.action, it.meta);
        contextMenu.classList.remove('show');
      });
    }
    contextMenu.appendChild(el);
  });
}


function findExplorerTarget(el) {
  const btn = el.closest('[data-path][data-name], [data-f], [data-del], .file-item, #explorerList');
  return btn;
}

function pathFromDataset(el) {
  if (!el) return null;
  if (el.dataset && el.dataset.name && (el.dataset.path !== undefined)) {
    const p = el.dataset.path === '/' ? '/' + el.dataset.name : el.dataset.path + '/' + el.dataset.name;
    return { path: p, name: el.dataset.name, kind: el.dataset.kind || null };
  }
  if (el.dataset && el.dataset.f && el.dataset.path !== undefined) {
    const p = el.dataset.path === '/' ? '/' + el.dataset.f : el.dataset.path + '/' + el.dataset.f;
    return { path: p, name: el.dataset.f, kind: 'file' };
  }
  const inner = el.querySelector && (el.querySelector('[data-path][data-name]') || el.querySelector('[data-f]'));
  if (inner) return pathFromDataset(inner);
  return null;
}
function ensureTrash() {
  const fs = getFS();
  if (!fs['/Trash']) {
    fs['/Trash'] = { type: 'dir', children: [] };
    if (fs['/'] && Array.isArray(fs['/'].children) && !fs['/'].children.includes('Trash')) {
      fs['/'].children.push('Trash');
    }
    setFS(fs);
  }
}
function renameEntryPrompt(path) {
    const fs = getFS();
    const oldName = path.split("/").pop();
    const parent = path.split("/").slice(0, -1).join("/") || "/";
    const entry = fs[path];

    if (!entry) {
        alert("Error: File not found.");
        return;
    }

    const newName = prompt("Rename:", oldName);
    if (!newName || newName.trim() === "" || newName === oldName) return;

    const newPath = parent === "/" ? "/" + newName : parent + "/" + newName;
    if (fs[newPath]) {
        alert("A file/folder with that name already exists.");
        return;
    }

    fs[newPath] = entry;
    delete fs[path];

    if (fs[parent] && fs[parent].children) {
        const idx = fs[parent].children.indexOf(oldName);
        if (idx >= 0) fs[parent].children[idx] = newName;
    }

    setFS(fs);
    showNotification("Renamed", oldName + " ‚Üí " + newName, "success", 2000);

    if (window.currentExplorerRender) window.currentExplorerRender();
}


function moveToTrash(path) {
    const fs = getFS();
    const name = path.split("/").pop();
    const parent = path.split("/").slice(0, -1).join("/") || "/";

    if (!fs[path]) {
        alert("Error: file not found.");
        return;
    }

    delete fs[path];

    if (fs[parent] && Array.isArray(fs[parent].children)) {
        fs[parent].children = fs[parent].children.filter(n => n !== name);
    }


    setFS(fs);

    showNotification("Deleted", name + " removed", "warning", 2000);

    if (window.currentExplorerRender) window.currentExplorerRender();
	
}



function copyEntry(srcPath, destDir) {
  const fs = getFS();
  if (!fs[srcPath]) return false;
  const name = srcPath.split('/').pop();
  const destPath = destDir === '/' ? '/' + name : destDir + '/' + name;
  if (fs[destPath]) {
    let i = 1;
    const dot = name.lastIndexOf('.');
    const ext = dot > 0 ? name.slice(dot) : '';
    const base = dot > 0 ? name.slice(0, dot) : name;
    let candidate = `${base}-${i}${ext}`;
    while (fs[destDir === '/' ? '/' + candidate : destDir + '/' + candidate]) {
      i++;
      candidate = `${base}-${i}${ext}`;
    }
    const finalPath = destDir === '/' ? '/' + candidate : destDir + '/' + candidate;
    fs[finalPath] = JSON.parse(JSON.stringify(fs[srcPath]));
    if (!fs[destDir]) fs[destDir] = { type: 'dir', children: [] };
    fs[destDir].children = fs[destDir].children || [];
    fs[destDir].children.push(candidate);
  } else {
    fs[destPath] = JSON.parse(JSON.stringify(fs[srcPath]));
    if (!fs[destDir]) fs[destDir] = { type: 'dir', children: [] };
    fs[destDir].children = fs[destDir].children || [];
    fs[destDir].children.push(name);
  }
  setFS(fs);
  return true;
}

function moveEntry(srcPath, destDir) {
  const fs = getFS();
  if (!fs[srcPath]) return false;
  const name = srcPath.split('/').pop();
  const destPath = destDir === '/' ? '/' + name : destDir + '/' + name;
  if (fs[destPath]) {
    alert('Destination already has a file/folder named ' + name);
    return false;
  }
  if (!fs[destDir]) fs[destDir] = { type: 'dir', children: [] };
  fs[destDir].children = fs[destDir].children || [];
  fs[destDir].children.push(name);
  const oldParent = srcPath.split('/').slice(0, -1).join('/') || '/';
  if (fs[oldParent] && Array.isArray(fs[oldParent].children)) {
    const idx = fs[oldParent].children.indexOf(name);
    if (idx >= 0) fs[oldParent].children.splice(idx, 1);
  }
  if (fs[srcPath].type === 'dir') {
    const keysToMove = Object.keys(fs).filter(k => k === srcPath || k.startsWith(srcPath + '/'));
    keysToMove.forEach(k => {
      const relative = k.slice(srcPath.length);
      const newKey = destPath + relative;
      fs[newKey] = fs[k];
      delete fs[k];
    });
  } else {
    fs[destPath] = fs[srcPath];
    delete fs[srcPath];
  }
  setFS(fs);
  return true;
}

function renameEntry(srcPath, newName) {
  const fs = getFS();
  if (!fs[srcPath]) return false;
  const parent = srcPath.split('/').slice(0, -1).join('/') || '/';
  const newPath = parent === '/' ? '/' + newName : parent + '/' + newName;
  if (fs[newPath]) {
    alert('A file with that name already exists.');
    return false;
  }
  if (fs[parent] && Array.isArray(fs[parent].children)) {
    const oldName = srcPath.split('/').pop();
    const idx = fs[parent].children.indexOf(oldName);
    if (idx >= 0) fs[parent].children[idx] = newName;
  }
  if (fs[srcPath].type === 'dir') {
    const keysToMove = Object.keys(fs).filter(k => k === srcPath || k.startsWith(srcPath + '/'));
    keysToMove.forEach(k => {
      const relative = k.slice(srcPath.length);
      const newKey = newPath + relative;
      fs[newKey] = fs[k];
      delete fs[k];
    });
  } else {
    fs[newPath] = fs[srcPath];
    delete fs[srcPath];
  }
  setFS(fs);
  return true;
}

async function importFilesTo(files, destDir) {
  if (!files || files.length === 0) return 0;
  const fsObj = getFS();
  let importedCount = 0;
  for (const file of files) {
    const reader = new FileReader();
    await new Promise(res => {
      reader.onload = () => {
        const fileName = file.name;
        const filePath = destDir === '/' ? '/' + fileName : destDir + '/' + fileName;
        if (fsObj[filePath]) {
          let i = 1;
          const dot = fileName.lastIndexOf('.');
          const ext = dot > 0 ? fileName.slice(dot) : '';
          const base = dot > 0 ? fileName.slice(0, dot) : fileName;
          let cand = base + '-' + i + ext;
          while (fsObj[destDir === '/' ? '/' + cand : destDir + '/' + cand]) { i++; cand = base + '-' + i + ext; }
          const finalPath = destDir === '/' ? '/' + cand : destDir + '/' + cand;
          fsObj[finalPath] = { type: 'file', mime: file.type || 'application/octet-stream', data: reader.result };
          fsObj[destDir] = fsObj[destDir] || { type: 'dir', children: [] };
          fsObj[destDir].children = fsObj[destDir].children || [];
          fsObj[destDir].children.push(cand);
        } else {
          fsObj[filePath] = { type: 'file', mime: file.type || 'application/octet-stream', data: reader.result };
          fsObj[destDir] = fsObj[destDir] || { type: 'dir', children: [] };
          fsObj[destDir].children = fsObj[destDir].children || [];
          fsObj[destDir].children.push(fileName);
        }
        importedCount++;
        res();
      };
      reader.onerror = () => res();
      reader.readAsDataURL(file);
    });
  }
  setFS(fsObj);
  return importedCount;
}

document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  contextMenu.classList.remove('show');
  contextMenu.style.left = e.pageX + 'px';
  contextMenu.style.top = e.pageY + 'px';
  contextMenuTarget = e.target;
  const explorerEl = findExplorerTarget(e.target);
  const info = pathFromDataset(explorerEl);

  if (info && e.target.closest && e.target.closest('#explorerList')) {
    const fs = getFS();
    const entry = fs[info.path];
    if (entry && entry.type === 'dir') {
      buildMenu([
        { label: 'Open', action: 'fm_open', meta: { path: info.path } },
        { label: 'New Folder', action: 'fm_newFolder', meta: { path: info.path } },
        { label: 'New File', action: 'fm_newFile', meta: { path: info.path } },
        { label: 'Paste', action: 'fm_paste', disabled: !fmClipboard.mode },
        { label: 'Rename', action: 'fm_rename', meta: { path: info.path } },
        { label: 'Delete', action: 'fm_delete', meta: { path: info.path } },
        { label: 'Properties', action: 'fm_props', meta: { path: info.path } },
      ]);
    } else {
      buildMenu([
        { label: 'Open', action: 'fm_open', meta: { path: info.path } },
        { label: 'Cut', action: 'fm_cut', meta: { path: info.path } },
        { label: 'Copy', action: 'fm_copy', meta: { path: info.path } },
        { label: 'Paste', action: 'fm_paste', disabled: !fmClipboard.mode },
        { label: 'Rename', action: 'fm_rename', meta: { path: info.path } },
        { label: 'Delete', action: 'fm_delete', meta: { path: info.path } },
        { label: 'Properties', action: 'fm_props', meta: { path: info.path } },
      ]);
    }
  } else if (e.target.closest && e.target.closest('#explorerList')) {
    buildMenu([
      { label: 'New Folder', action: 'fm_newFolder', meta: { path: '/' } },
      { label: 'New File', action: 'fm_newFile', meta: { path: '/' } },
      { label: 'Paste', action: 'fm_paste', disabled: !fmClipboard.mode },
      { label: 'Import Files...', action: 'fm_import', meta: { path: '/' } },
      { label: 'Refresh', action: 'refresh' },
    ]);
  } else {
    buildMenu([
      { label: 'Refresh Desktop', action: 'refresh' },
      { label: 'New Text File', action: 'newFile' },
      { label: 'Open Terminal', action: 'terminal' },
      { label: 'Play Snake', action: 'snake' },
      { label: 'Settings', action: 'settings' },
    ]);
  }

  setTimeout(() => contextMenu.classList.add('show'), 10);
});

document.addEventListener('click', () => {
  contextMenu.classList.remove('show');
});

function handleContextAction(action, meta = {}) {
  const fs = getFS();
  switch (action) {
    case 'refresh':
      showNotification('Desktop', 'Desktop refreshed', 'info', 1200);
      break;
    

    case 'newFile': {
      const destDir = meta.path || '/';
      openEditor(); 
      break;
    }

    case 'terminal':
      openTerminal();
      break;

    case 'snake':
      openSnake();
      break;

    case 'settings':
      openSettings();
      break;

    case 'fm_open': {
      const p = meta.path;
      if (!p) return;
      const entry = fs[p];
      if (!entry) { showNotification('Open', 'Item not found', 'error'); return; }
      if (entry.type === 'dir') {
        openExplorer(p);
      } else {
        if (entry.mime && entry.mime.startsWith('image/')) openImageViewer(p);
        else if (entry.mime && entry.mime.startsWith('audio/')) openMusicPlayer(p);
        else if (entry.mime && entry.mime.startsWith('video/')) openVideoPlayer(p);
        else openEditor(p);
      }
      break;
    }

    case 'fm_cut': {
      fmClipboard.mode = 'cut';
      fmClipboard.path = meta.path;
      showNotification('Cut', (meta.path || '').split('/').pop() + ' ready to move', 'info', 2000);
      break;
    }

    case 'fm_copy': {
      fmClipboard.mode = 'copy';
      fmClipboard.path = meta.path;
      showNotification('Copy', (meta.path || '').split('/').pop() + ' copied', 'info', 2000);
      break;
    }

    case 'fm_paste': {
      if (!fmClipboard.mode || !fmClipboard.path) {
        showNotification('Paste', 'Nothing to paste', 'warning', 1800);
        return;
      }
      let destDir = '/';
      if (meta.path) {
        const candidate = meta.path;
        if (fs[candidate] && fs[candidate].type === 'dir') destDir = candidate;
        else destDir = candidate.split('/').slice(0, -1).join('/') || '/';
      } else if (contextMenuTarget) {
        const ex = findExplorerTarget(contextMenuTarget);
        const info = pathFromDataset(ex);
        if (info) {
          if (fs[info.path] && fs[info.path].type === 'dir') destDir = info.path;
          else destDir = info.path.split('/').slice(0, -1).join('/') || '/';
        }
      }

      if (fmClipboard.mode === 'cut') {
        if (fmClipboard.path === destDir || (fmClipboard.path && fmClipboard.path.startsWith(destDir + '/'))) {
          showNotification('Move Failed', 'Cannot move into itself', 'error', 2500);
          return;
        }
        const ok = moveEntry(fmClipboard.path, destDir);
        if (ok) {
          showNotification('Moved', (fmClipboard.path || '').split('/').pop() + ' ‚Üí ' + destDir, 'success', 2000);
          fmClipboard.mode = null; fmClipboard.path = null;
        } else showNotification('Move Failed', 'Could not move item', 'error', 2200);
      } else if (fmClipboard.mode === 'copy') {
        const ok = copyEntry(fmClipboard.path, destDir);
        if (ok) showNotification('Copied', (fmClipboard.path || '').split('/').pop() + ' ‚Üí ' + destDir, 'success', 2000);
        else showNotification('Copy Failed', 'Could not copy item', 'error', 2200);
      }
      break;
    }

    case 'fm_rename': {
      const src = meta.path;
      if (!src) return;

      const oldName = src.split('/').pop();
      const dot = oldName.lastIndexOf(".");
      const base = oldName.substring(0, dot);
      const ext = oldName.substring(dot); 

      const newName = prompt('Rename', base); 
      if (!newName || newName.trim() === '') return;

      const finalName = newName + ext; 

      const parent = src.split('/').slice(0, -1).join('/') || '/';
      const newPath = parent === '/' ? '/' + finalName : parent + '/' + finalName;

      const ok = renameEntry(src, finalName);
      if (ok) showNotification('Renamed', `${oldName} ‚Üí ${finalName}`, 'success', 2000);
      else showNotification('Rename Failed', 'Could not rename', 'error', 2200);

      break;
    }



    case 'fm_delete': {
      const src = meta.path;
      if (!src) return;
      if (!confirm('Delete ' + src.split('/').pop() + '?')) return;
      const ok = moveToTrash(src);
      if (ok) showNotification('Deleted', src.split('/').pop() + ' moved to Trash', 'warning', 2500);
      else showNotification('Delete Failed', 'Could not remove item', 'error', 2200);
      break;
    }

    case 'fm_newFolder': {
      const baseDir = (meta.path && getFS()[meta.path] && getFS()[meta.path].type === 'dir') ? meta.path : '/';
      const name = prompt('Folder name');
      if (!name) return;
      const fs2 = getFS();
      const folderPath = baseDir === '/' ? '/' + name : baseDir + '/' + name;
      if (fs2[folderPath]) { alert('Folder exists'); return; }
      fs2[folderPath] = { type: 'dir', children: [] };
      fs2[baseDir] = fs2[baseDir] || { type: 'dir', children: [] };
      fs2[baseDir].children = fs2[baseDir].children || [];
      fs2[baseDir].children.push(name);
      setFS(fs2);
      showNotification('Folder Created', `${name} created`, 'success', 2000);
      break;
    }
    case 'fm_newFile': {
  let baseDir = '/';
  
  const allWindows = document.querySelectorAll('.window');
  allWindows.forEach(win => {
    const breadcrumbs = win.querySelector('#breadcrumbs');
    if(breadcrumbs) {
      const spans = breadcrumbs.querySelectorAll('span[data-path]');
      if(spans. length > 0) {
        const lastSpan = spans[spans.length - 1];
        baseDir = lastSpan.dataset.path || '/';
      } else if(breadcrumbs.textContent.includes('This PC')) {
        baseDir = '/';
      }
    }
  });
  
  if(meta && meta.path && getFS()[meta.path] && getFS()[meta.path]. type === 'dir') {
    baseDir = meta.path;
  }
  
  console.log('üéØ fm_newFile - Opening editor with baseDir:', baseDir);
  openEditor('', baseDir);
  break;
}
    case 'fm_import': {
      const target = meta.path || '/';
      const inp = document.createElement('input');
      inp.type = 'file';
      inp.multiple = true;
      inp.style.display = 'none';
      inp.onchange = async (ev) => {
        const files = Array.from(ev.target.files || []);
        const count = await importFilesTo(files, target);
        if (count > 0) showNotification('Import Complete', `${count} files imported`, 'success', 3000);
      };
      document.body.appendChild(inp);
      inp.click();
      setTimeout(()=>document.body.removeChild(inp), 2000);
      break;
    }

    case 'fm_props': {
      const p = meta.path;
      if (!p) return;
      const entry = getFS()[p];
      if (!entry) { showNotification('Properties', 'Not found', 'error'); return; }
      makeWin('Properties: ' + p.split('/').pop(), 420, 320, `<pre style="white-space:pre-wrap">${JSON.stringify(entry, null, 2)}</pre>`);
      break;
    }

    default:
      break;
  }

  document.querySelectorAll('#explorerList').forEach(el => {
    const winEl = el.closest('.window');
    if (winEl) {
      const refreshBtn = winEl.querySelector('#btnRefresh');
      if (refreshBtn) refreshBtn.click();
    }
  });


const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
let desktopCardsLoaded = false;

function lazyLoadDesktopCards() {
  if(desktopCardsLoaded) return;
  desktopCardsLoaded = true;
  
  const cards = document.querySelectorAll('.app-card');
  cards.forEach(card => {
    card.style.willChange = 'transform';
  });
}

$('desktopCards').addEventListener('mouseenter', lazyLoadDesktopCards, {once: true});
setTimeout(lazyLoadDesktopCards, 2000); // Fallback: load after 2s
function sfx(name){
  try{
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    if(name==='click'){ o.type='square'; o.frequency.setValueAtTime(1000,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.08, now+0.005); g.gain.exponentialRampToValueAtTime(0.0001, now+0.15); }
    else if(name==='open'){ o.type='sine'; o.frequency.setValueAtTime(600,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.09, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.25); }
    else if(name==='close'){ o.type='sine'; o.frequency.setValueAtTime(250,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.08, now+0.005); g.gain.exponentialRampToValueAtTime(0.0001, now+0.18); }
    else if(name==='error'){ o.type='sawtooth'; o.frequency.setValueAtTime(180,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.12, now+0.005); g.gain.exponentialRampToValueAtTime(0.0001, now+0.35); }
    else if(name==='save'){ o.type='triangle'; o.frequency.setValueAtTime(900,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.07, now+0.005); g.gain.exponentialRampToValueAtTime(0.0001, now+0.2); }
    o.start(now); o.stop(now+0.5);
  }catch(e){}
}

// Clock
function tick(){$('clock').textContent=new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}
tick();setInterval(tick,1000);

// Wallpaper
const wallpaperList = {
  wall1: "#3B82F6",
  wall2: "#6D28D9",
  wall3: "#DC2626",
  wall4: "#059669",
  wall5: "#F97316",
  wall6: "#EC4899",
  wall7: "#06B6D4",
  wall8: "#FACC15",
  wall9: "#334155"
};

function applyWall(){
  const w=localStorage.getItem('wall')||'dark';
  const walls={
    dark:'linear-gradient(135deg,#071124,#0f172a)',
    ocean:'linear-gradient(135deg,#0c4a6e,#0ea5e9)',
    purple:'linear-gradient(135deg,#1e1b4b,#7c3aed)',
    sunset:'linear-gradient(135deg,#7c2d12,#f97316)',
    forest:'linear-gradient(135deg,#064e3b,#10b981)',
    space:'linear-gradient(135deg,#1e1b4b,#312e81)',
    fire:'linear-gradient(135deg,#7f1d1d,#dc2626)',
    ice:'linear-gradient(135deg,#0e7490,#22d3ee)',
    lavender:'linear-gradient(135deg,#4c1d95,#8b5cf6)',
    mint:'linear-gradient(135deg,#065f46,#34d399)',
    rose:'linear-gradient(135deg,#831843,#f472b6)',
    amber:'linear-gradient(135deg,#78350f,#f59e0b)',
    cyan:'linear-gradient(135deg,#155e75,#06b6d4)',
    emerald:'linear-gradient(135deg,#064e3b,#10b981)',
    violet:'linear-gradient(135deg,#4c1d95,#8b5cf6)',
    custom: localStorage.getItem('customWallpaper') || 'linear-gradient(135deg,#071124,#0f172a)'
  };
  
  if (w === 'custom' && localStorage.getItem('customWallpaper')) {
    $('wallpaper').style.backgroundImage = `url(${localStorage.getItem('customWallpaper')})`;
  } else {
    $('wallpaper').style.backgroundImage = walls[w] || walls.dark;
  }
}
applyWall();

// Start menu
$('startBtn').onclick=e=>{e.stopPropagation();startMenu.classList.toggle('open');sfx('click')};
window.addEventListener('click', e => {
  if (!startMenu.contains(e.target) && e.target !== $('startBtn')) startMenu.classList.remove('open');
});

// Desktop & start menu apps
$('desktopCards').onclick=e=>{const c=e.target.closest('.app-card');if(c){sfx('click');openApp(c.dataset.app)}}
$('appsGrid').onclick=e=>{const c=e.target.closest('.app-card-small');if(c){sfx('click');openApp(c.dataset.app);startMenu.classList.remove('open')}}

// Taskbar clicks
taskList.onclick=e=>{const t=e.target.closest('.task-item');if(t){const w=$(t.dataset.win);if(w){w.style.display='flex';w.classList.remove('minimizing');focus(w);sfx('open')}}};

// Make window
function makeWin(title,w,h,content){
  const id='w'+(++winCount);
  const win=document.createElement('div');
  win.className='window';win.id=id;
  win.style.cssText=`width:${w}px;height:${h}px;left:${50+winCount*20}px;top:${50+winCount*20}px;z-index:${++zIdx}`;
  win.innerHTML=`<div class="win-title"><span class="title">${title}</span><div class="win-controls"><button data-act="min">‚àí</button><button data-act="max">‚ñ°</button><button data-act="close">√ó</button></div></div><div class="win-body">${content}</div><div class="resizer">‚Üï</div>`;
  windowsEl.appendChild(win);
  
  const task=document.createElement('div');
  task.className='task-item';task.textContent=title;task.dataset.win=id;
  taskList.appendChild(task);
  winTasks.set(id,task);
  
  win.querySelectorAll('[data-act]').forEach(b=>b.onclick=()=>ctrl(b.dataset.act,win));
  
  let drag=false,sx,sy,ox,oy;
  const tb=win.querySelector('.win-title');
  tb.onmousedown=e=>{
    if(e.target.closest('.win-controls'))return;
    drag=true;
    sx=e.clientX;
    sy=e.clientY;
    ox=parseInt(win.style.left);
    oy=parseInt(win.style.top);
    focus(win);
  };
  window.addEventListener('mousemove',e=>{
    if(drag){
      // Calculate new position
      let newLeft = ox+e.clientX-sx;
      let newTop = oy+e.clientY-sy;
      
      // PREVENT GOING OFF SCREEN
      const minTop = 0;
      const minLeft = -win.offsetWidth + 100;
      const maxLeft = window.innerWidth - 100;
      const maxTop = window.innerHeight - 100;
      
      // Clamp values
      newLeft = Math.max(minLeft, Math.min(newLeft, maxLeft));
      newTop = Math.max(minTop, Math.min(newTop, maxTop));
      
      win.style.left = newLeft + 'px';
      win.style.top = newTop + 'px';
    }
  });
  window.addEventListener('mouseup',()=>drag=false);
  
  let rsz=false,rw,rh,rx,ry;
  const rs=win.querySelector('.resizer');
  rs.onmousedown=e=>{rsz=true;rw=win.offsetWidth;rh=win.offsetHeight;rx=e.clientX;ry=e.clientY;e.preventDefault()};
  window.addEventListener('mousemove',e=>{if(rsz){win.style.width=Math.max(200,rw+e.clientX-rx)+'px';win.style.height=Math.max(150,rh+e.clientY-ry)+'px'}});
  window.addEventListener('mouseup',()=>rsz=false);
  
  focus(win);
  sfx('open');
  return win;
}
function ctrl(act,win){
  const task=winTasks.get(win.id);
  if(act==='close'){
    win.classList.add('closing');
    sfx('close');
    setTimeout(()=>{win.remove();if(task)task.remove();winTasks.delete(win.id)},150);
  }else if(act==='min'){
    win.classList.add('minimizing');
    sfx('click');
    setTimeout(()=>{win.style.display='none';if(task)task.classList.remove('active')},200);
  }else if(act==='max'){
    if(win.dataset.max==='1'){
      win.style.cssText=`width:${win.dataset.ow};height:${win.dataset.oh};left:${win.dataset.ox};top:${win.dataset.oy};z-index:${++zIdx}`;
      win.dataset.max='0';
    }else{
      win.dataset.ow=win.style.width;win.dataset.oh=win.style.height;win.dataset.ox=win.style.left;win.dataset.oy=win.style.top;
      win.style.cssText=`left:0;top:0;width:100%;height:calc(100vh - 46px);z-index:${++zIdx}`;
      win.dataset.max='1';
    }
  }
}
window.makeWin = makeWin;

function focus(win){
  document.querySelectorAll('.window').forEach(w=>w.style.zIndex=10);
  document.querySelectorAll('.task-item').forEach(t=>t.classList.remove('active'));
  win.style.zIndex=++zIdx;
  const task=winTasks.get(win.id);if(task)task.classList.add('active');
}

function openApp(name){
  console.log('Opening app:', name); // Debug line
  
  const apps = {
    explorer: openExplorer,
    editor: openEditor,
    terminal: openTerminal,
    paint: openPaint,
    snake: openSnake,
    calculator: openCalc,
    settings: openSettings,
    about: openAbout,
    browser: openBrowser,
    imageviewer: openImageViewer,
    flappybird: openFlappyBird,
    spaceinvaders: openSpaceInvaders,
    games: openGames,
    game2048: open2048,
    pong: openPong,
	dino: openDino,
	tetris: openTetris,
    music: openMusicPlayer,
    video: openVideoPlayer,
    screenshot: openScreenshotTool,
	chat:openChat
  };
  
  if (apps[name]) {
    console.log('App function found, calling it...'); // Debug line
    apps[name]();
  } else {
    console.log('App not found:', name); // Debug line
    showNotification('Error', `App "${name}" not found`, 'error', 3000);
  }
}


// Explorer
// Explorer - Windows-style file manager
function openExplorer(startPath = "/"){
  const fs = getFS();
  let currentPath = startPath === "/" ? "/" : startPath;
  let history = ["/"];
  let historyIndex = 0;
  
  const winHtml = `
    <div style="
  display:flex;
  align-items:center;
  gap:10px;
  padding:12px;
  background:rgba(255,255,255,0.03);
  border-bottom:1px solid rgba(255,255,255,0.05);
  flex-wrap:wrap">

  <button class="btn" id="btnBack" style="background:rgba(255,255,255,0.08);padding:6px 10px">‚óÄ</button>
  <button class="btn" id="btnForward" style="background:rgba(255,255,255,0.08);padding:6px 10px">‚ñ∂</button>
  <button class="btn" id="btnUp" style="background:rgba(255,255,255,0.08);padding:6px 10px">‚¨Ü</button>

  <div style="flex:1; position:relative;">
      <input 
        id="explorerSearch"
        placeholder="Search files..."
        style="
          width:100%;
          padding:8px 12px;
          border-radius:8px;
          border:1px solid rgba(255,255,255,0.07);
          background:rgba(255,255,255,0.05);
          color:white;
          font-size:13px;" />

      <div id="searchClear" 
        style="
          position:absolute;
          right:10px;
          top:50%;
          transform:translateY(-50%);
          font-size:14px;
          cursor:pointer;
          opacity:0.4;
          display:none;">‚úñ</div>
  </div>
  
  <button class="btn" id="btnImport">üìÅ Import</button>
  <button class="btn" id="btnNewFolder">üìÇ New Folder</button>
  <input type="file" id="fileImporter" multiple style="display:none">

  <button class="btn" id="btnRefresh" style="background:rgba(255,255,255,0.06);padding:6px 10px">üîÑ</button>
</div>

      
      <div style="display:flex;align-items:center;gap:8px;padding:10px 12px;background:rgba(255,255,255,0.02);border-bottom:1px solid rgba(255,255,255,0.05);font-size:12px">
        <span style="color:var(--muted)">üìç</span>
        <div id="breadcrumbs" style="flex:1;display:flex;align-items:center;gap:4px;overflow-x:auto"></div>
      </div>
      
      <div style="display:flex;flex:1;overflow:hidden;gap:10px;padding:10px">
        <div style="width:160px; background:rgba(255,255,255,0.02); border-radius:8px; padding:10px; overflow-y:auto; border:1px solid rgba(255,255,255,0.05); position:relative; z-index:50;">
          <div style="font-size:11px;font-weight:600;color:var(--muted);text-transform:uppercase;margin-bottom:8px">Quick Access</div>
          <div class="sidebarBtn" data-path="/" style="padding:10px 12px;border-radius:6px;cursor:pointer;font-size:13px;transition:all 0.15s;display:flex;align-items:center;gap:8px;user-select:none">üè† This PC</div>
          <div class="sidebarBtn" data-path="/Downloads" style="padding:10px 12px;border-radius:6px;cursor:pointer;font-size:13px;transition:all 0.15s;display:flex;align-items:center;gap:8px;user-select:none">üì• Downloads</div>
          <div class="sidebarBtn" data-path="/Documents" style="padding:10px 12px;border-radius:6px;cursor:pointer;font-size:13px;transition:all 0.15s;display:flex;align-items:center;gap:8px;user-select:none">üìÑ Documents</div>
          <div class="sidebarBtn" data-path="/Music" style="padding:10px 12px;border-radius:6px;cursor:pointer;font-size:13px;transition:all 0.15s;display:flex;align-items:center;gap:8px;user-select:none">üéµ Music</div>
          <div class="sidebarBtn" data-path="/Videos" style="padding:10px 12px;border-radius:6px;cursor:pointer;font-size:13px;transition:all 0.15s;display:flex;align-items:center;gap:8px;user-select:none">üé¨ Videos</div>
          <div class="sidebarBtn" data-path="/Pictures" style="padding:10px 12px;border-radius:6px;cursor:pointer;font-size:13px;transition:all 0.15s;display:flex;align-items:center;gap:8px;user-select:none">üñºÔ∏è Pictures</div>
        </div>
        
        <div style="flex:1; display:flex; gap:10px; overflow:hidden;">
  
  <div id="fileList"
    style="flex:1; overflow:auto; background:rgba(255,255,255,0.01);
    border-radius:8px; border:1px solid rgba(255,255,255,0.05); padding:10px;
    display:flex; flex-direction:column; gap:6px;">
  </div>

  <div id="previewPane"
    style="
      width:260px;
      background:rgba(255,255,255,0.02);
      border-radius:8px;
      border:1px solid rgba(255,255,255,0.05);
      padding:12px;
      display:flex;
      flex-direction:column;
      gap:8px;
      font-size:13px;
      color:var(--muted);">
    
    <div style="font-size:12px; text-transform:uppercase; opacity:0.6;">Preview</div>
    <div id="previewInner" style="flex:1; overflow:auto; opacity:0.5; font-size:12px;">
      Select a file to preview
    </div>

  </div>

</div>

  `;
  
  const win = window.makeWin('File Explorer', 900, 550, winHtml);
  // Make sidebar accept drag events above file list
win.querySelectorAll('.sidebarBtn').forEach(btn => {
  btn.style.position = "relative";
  btn.style.zIndex = "20";
});

  const fileListEl = win.querySelector('#fileList');
  // --- SEARCH + PREVIEW (robust version) ---
const searchInput = win.querySelector('#explorerSearch');
const searchClear = win.querySelector('#searchClear');
const previewPane = win.querySelector('#previewPane');
const previewInner = win.querySelector('#previewInner');

searchClear.style.display = 'none';

// recursive search helper: returns array of { name, path, entry }
function searchRecursive(path, q, results = []) {
  const entry = fs[path];
  if (!entry) return results;

  // Match files
  if (entry.type === "file") {
    const name = path.split("/").pop();
    if (name.toLowerCase().includes(q.toLowerCase())) {
      results.push({ path, name, entry });
    }
    return results;
  }

  // Match folders
  if (entry.type === "dir") {
    const name = path === "/" ? "/" : path.split("/").pop();
    if (name.toLowerCase().includes(q.toLowerCase())) {
      results.push({ path, name, entry });
    }

    // Recurse into children
    if (entry.children) {
      for (const child of entry.children) {
        const childPath = path === "/" ? `/${child}` : `${path}/${child}`;
        searchRecursive(childPath, q, results);
      }
    }
  }

  return results;
}


// Render search results (if q is empty: show normal render)
function globalSearch(q) {
  const results = [];

  for (const path in fs) {
    const entry = fs[path];
    const name = path.split("/").pop() || "/";

    if (name.toLowerCase().includes(q.toLowerCase())) {
      results.push({ path, name, entry });
    }
  }

  return results;
}

function renderSearch(q) {
  q = (q||'').trim().toLowerCase();
  if(!q) {
    render(); // fallback to normal view when empty
    previewInner.innerHTML = 'Select a file to preview';
    previewInner.style.opacity = 0.5;
    searchClear.style.display = 'none';
    return;
  }

  searchClear.style.display = 'block';
  fileListEl.innerHTML = '';

  // Search from currentPath (so user searches inside the folder they are browsing)
  const results = globalSearch(q);

  if(results.length === 0) {
    fileListEl.innerHTML = `
      <div style="padding:20px;text-align:center;color:var(--muted)">
        No results for "<b>${q}</b>"
      </div>`;
    previewInner.innerHTML = 'No preview available';
    previewInner.style.opacity = 0.5;
    return;
  }

  // Group results by parent path
  const groups = results.reduce((acc, r) => {
    (acc[r.path] = acc[r.path] || []).push(r);
    return acc;
  }, {});

  const frag = document.createDocumentFragment();

  Object.keys(groups).forEach(parent => {
    const header = document.createElement('div');
    header.style.cssText = 'font-size:12px;padding:8px 6px;color:var(--muted);opacity:0.8;border-bottom:1px solid rgba(255,255,255,0.02)';
    header.textContent = parent === '/' ? 'This PC' : parent;
    frag.appendChild(header);

    groups[parent].forEach(r => {
      const row = document.createElement('div');
      row.style.cssText = 'display:flex;align-items:center;padding:10px;border-radius:8px;cursor:pointer;gap:8px';
      row.onmouseover = () => row.style.background = 'rgba(255,255,255,0.03)';
      row.onmouseout = () => row.style.background = '';

      const icon = document.createElement('div');
      icon.style.cssText = 'font-size:20px;width:38px;text-align:center';
      if(r.entry.type === 'dir') icon.textContent = 'üìÅ';
      else if(r.entry.mime && r.entry.mime.startsWith('image/')) icon.textContent = 'üñºÔ∏è';
      else if(r.entry.mime && r.entry.mime.startsWith('audio/')) icon.textContent = 'üéµ';
      else if(r.entry.mime && r.entry.mime.startsWith('video/')) icon.textContent = 'üé¨';
      else icon.textContent = 'üìÑ';

      const txt = document.createElement('div');
      txt.style.cssText = 'flex:1;min-width:0';
      txt.innerHTML = `<div style="font-weight:600;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${r.name}</div>
                       <div style="font-size:11px;color:var(--muted)">${r.path === '/' ? '/' : r.path}</div>`;

      row.appendChild(icon);
      row.appendChild(txt);

      // click: show preview and allow open
      row.onclick = () => {
        showPreview(r.name, r.entry, r.itemPath);
      };

      frag.appendChild(row);
    });
  });

  fileListEl.appendChild(frag);
}

// showPreview now accepts optional absolute path
function showPreview(name, entry, itemPath) {
  previewInner.style.opacity = 1;
  previewInner.innerHTML = ''; // clear

  // If folder
  if(entry.type === 'dir') {
    previewInner.innerHTML = `
      <div style="font-size:28px">üìÅ</div>
      <div style="margin-top:8px;font-weight:700">${name}</div>
      <div style="font-size:12px;opacity:0.7;margin-top:6px">Folder ‚Ä¢ ${ (entry.children||[]).length } items</div>
      <div style="margin-top:8px"><button class="btn" id="openInFolder">Open Folder</button></div>
    `;
    const btn = previewInner.querySelector('#openInFolder');
    btn.onclick = () => {
      // navigate to that folder
      const p = itemPath || (currentPath === '/' ? '/' + name : currentPath + '/' + name);
      navigate(p);
    };
    return;
  }

  // If image
  if(entry.mime && entry.mime.startsWith('image/')) {
    const img = document.createElement('img');
    img.src = entry.data;
    img.style.cssText = 'max-width:100%;border-radius:8px;display:block;margin-bottom:8px';
    previewInner.appendChild(img);
    const title = document.createElement('div');
    title.innerHTML = `<div style="font-weight:700">${name}</div><div style="font-size:12px;opacity:0.7;margin-top:6px">Image file</div>`;
    previewInner.appendChild(title);

    const exportBtn = document.createElement('button');
    exportBtn.className = 'btn';
    exportBtn.style.marginTop = '8px';
    exportBtn.textContent = 'Export';
    exportBtn.onclick = () => {
      const a = document.createElement('a');
      a.href = entry.data;
      a.download = name;
      a.click();
      showNotification('Exported', name + ' downloaded', 'success', 2000);
    };
    previewInner.appendChild(exportBtn);
    return;
  }

  // For audio/video show metadata
  if(entry.mime && (entry.mime.startsWith('audio/') || entry.mime.startsWith('video/'))) {
    previewInner.innerHTML = `<div style="font-size:28px">${ entry.mime.startsWith('audio/') ? 'üéµ' : 'üé¨' }</div>
      <div style="margin-top:8px;font-weight:700">${name}</div>
      <div style="font-size:12px;opacity:0.7;margin-top:6px">${entry.mime}</div>
      <div style="margin-top:8px">
        <button class="btn" id="previewPlay">Play</button>
      </div>`;
    const playBtn = previewInner.querySelector('#previewPlay');
    playBtn.onclick = () => {
      const media = document.createElement(entry.mime.startsWith('audio/') ? 'audio' : 'video');
      media.src = entry.data;
      media.controls = true;
      media.style.width = '100%';
      previewInner.appendChild(media);
      media.play().catch(()=>{});
      playBtn.disabled = true;
    };
    return;
  }

  // Fallback: text preview (attempt to decode data URL)
  let textPreview = 'No preview available';
  try {
    if(entry.data && typeof entry.data === 'string' && entry.data.startsWith('data:')) {
      const comma = entry.data.indexOf(',');
      const b64 = entry.data.slice(comma + 1);
      // attempt to decode (might be binary) - we guard length
      const decoded = atob(b64);
      textPreview = decoded.slice(0, 800); // show up to 800 chars
      // escape HTML
      textPreview = textPreview.replace(/[&<>]/g, c => (c === '&' ? '&amp;' : c === '<' ? '&lt;' : '&gt;'));
    }
  } catch (err) {
    textPreview = 'No preview available';
  }

  previewInner.innerHTML = `
  <div style="font-size:28px">üìÑ</div>
  <div style="margin-top:8px;font-weight:700">${name}</div>
  <div style="font-size:12px;opacity:0.7;margin-top:6px">${entry.mime || 'File'}</div>

  <pre style="
      white-space:pre-wrap;
      font-size:11px;
      opacity:0.9;
      max-height:220px;
      overflow:auto;
      margin-top:12px;
      padding:6px;
      background:rgba(255,255,255,0.03);
      border-radius:6px;
  ">${textPreview}</pre>

  <div style="display:flex;gap:8px;margin-top:12px;">
      <button id="openFileBtn" class="btn" style="flex:1;">üìÇ Open</button>
      <button id="revealBtn" class="btn" style="flex:1;background:rgba(255,255,255,0.07)">üìç Reveal</button>
  </div>
`;


  const openFileBtn = previewInner.querySelector('#openFileBtn');
  const revealBtn = previewInner.querySelector('#revealBtn');
  openFileBtn.onclick = () => {
    // open the file (editor/music/image) using your existing handlers
    if(entry.mime && entry.mime.startsWith('image/')) openImageViewer(itemPath);
    else if(entry.mime && entry.mime.startsWith('audio/')) openMusicPlayer(itemPath);
    else if(entry.mime && entry.mime.startsWith('video/')) openVideoPlayer(itemPath);
    else openEditor(itemPath, currentPath);
  };
  revealBtn.onclick = () => {
    // navigate to containing folder and highlight
    const folder = (itemPath || (currentPath === '/' ? '/' + name : currentPath + '/' + name)).split('/').slice(0,-1).join('/') || '/';
    navigate(folder);
    // simple highlight after render
    setTimeout(()=> {
      const nodes = Array.from(fileListEl.querySelectorAll('div'));
      const target = nodes.find(n => n.textContent && n.textContent.includes(name));
      if(target) {
        target.style.transition = 'box-shadow .2s';
        target.style.boxShadow = '0 0 0 3px rgba(37,99,235,0.12)';
        setTimeout(()=> target.style.boxShadow = '', 1200);
      }
    }, 120);
  };
}
function openFileContextMenu(path, x, y) {
    const menu = document.querySelector('#fileContextMenu');
    if (!menu) return;

    menu.style.display = "block";
    menu.style.left = x + "px";
    menu.style.top = y + "px";

    menu.querySelector("#ctxOpen").onclick = () => openEditor(path);
    menu.querySelector("#ctxRename").onclick = () => renameEntryPrompt(path);
    menu.querySelector("#ctxDelete").onclick = () => moveToTrash(path);
}
document.addEventListener("click", () => {
    const menu = document.querySelector('#fileContextMenu');
    if (menu) menu.style.display = "none";
});


// wire input
searchInput.oninput = () => {
  const q = searchInput.value.trim();
  renderSearch(q);
};
searchInput.onkeydown = (e) => {
  if(e.key === 'Escape') {
    searchInput.value = '';
    render();
    previewInner.innerHTML = 'Select a file to preview';
    previewInner.style.opacity = 0.5;
    searchClear.style.display = 'none';
  }
};
searchClear.onclick = () => {
  searchInput.value = '';
  render();
  previewInner.innerHTML = 'Select a file to preview';
  previewInner.style.opacity = 0.5;
  searchClear.style.display = 'none';
};

  function showPreview(name, entry) {
  previewInner.style.opacity = 1;

  if (entry.type === "dir") {
    previewInner.innerHTML = `
      <div style="font-size:32px">üìÅ</div>
      <div><b>${name}</b></div>
      <div style="font-size:12px;opacity:0.6;">Folder</div>`;
    return;
  }

  if (entry.mime && entry.mime.startsWith("image/")) {
    previewInner.innerHTML = `
      <img src="${entry.data}" style="max-width:100%;border-radius:8px;"/>
      <div><b>${name}</b></div>
      <div style="font-size:12px;opacity:0.6;">Image File</div>`;
    return;
  }

  const textPreview = entry.data ? atob(entry.data.split(",")[1]).slice(0, 500) : "";

  previewInner.innerHTML = `
    <div style="font-size:32px">üìÑ</div>
    <div><b>${name}</b></div>
    <pre style="white-space:pre-wrap; font-size:11px; opacity:0.8; max-height:200px; overflow:auto; margin-top:8px;">
${textPreview || "No preview available"}
    </pre>
  `;
}

  function renderSearch(q) {
  fileListEl.innerHTML = "";
  previewInner.innerHTML = "Select a file to preview";
  previewInner.style.opacity = 0.5;

  const currentDir = fs[currentPath];
  if (!currentDir || !currentDir.children) return;

  const results = currentDir.children.filter(name =>
    name.toLowerCase().includes(q)
  );

  if (results.length === 0) {
    fileListEl.innerHTML = `
      <div style="padding:20px;text-align:center;color:var(--muted)">
        No results for "<b>${q}</b>"
      </div>`;
    return;
  }

  const frag = document.createDocumentFragment();
  results.forEach(name => {
    const itemPath = currentPath === "/" ? "/" + name : currentPath + "/" + name;
    const entry = fs[itemPath];
    if (!entry) return;

    const item = createFileItem(name, itemPath, entry);
    frag.appendChild(item);

    // LEFT CLICK
item.onclick = () => showPreview(name, entry);

// RIGHT CLICK ‚Äî THIS FIXES YOUR PROBLEM
item.oncontextmenu = (e) => {
    e.preventDefault();       // stop browser menu
    e.stopPropagation();      // stop desktop menu from opening
    openFileContextMenu(itemPath, e.pageX, e.pageY);
};


    // RIGHT CLICK ‚Üí file context menu (and stop desktop menu)
    item.oncontextmenu = (e) => {
        e.preventDefault();
        e.stopPropagation();
        openFileContextMenu(itemPath, e.pageX, e.pageY);
    };
});


  fileListEl.appendChild(frag);
}

  const breadcrumbsEl = win.querySelector('#breadcrumbs');
  let draggedItem = null;
  
  function renderBreadcrumbs() {
    breadcrumbsEl.innerHTML = '';
    
    if(currentPath === "/") {
      const crumb = document.createElement('span');
      crumb.textContent = 'This PC';
      crumb.style.cssText = 'padding:4px 8px;cursor:pointer;border-radius:4px;background:rgba(59,130,246,0.1);color:var(--accent)';
      breadcrumbsEl.appendChild(crumb);
      return;
    }
    
    const parts = currentPath.split('/'). filter(p => p);
    let accumulated = '';
    
    const rootCrumb = document.createElement('span');
    rootCrumb. textContent = 'This PC';
    rootCrumb.style.cssText = 'padding:4px 8px;cursor:pointer;border-radius:4px;transition:all 0.15s';
    rootCrumb.onclick = () => navigate('/');
    rootCrumb.onmouseover = () => rootCrumb.style.background = 'rgba(59,130,246,0.2)';
    rootCrumb.onmouseout = () => rootCrumb.style.background = '';
    breadcrumbsEl.appendChild(rootCrumb);
    
    parts.forEach((part, idx) => {
      accumulated += '/' + part;
      
      const sep = document.createElement('span');
      sep.textContent = '‚Ä∫';
      sep.style.color = 'var(--muted)';
      sep.style.opacity = '0.5';
      breadcrumbsEl.appendChild(sep);
      
      const crumb = document.createElement('span');
      crumb.textContent = part;
      crumb.dataset.path = accumulated;
      const isLast = idx === parts.length - 1;
      crumb.style.cssText = 'padding:4px 8px;cursor:pointer;border-radius:4px;transition:all 0.15s;' + (isLast ? 'color:var(--accent);font-weight:600;background:rgba(59,130,246,0.1)' : '');
      crumb.onclick = () => navigate(crumb.dataset.path);
      crumb.onmouseover = () => { if(!isLast) crumb. style.background = 'rgba(59,130,246,0. 2)'; };
      crumb.onmouseout = () => { if(!isLast) crumb.style. background = ''; };
      breadcrumbsEl.appendChild(crumb);
    });
  }
  
  function navigate(path) {
    currentPath = path;
    history = history.slice(0, historyIndex + 1);
    history.push(path);
    historyIndex = history.length - 1;
    render();
  }
  
  function createFileItem(name, itemPath, entry) {
    const item = document.createElement('div');
item.classList.add("file-item");

    item.draggable = true;
    item.style.cssText = 'display:flex;align-items:center;padding:12px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);border-radius:8px;cursor:pointer;transition:all 0.15s;user-select:none';
    
    const isFolder = entry.type === 'dir';
    let icon = 'üìÑ';
    if(isFolder) icon = 'üìÅ';
    else if(entry.mime && entry.mime.startsWith('image/')) icon = 'üñºÔ∏è';
    else if(entry.mime && entry.mime. startsWith('audio/')) icon = 'üéµ';
    else if(entry. mime && entry.mime.startsWith('video/')) icon = 'üé¨';
    
    const sizeText = isFolder ? 'Folder' : (entry.data ?  Math.ceil(entry.data. length / 1024) + ' KB' : '0 KB');
    
        // inside createFileItem(...)
    item.innerHTML = `
      <div style="font-size:28px;width:40px;text-align:center;margin-right:12px">${icon}</div>
      <div style="flex:1;min-width:0">
        <div style="font-weight:600;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${name}</div>
        <div style="font-size:11px;color:var(--muted)">${sizeText}</div>
      </div>
      <div style="display:flex;gap:6px;opacity:0;transition:opacity 0.15s" class="actions">
        <button class="act-open" style="padding:4px 8px;background:rgba(59,130,246,0.2);border:none;border-radius:4px;color:inherit;cursor:pointer;font-size:11px">Open</button>
        <button class="act-delete" style="padding:4px 8px;background:rgba(239,68,68,0.2);border:none;border-radius:4px;color:inherit;cursor:pointer;font-size:11px">Delete</button>
        ${entry.mime && entry.mime.startsWith('image/') ? `<button class="act-export" style="padding:4px 8px;background:rgba(16,185,129,0.12);border:none;border-radius:4px;color:inherit;cursor:pointer;font-size:11px">Export</button>` : ''}
      </div>
    `;

    
    item.onmouseover = () => {
      item.style.background = 'rgba(255,255,255,0.08)';
      item.querySelector('.actions').style.opacity = '1';
    };
    item.onmouseout = () => {
      item.style.background = 'rgba(255,255,255,0.03)';
      item.querySelector('.actions'). style.opacity = '0';
    };
    
    item. onclick = e => {
      if(e.target.closest('.actions')) return;
      if(isFolder) navigate(itemPath);
      else if(entry.mime && entry.mime.startsWith('image/')) openImageViewer(itemPath);
      else if(entry.mime && entry. mime.startsWith('audio/')) openMusicPlayer(itemPath);
      else if(entry.mime && entry.mime.startsWith('video/')) openVideoPlayer(itemPath);
      else openEditor(itemPath, currentPath);
    };
    
    const actionBtns = item.querySelectorAll('.actions button');
    actionBtns[0].onclick = e => {
      e.stopPropagation();
      if(isFolder) navigate(itemPath);
      else if(entry. mime && entry.mime.startsWith('image/')) openImageViewer(itemPath);
      else openEditor(itemPath, currentPath);
    };
    
    actionBtns[1].onclick = e => {
      e.stopPropagation();
      if(confirm('Delete ' + name + '?')) {
        const parentPath = currentPath === "/" ? "/" : currentPath;
        if(fs[parentPath] && fs[parentPath].children) {
          const idx = fs[parentPath].children. indexOf(name);
          if(idx >= 0) fs[parentPath]. children.splice(idx, 1);
        }
        delete fs[itemPath];
        setFS(fs);
        showNotification('Deleted', name + ' removed', 'warning', 2500);
        render();
      }
    };
    const exportBtn = item.querySelector('.act-export');
    if (exportBtn) {
      exportBtn.onclick = (e) => {
        e.stopPropagation();
        const fs = getFS();
        const file = fs[itemPath];
        if(!file || !file.data) {
          showNotification('Export Failed', 'File data missing', 'error', 2500);
          return;
        }
        // download the data URL
        const a = document.createElement('a');
        a.href = file.data;
        a.download = name;
        a.click();
        showNotification('Exported', name + ' downloaded', 'success', 2500);
      };
    }
    
    item.ondragstart = () => {
      draggedItem = itemPath;
      e.dataTransfer.effectAllowed = "move";
      item.style.opacity = '0.5';
    };
    item.ondragend = () => item.style.opacity = '1';
    item.ondragover = e => {
      e.preventDefault();
      if(isFolder && draggedItem && draggedItem !== itemPath) {
        item.style.background = 'rgba(59,130,246,0.3)';
      }
    };
    item.ondragleave = () => item.style.background = 'rgba(255,255,255,0.03)';
    item.ondrop = e => {
      e. preventDefault();
      item.style.background = 'rgba(255,255,255,0.03)';
      if(isFolder && draggedItem && draggedItem !== itemPath) {
        const dragName = draggedItem.split('/'). pop();
        const newPath = itemPath + '/' + dragName;
        if(! fs[newPath]) {
          fs[newPath] = fs[draggedItem];
          if(fs[itemPath] && fs[itemPath].children) fs[itemPath].children.push(dragName);
          const oldParent = draggedItem.split('/').slice(0, -1).join('/') || '/';
          if(fs[oldParent] && fs[oldParent].children) {
            const idx = fs[oldParent].children.indexOf(dragName);
            if(idx >= 0) fs[oldParent].children.splice(idx, 1);
          }
          delete fs[draggedItem];
          setFS(fs);
          showNotification('Moved', dragName + ' moved', 'success', 2000);
          render();
        }
      }
      draggedItem = null;
    };

item.oncontextmenu = (e) => {
    e.preventDefault();     // stop browser menu
    e.stopPropagation();    // stop desktop menu
    openFileContextMenu(itemPath, e.pageX, e.pageY);
};

    return item;
  }
  
  function render() {
    window.currentExplorerRender = render;
    renderBreadcrumbs();
    fileListEl.innerHTML = '';
    
    const currentDir = fs[currentPath === "/" ? "/" : currentPath];
    
    if(! currentDir || ! currentDir.children) {
      fileListEl.innerHTML = '<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;color:var(--muted);text-align:center"><div style="font-size:48px;margin-bottom:16px;opacity:0.3">üìÅ</div><div>Empty Folder</div><div style="font-size:11px;margin-top:8px">Drag files here or use Import button</div></div>';
      return;
    }
    
    const fragment = document.createDocumentFragment();
    
    if(currentPath !== "/") {
      const upItem = document.createElement('div');
      upItem.style.cssText = 'display:flex;align-items:center;padding:12px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);border-radius:8px;cursor:pointer;transition:all 0. 15s';
      upItem.innerHTML = '<div style="font-size:28px;width:40px;text-align:center;margin-right:12px">üìÇ</div><div style="flex:1"><div style="font-weight:600;font-size:13px">..</div><div style="font-size:11px;color:var(--muted)">Parent Folder</div></div>';
      upItem.onmouseover = () => upItem.style.background = 'rgba(255,255,255,0.08)';
      upItem.onmouseout = () => upItem.style.background = 'rgba(255,255,255,0.03)';
      upItem.onclick = () => {
        const parts = currentPath.split('/'). filter(p => p);
        parts.pop();
        navigate(parts.length ? '/' + parts.join('/') : '/');
      };
      fragment.appendChild(upItem);
    }
    
    const children = currentDir.children || [];
    children.forEach(name => {
      const itemPath = currentPath === "/" ? "/" + name : currentPath + "/" + name;
      const entry = fs[itemPath];
      if(! entry) return;
      const item = createFileItem(name, itemPath, entry);
      fragment.appendChild(item);
    });
    
    fileListEl. appendChild(fragment);
  }
  
  // SETUP ALL BUTTON HANDLERS
  win.querySelector('#btnBack').onclick = () => {
    if(historyIndex > 0) {
      historyIndex--;
      currentPath = history[historyIndex];
      render();
    }
  };
 win.querySelectorAll('.sidebarBtn').forEach(side => {

    // CLICK WORKS AGAIN
    side.onclick = () => navigate(side.dataset.path);

    // allow drop
    side.ondragover = e => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
        side.style.background = 'rgba(59,130,246,0.25)';
    };

    side.ondragenter = e => {
        e.preventDefault();
        side.style.background = 'rgba(59,130,246,0.35)';
    };

    side.ondragleave = () => {
        side.style.background = '';
    };

    side.ondrop = e => {
        e.preventDefault();
        e.stopPropagation();
        side.style.background = '';

        if (!draggedItem) return;

        const fs = getFS();
        const dest = side.dataset.path;

        const name = draggedItem.split("/").pop();
        const newPath = dest === "/" ? "/" + name : dest + "/" + name;

        if (!fs[dest]) fs[dest] = { type:"dir", children:[] };

        if (!fs[newPath]) {
            fs[newPath] = fs[draggedItem];

            const old = draggedItem.split("/").slice(0,-1).join("/") || "/";
            fs[old].children = fs[old].children.filter(n => n !== name);
            fs[dest].children.push(name);

            delete fs[draggedItem];
            setFS(fs);
            render();
        }

        draggedItem = null;
    };

    // FIX CLICK BLOCKED AFTER DND
    side.onmouseup = () => {
        side.style.pointerEvents = "auto";
    };

});


  
  win.querySelector('#btnForward').onclick = () => {
    if(historyIndex < history.length - 1) {
      historyIndex++;
      currentPath = history[historyIndex];
      render();
    }
  };
  
  win.querySelector('#btnUp').onclick = () => {
    const parts = currentPath.split('/'). filter(p => p);
    parts.pop();
    navigate(parts.length ? '/' + parts.join('/') : '/');
  };
  
  win.querySelector('#btnRefresh').onclick = () => render();
  
  win.querySelector('#btnNewFolder').onclick = () => {
    const name = prompt('Folder name');
    if(! name) return;
    const folderPath = currentPath === "/" ?  "/" + name : currentPath + "/" + name;
    if(fs[folderPath]) {
      alert('Already exists');
      return;
    }
    fs[folderPath] = { type: 'dir', children: [] };
    if(! fs[currentPath]) fs[currentPath] = { type: 'dir', children: [] };
    fs[currentPath].children. push(name);
    setFS(fs);
    showNotification('Created', name + ' folder created', 'success', 2500);
    render();
  };
  
  const importer = win.querySelector('#fileImporter');
  win.querySelector('#btnImport').onclick = () => importer.click();
  
  importer.onchange = async e => {
    const files = Array.from(e.target.files || []);
    for(const file of files) {
      const reader = new FileReader();
      await new Promise(res => {
        reader.onload = () => {
          const filePath = currentPath === "/" ? "/" + file. name : currentPath + "/" + file.name;
          fs[filePath] = { type: 'file', mime: file.type || 'application/octet-stream', data: reader.result };
          if(! fs[currentPath]) fs[currentPath] = { type: 'dir', children: [] };
          if(! fs[currentPath].children. includes(file.name)) fs[currentPath].children.push(file.name);
          res();
        };
        reader. readAsDataURL(file);
      });
    }
    setFS(fs);
    fileListEl.appendChild(fragment);
    showNotification('Import', files.length + ' files imported', 'success', 3000);
    render();
  };
  
  // FIXED: Sidebar buttons NOW WORK
  // --- ENABLE DROP ON SIDEBAR SHORTCUTS ---
win.querySelectorAll('.sidebarBtn').forEach(side => {

  // Allow drop
  side.ondragover = e => {
    e.preventDefault();
    side.style.background = 'rgba(59,130,246,0.3)';
  };

  side.ondragleave = () => {
    side.style.background = '';
  };

  side.ondrop = e => {
    e.preventDefault();
    side.style.background = '';

    if (!draggedItem) return;

    const dest = side.dataset.path;   // "/Documents" etc.
    const fs = getFS();
    const dragName = draggedItem.split('/').pop();
    const newPath = dest === "/" ? "/" + dragName : dest + "/" + dragName;

    // Create target folder if missing
    if (!fs[dest]) fs[dest] = { type: 'dir', children: [] };

    // Move file
    if (!fs[newPath]) {
      fs[newPath] = fs[draggedItem];

      // Add to new folder
      fs[dest].children.push(dragName);

      // Remove from old folder
      const oldParent = draggedItem.split("/").slice(0, -1).join("/") || "/";
      const idx = fs[oldParent].children.indexOf(dragName);
      if (idx >= 0) fs[oldParent].children.splice(idx, 1);

      delete fs[draggedItem];
      setFS(fs);
      showNotification('Moved', dragName + ' moved to ' + dest, 'success', 2500);
      render();
    }

    draggedItem = null;
  };
});

  
  render();
  return win;
}



// Editor
// Editor - FIXED to save to Documents folder

    
async function openEditor(name='', saveLocation=''){
  console.log('üìù openEditor called with:', {name, saveLocation});
  const fs = await getFS();
  const content = fs[name] ?   (fs[name].data || fs[name]) : '';

  
  // DETERMINE SAVE LOCATION
  let defaultSaveLocation = saveLocation || '/Documents/';
  
  const win=makeWin('Editor',600,420,`
    <div style="display:flex;flex-direction:column;height:100%">
      <div style="display:flex;gap:6px;margin-bottom:8px;align-items:center">
        <input class="input" id="fname" value="${name||'untitled. txt'}" style="flex:1" placeholder="filename">
        <div class="small" style="color:var(--muted);padding:0 8px">üìÅ ${defaultSaveLocation}</div>
        <button class="btn" id="saveF">üíæ Save</button>
      </div>
      <textarea id="farea" style="flex:1;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.05);border-radius:6px;color:inherit;padding:8px;resize:none">${content}</textarea>
    </div>
  `);
  
  win.querySelector('#saveF').onclick=async ()=>{
    const fsObj = await getFS();
    // Get filename from input
let inputName = win.querySelector('#fname').value.trim() || 'untitled.txt';

// Extract original extension from the OPENED file
let originalExt = ".txt";
if (name && name.includes(".")) {
  originalExt = name.substring(name.lastIndexOf("."));
}

// Force the extension to stay the same
let baseOnly = inputName.replace(/\.[^.]+$/, ""); // remove user-entered extension
const fileName = baseOnly + originalExt; // restore original extension

    
    // IMPORTANT: Use saveLocation if provided (not empty and not default)
    let filePath;
    if (name && name. includes('/')) {
      // Editing existing file - keep original path
      filePath = name;
    } else if (saveLocation && saveLocation !== '/' && saveLocation !== '/Documents/') {
      // Use provided location (from sidebar click)
      filePath = saveLocation === '/' ? '/' + fileName : saveLocation + '/' + fileName;
    } else {
      // Default to Documents
      filePath = '/Documents/' + fileName;
    }
    
    console.log('Saving to:', filePath, 'saveLocation was:', saveLocation); // DEBUG
    
    // Save the file content
    fsObj[filePath] = { 
      type: 'file', 
      mime: 'text/plain', 
      data: win.querySelector('#farea').value 
    };
    
    // Ensure the parent folder exists
    const parentPath = filePath.split('/').slice(0, -1).join('/') || '/';
    if (!  fsObj[parentPath]) {
      fsObj[parentPath] = { type: 'dir', children: [] };
    }
    
    // Add to parent folder's children
    const fileName_only = filePath.split('/').pop();
    if (!  fsObj[parentPath].children. includes(fileName_only)) {
      fsObj[parentPath].children.push(fileName_only);
    }
    
    await setFS(fsObj);
    showNotification('File Saved', `${fileName} was saved to ${parentPath}`, 'success', 4000);
    sfx('save');
    ctrl('close', win); // Close editor after saving
  };
}


function openTerminal() {
  const win = makeWin(
    "Terminal",
    650,
    380,
    `
      <div class="terminal-frame">

        <div class="terminal-toolbar">
          <button class="terminal-zoom-btn" id="tZoomOut">‚àí</button>
          <button class="terminal-zoom-btn" id="tZoomIn">+</button>
          <button class="terminal-zoom-btn" id="tZoomReset">100%</button>
        </div>

        <div id="tout" class="terminal-output"></div>

        <div class="terminal-input-row">
          <input id="tin" class="terminal-input" placeholder="Enter command‚Ä¶">
          <button id="trun" class="terminal-run-btn">Run</button>
        </div>

      </div>
    `
  );

  // DOM
  const out = win.querySelector("#tout");
  const inp = win.querySelector("#tin");

  // Zoom system
  let zoom = 13;
  function applyZoom() {
    document.documentElement.style.setProperty("--termFont", zoom + "px");
  }

  win.querySelector("#tZoomIn").onclick = () => {
    zoom++;
    applyZoom();
  };

  win.querySelector("#tZoomOut").onclick = () => {
    zoom = Math.max(8, zoom - 1);
    applyZoom();
  };

  win.querySelector("#tZoomReset").onclick = () => {
    zoom = 13;
    applyZoom();
  };

  // terminal logic
  let cwd = "/";

  const append = (txt) => {
    out.innerHTML += txt;
    out.scrollTop = out.scrollHeight;
  };

  const run = () => {
    const raw = inp.value.trim();
    if (!raw) return;

    append(`\n$ ${raw}\n`);
    exec(raw, out, { cwd, setCwd: (v) => (cwd = v), append });

    inp.value = "";
  };

  win.querySelector("#trun").onclick = run;
  inp.onkeydown = (e) => {
    if (e.key === "Enter") run();
  };
}


/* ---------- helper: autocomplete ---------- */
function doAutocomplete(inputEl, cwd) {
  const val = inputEl.value;
  const parts = val.split(/\s+/);
  const last = parts.pop();
  // if no token, nothing to autocomplete
  if(last === undefined) return;
  const token = last;
  const fs = getFS() || {};

  // build candidates: children of cwd + root basenames + global paths
  const candidates = new Set();

  // children of cwd
  const cwdEntry = fs[cwd];
  if(cwdEntry && cwdEntry.children) {
    cwdEntry.children.forEach(name => candidates.add(name));
  }

  // all basenames
  for(const key in fs) {
    const b = key.split('/').pop();
    if(b) candidates.add(b);
  }

  // also allow commands
  const commands = ['ls','cd','pwd','cat','rm','touch','write','open','img','echo','clear','date','time','find','cp','mv','rename','mkdir','rmdir','file','du','size','stats','export','help'];
  commands.forEach(c => candidates.add(c));

  const matches = Array.from(candidates).filter(x=> typeof x === 'string' && x.toLowerCase().startsWith(token.toLowerCase()));
  if(matches.length === 0) return;

  // if single match, insert it (preserve preceding tokens)
  if(matches.length === 1) {
    parts.push(matches[0]);
    inputEl.value = parts.join(' ') + (inputEl.value.endsWith(' ') ? ' ' : ' ');
    return;
  }

  // if multiple matches, find common prefix
  let prefix = matches[0];
  for(let i=1;i<matches.length;i++){
    let j=0; while(j<prefix.length && j<matches[i].length && prefix[j].toLowerCase()===matches[i][j].toLowerCase()) j++;
    prefix = prefix.slice(0,j);
  }
  if(prefix.length > token.length) {
    parts.push(prefix);
    inputEl.value = parts.join(' ');
  } else {
    // show options in output
    appendAutocompleteList(matches);
  }
}

function appendAutocompleteList(items) {
  const outElems = document.querySelectorAll('#tout');
  if(!outElems || outElems.length===0) return;
  const out = outElems[outElems.length-1];
  let txt = '';
  for(const it of items) txt += it + '\t';
  txt += '\n';
  out.innerHTML += txt;
  out.scrollTop = out.scrollHeight;
}

/* ---------- main exec - full Linux-like commands ---------- */
function exec(cmdLine, out, ctx = {}) {
  const append = ctx.append || ((t)=>{ out.innerHTML += t; out.scrollTop = out.scrollHeight; });
  const setCwd = ctx.setCwd || (()=>{});
  let cwd = ctx.cwd || '/';
  const fs = getFS() || {};

  function normalizePath(path) {
    if(!path) return null;
    // absolute
    if(path === '/') return '/';
    if(path.startsWith('/')) {
      const parts = path.split('/').filter(Boolean);
      const stack = [];
      for(const p of parts) {
        if(p === '.') continue;
        if(p === '..') stack.pop();
        else stack.push(p);
      }
      return '/' + stack.join('/');
    }
    // relative
    const baseParts = (cwd === '/' ? [] : cwd.split('/').filter(Boolean));
    const parts = path.split('/').filter(Boolean);
    const stack = baseParts.slice();
    for(const p of parts) {
      if(p === '.') continue;
      if(p === '..') stack.pop();
      else stack.push(p);
    }
    return '/' + stack.join('/');
  }

  function resolveToExisting(input) {
    if(!input) return null;
    // if input absolute and exists
    if(input.startsWith('/')) {
      const cand = input;
      if(fs[cand]) return cand;
    }
    // try normalized
    const norm = normalizePath(input);
    if(norm && fs[norm]) return norm;
    // try root based
    const rootCand = '/' + input;
    if(fs[rootCand]) return rootCand;
    // try basename match
    const basename = input.split('/').pop();
    for(const key in fs) {
      if(key.split('/').pop() === basename) return key;
    }
    return null;
  }

  function getEntry(pathKey) {
    if(!pathKey) return null;
    const raw = fs[pathKey];
    if(raw == null) return null;
    if(typeof raw === 'object') {
      if(raw.type) return raw;
      if(raw.children) return { type:'dir', children: raw.children };
      if(raw.data || raw.mime) return { type:'file', data: raw.data, mime: raw.mime };
    }
    if(typeof raw === 'string') {
      return { type:'file', data: raw };
    }
    return null;
  }

  function writeFS(path, entry) {
    fs[path] = entry;
    const parent = path.split('/').slice(0,-1).join('/') || '/';
    if(!fs[parent]) fs[parent] = { type:'dir', children: [] };
    if(!fs[parent].children) fs[parent].children = [];
    const name = path.split('/').pop();
    if(!fs[parent].children.includes(name)) fs[parent].children.push(name);
    setFS(fs);
  }

  function removeFS(path) {
    delete fs[path];
    const parent = path.split('/').slice(0,-1).join('/') || '/';
    if(fs[parent] && Array.isArray(fs[parent].children)) {
      fs[parent].children = fs[parent].children.filter(n => n !== path.split('/').pop());
    }
    setFS(fs);
  }

  // parse
  const parts = cmdLine.match(/(?:[^\s"]+|"[^"]*")+/g) || [];
  const args = parts.map(s=> s.replace(/^"(.*)"$/,'$1'));
  const cmd = (args[0] || '').toLowerCase();
  if(!cmd) return;

  // HELP text
  if(cmd === 'help') {
    append(
`Commands (examples):
  ls [dir]                  - list files
  cd <dir>                  - change directory
  pwd                       - show current dir
  cat <file>                - display file contents
  img <image>               - open image viewer
  open <file>               - open file in appropriate app
  touch <file>              - create empty file
  write <file> <text>       - write text to file
  rm <file|dir>             - delete file or empty directory
  mkdir <dir>               - create directory
  rmdir <dir>               - remove empty directory
  cp <src> <dest>          - copy file/dir (shallow)
  mv <src> <dest>          - move/rename
  rename <old> <new>       - alias to mv
  find <term>               - search filenames globally
  file <path>               - show type (dir/file/mime)
  du [path]                 - rough size of path
  size <file>               - file size in bytes
  stats                     - global filesystem stats
  export                    - download JSON backup
  echo <text>               - print text
  clear                     - clear terminal
  date | time               - current time/date

Examples:
  ls /Pictures
  cd Documents
  cat notes.txt
  img photo.png
  write notes.txt "hello world"
  mkdir /tmp/newdir
  cp /a/file.png /b/file.png
`);
    return;
  }

  // pwd
  if(cmd === 'pwd') { append(cwd + '\n'); return; }

  // cd
  if(cmd === 'cd') {
    const target = args[1] || '/';
    const norm = normalizePath(target);
    const resolved = resolveToExisting(norm) || resolveToExisting(target) || norm;
    const ent = getEntry(resolved);
    if(ent && ent.type === 'dir') {
      cwd = resolved;
      setCwd(cwd);
      append('cwd: ' + cwd + '\n');
    } else {
      append('Directory not found: ' + target + '\n');
    }
    return;
  }

  // ls
  if(cmd === 'ls') {
    const target = args[1] ? (normalizePath(args[1])) : cwd;
    const resolved = resolveToExisting(target) || target;
    const ent = getEntry(resolved);
    if(!ent || ent.type !== 'dir') { append('Not a directory: ' + (args[1]||cwd) + '\n'); return; }
    const list = ent.children || [];
    if(list.length === 0) { append('(empty)\n'); return; }
    for(const name of list) {
      const full = (resolved === '/' ? '/' + name : resolved + '/' + name);
      const e = getEntry(full);
      append((e && e.type === 'dir' ? 'd ' : '- ') + name + (e && e.type === 'file' && e.mime ? ' ‚Ä¢ ' + e.mime : '') + '\n');
    }
    return;
  }

  // cat
  if(cmd === 'cat') {
    const fileArg = args.slice(1).join(' ');
    if(!fileArg) { append('Usage: cat <file>\nExample: cat notes.txt\n'); return; }
    const resolved = resolveToExisting(fileArg);
    if(!resolved) { append('No such file: ' + fileArg + '\n'); return; }
    const ent = getEntry(resolved);
    if(!ent || ent.type !== 'file') { append('Not a file: ' + resolved + '\n'); return; }
    if(ent.data && typeof ent.data === 'string' && ent.data.startsWith('data:')) {
      // attempt decode
      try {
        const comma = ent.data.indexOf(',');
        const b64 = ent.data.slice(comma+1);
        const dec = atob(b64);
        append(dec + '\n');
      } catch(e) {
        append('[binary/blob] ' + resolved + '\n');
      }
    } else {
      append(String(ent.data || '') + '\n');
    }
    return;
  }

  // img
  if(cmd === 'img') {
    const f = args[1];
    if(!f) { append('Usage: img <file>\nExample: img photo.png\n'); return; }
    const resolved = resolveToExisting(f);
    if(!resolved) { append('Image not found: ' + f + '\n'); return; }
    const ent = getEntry(resolved);
    if(ent && ent.data && typeof ent.data === 'string' && ent.data.startsWith('data:image/')) {
      try { openImageViewer(resolved); append('Opened image ' + resolved + '\n'); } catch(e){ append('Opened (viewer missing) ' + resolved + '\n'); }
    } else append('Not an image: ' + resolved + '\n');
    return;
  }

  // open
  if(cmd === 'open') {
    const f = args[1];
    if(!f) { append('Usage: open <file>\nExample: open notes.txt\n'); return; }
    const resolved = resolveToExisting(f);
    if(!resolved) { append('No such file: ' + f + '\n'); return; }
    const ent = getEntry(resolved);
    if(ent && ent.type === 'file') {
      if(ent.data && typeof ent.data === 'string' && ent.data.startsWith('data:image/')) { try{ openImageViewer(resolved); }catch(e){} append('Opened ' + resolved + '\n'); }
      else if(ent.mime && ent.mime.startsWith('audio/')) { try{ openMusicPlayer(resolved); }catch(e){} append('Opened audio ' + resolved + '\n'); }
      else if(ent.mime && ent.mime.startsWith('video/')) { try{ openVideoPlayer(resolved); }catch(e){} append('Opened video ' + resolved + '\n'); }
      else { try{ openEditor(resolved, resolved.split('/').slice(0,-1).join('/')||'/'); }catch(e){} append('Opened editor ' + resolved + '\n'); }
    } else append('Cannot open: ' + f + '\n');
    return;
  }

  // touch
  if(cmd === 'touch') {
    const f = args[1];
    if(!f) { append('Usage: touch <file>\nExample: touch newfile.txt\n'); return; }
    const path = normalizePath(f);
    if(fs[path]) { append('Already exists: ' + path + '\n'); return; }
    writeFS(path, { type:'file', data: '' });
    append('Created file: ' + path + '\n');
    return;
  }

  // write
  if(cmd === 'write') {
    const f = args[1];
    if(!f) { append('Usage: write <file> <text>\nExample: write notes.txt "hello world"\n'); return; }
    const text = args.slice(2).join(' ');
    const path = normalizePath(f);
    writeFS(path, { type:'file', data: text });
    append('Wrote ' + (String(text).length) + ' bytes to ' + path + '\n');
    return;
  }

  // rm
  if(cmd === 'rm') {
    const target = args[1];
    if(!target) { append('Usage: rm <file|dir>\nExample: rm /tmp/file.txt\n'); return; }
    const resolved = resolveToExisting(target);
    if(!resolved) { append('No such file/folder: ' + target + '\n'); return; }
    const ent = getEntry(resolved);
    if(ent && ent.type === 'dir') {
      if(ent.children && ent.children.length>0) { append('Directory not empty: ' + resolved + '\n'); return; }
      removeFS(resolved);
      append('Removed directory: ' + resolved + '\n');
    } else {
      removeFS(resolved);
      append('Removed file: ' + resolved + '\n');
    }
    return;
  }

  // mkdir
  if(cmd === 'mkdir') {
    const dir = args[1];
    if(!dir) { append('Usage: mkdir <dir>\n'); return; }
    const path = normalizePath(dir);
    if(fs[path]) { append('Already exists: ' + path + '\n'); return; }
    fs[path] = { type:'dir', children: [] };
    const parent = path.split('/').slice(0,-1).join('/') || '/';
    if(!fs[parent]) fs[parent] = { type:'dir', children: [] };
    if(!fs[parent].children) fs[parent].children = [];
    fs[parent].children.push(path.split('/').pop());
    setFS(fs);
    append('Created directory: ' + path + '\n');
    return;
  }

  // rmdir
  if(cmd === 'rmdir') {
    const dir = args[1];
    if(!dir) { append('Usage: rmdir <dir>\n'); return; }
    const resolved = resolveToExisting(dir);
    if(!resolved) { append('No such directory: ' + dir + '\n'); return; }
    const ent = getEntry(resolved);
    if(!ent || ent.type !== 'dir') { append('Not a directory: ' + resolved + '\n'); return; }
    if(ent.children && ent.children.length>0) { append('Directory not empty: ' + resolved + '\n'); return; }
    removeFS(resolved);
    append('Removed directory: ' + resolved + '\n');
    return;
  }

  // cp (copy) shallow
  if(cmd === 'cp' || cmd === 'copy') {
    const src = args[1], dest = args[2];
    if(!src || !dest) { append('Usage: cp <src> <dest>\nExample: cp /a/file.png /b/file.png\n'); return; }
    const srcResolved = resolveToExisting(src);
    if(!srcResolved) { append('Source not found: ' + src + '\n'); return; }
    const destPath = normalizePath(dest);
    // clone shallow
    fs[destPath] = JSON.parse(JSON.stringify(fs[srcResolved]));
    const parent = destPath.split('/').slice(0,-1).join('/') || '/';
    if(!fs[parent]) fs[parent] = { type:'dir', children: [] };
    if(!fs[parent].children) fs[parent].children = [];
    if(!fs[parent].children.includes(destPath.split('/').pop())) fs[parent].children.push(destPath.split('/').pop());
    setFS(fs);
    append('Copied ' + srcResolved + ' to ' + destPath + '\n');
    return;
  }

  // mv (move) and rename alias
  if(cmd === 'mv' || cmd === 'rename') {
    const src = args[1], dest = args[2];
    if(!src || !dest) { append('Usage: mv <src> <dest>\nExample: mv old.txt new.txt\n'); return; }
    const srcResolved = resolveToExisting(src);
    if(!srcResolved) { append('Source not found: ' + src + '\n'); return; }
    const destPath = normalizePath(dest);
    fs[destPath] = fs[srcResolved];
    delete fs[srcResolved];
    // update parents
    const oldParent = srcResolved.split('/').slice(0,-1).join('/') || '/';
    if(fs[oldParent] && fs[oldParent].children) fs[oldParent].children = fs[oldParent].children.filter(n => n !== srcResolved.split('/').pop());
    const newParent = destPath.split('/').slice(0,-1).join('/') || '/';
    if(!fs[newParent]) fs[newParent] = { type:'dir', children: [] };
    if(!fs[newParent].children.includes(destPath.split('/').pop())) fs[newParent].children.push(destPath.split('/').pop());
    setFS(fs);
    append('Moved ' + srcResolved + ' to ' + destPath + '\n');
    return;
  }

  // find (global)
  if(cmd === 'find') {
    const term = args.slice(1).join(' ');
    if(!term) { append('Usage: find <term>\nExample: find png\n'); return; }
    const results = [];
    for(const key in fs) {
      if(key.split('/').pop().toLowerCase().includes(term.toLowerCase())) results.push(key);
    }
    append((results.length ? results.join('\n') : 'No matches') + '\n');
    return;
  }

  // file
  if(cmd === 'file') {
    const path = args[1] || cwd;
    const resolved = resolveToExisting(path) || normalizePath(path);
    const ent = getEntry(resolved);
    if(!ent) { append('Not found: ' + path + '\n'); return; }
    append((ent.type === 'dir' ? 'directory' : (ent.mime || 'file')) + '\n');
    return;
  }

  // du (rough size)
  if(cmd === 'du') {
    const path = args[1] ? normalizePath(args[1]) : cwd;
    let total = 0;
    function walk(p) {
      const e = fs[p];
      if(!e) return;
      if(typeof e === 'string') total += e.length;
      else if(e.data && typeof e.data === 'string') total += e.data.length;
      if(e.children) for(const ch of e.children) walk(p === '/' ? '/' + ch : p + '/' + ch);
    }
    walk(path);
    append('Size (bytes): ' + total + '\n');
    return;
  }

  // size
  if(cmd === 'size') {
    const f = args[1];
    if(!f) { append('Usage: size <file>\n'); return; }
    const resolved = resolveToExisting(f);
    if(!resolved) { append('No such file\n'); return; }
    const ent = getEntry(resolved);
    if(!ent || ent.type !== 'file') { append('Not a file\n'); return; }
    let len = 0;
    if(ent.data && typeof ent.data === 'string') len = ent.data.length;
    append('Size: ' + len + ' bytes\n');
    return;
  }

  // stats
  if(cmd === 'stats') {
    const keys = Object.keys(fs);
    let totalSize = 0;
    for(const k of keys) {
      const e = fs[k];
      if(typeof e === 'string') totalSize += e.length;
      else if(e && e.data && typeof e.data === 'string') totalSize += e.data.length;
    }
    append(`Entries: ${keys.length}, Total bytes: ${totalSize}\n`);
    return;
  }

  // export
  if(cmd === 'export') {
    const data = "data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(fs));
    const a = document.createElement('a');
    a.href = data;
    a.download = 'webos_backup.json';
    a.click();
    append('Exported filesystem to webos_backup.json\n');
    return;
  }

  // echo
  if(cmd === 'echo') {
    append(args.slice(1).join(' ') + '\n');
    return;
  }

  // clear
  if(cmd === 'clear') {
    out.innerHTML = '';
    return;
  }

  // date/time
  if(cmd === 'date' || cmd === 'time') {
    append(new Date().toString() + '\n');
    return;
  }

  // default: unknown
  append('Unknown command: ' + cmd + '\n');
}



// Calculator
function openCalc(){
  const win=makeWin('Calculator',280,340,`<div style="display:flex;flex-direction:column;height:100%"><input class="input" id="cDisp" style="font-size:20px;text-align:right;margin-bottom:8px" readonly><div id="cBtns" style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;flex:1"></div></div>`);
  const disp=win.querySelector('#cDisp'),btns=win.querySelector('#cBtns');
  let val='';
  ['C','¬±','%','√∑','7','8','9','√ó','4','5','6','-','1','2','3','+','0','.','‚å´','='].forEach(k=>{
    const b=document.createElement('button');
    b.className='btn';b.textContent=k;
    b.style.cssText='font-size:16px;padding:10px;background:'+([ '√∑','√ó','-','+','='].includes(k)?'#f97316':'rgba(255,255,255,0.1)');
    b.onclick=()=>{
      if(k==='C'){val='';disp.value=''}
      else if(k==='‚å´'){val=val.slice(0,-1);disp.value=val}
      else if(k==='¬±'){val=val[0]==='-'?val.slice(1):'-'+val;disp.value=val}
      else if(k==='='){try{disp.value=Function('return '+val.replace(/√ó/g,'*').replace(/√∑/g,'/'))();}catch{disp.value='Error';}}
      else{val+=k;disp.value=val}
    };
    btns.appendChild(b);
  });
}

// Browser
function openBrowser(){
  const win=makeWin('Browser',760,520,`<div style="display:flex;flex-direction:column;height:100%"><div style="display:flex;gap:6px;margin-bottom:8px;align-items:center"><button class="btn" id="backBtn" style="background:rgba(255,255,255,0.1);padding:6px 10px">‚Üê</button><button class="btn" id="fwdBtn" style="background:rgba(255,255,255,0.1);padding:6px 10px">‚Üí</button><button class="btn" id="refreshBtn" style="background:rgba(255,255,255,0.1);padding:6px 10px">‚ü≥</button><input class="input" id="browserUrl" value="https://google.com" style="flex:1" placeholder="Enter URL"><button class="btn" id="goBtn">Go</button></div><div style="display:flex;gap:6px;margin-bottom:6px;flex-wrap:wrap"><button class="btn quickLink" data-url="https://google.com" style="background:rgba(255,255,255,0.05);font-size:10px">Google</button><button class="btn quickLink" data-url="https://youtube.com" style="background:rgba(255,255,255,0.05);font-size:10px">YouTube</button><button class="btn quickLink" data-url="https://github.com" style="background:rgba(255,255,255,0.05);font-size:10px">GitHub</button><button class="btn quickLink" data-url="https://wikipedia.org" style="background:rgba(255,255,255,0.05);font-size:10px">Wikipedia</button><label style="display:flex;align-items:center;gap:4px;font-size:11px;color:var(--muted);margin-left:auto"><input type="checkbox" id="useProxy" checked>Use Proxy</label></div><iframe id="browserFrame" style="flex:1;width:100%;border:none;background:#fff;border-radius:6px"></iframe><div class="small" style="margin-top:6px;color:var(--muted);text-align:center">üöÄ Proxy enabled by default - loads any website!</div></div>`);
  const urlInput=win.querySelector('#browserUrl');
  const iframe=win.querySelector('#browserFrame');
  const goBtn=win.querySelector('#goBtn');
  const backBtn=win.querySelector('#backBtn');
  const fwdBtn=win.querySelector('#fwdBtn');
  const refreshBtn=win.querySelector('#refreshBtn');
  const useProxy=win.querySelector('#useProxy');
  
  const loadUrl=()=>{
    let url=urlInput.value.trim();
    if(!url)return;
    if(!url.startsWith('http://')&&!url.startsWith('https://')){url='https://'+url;}
    if(useProxy.checked){iframe.src='https://webos-proxy-1.onrender.com/proxy?url=' + encodeURIComponent(url);}else{iframe.src=url;}
    urlInput.value=url;
  };
  
  goBtn.onclick=loadUrl;
  urlInput.onkeydown=e=>{if(e.key==='Enter')loadUrl()};
  backBtn.onclick=()=>{try{iframe.contentWindow.history.back()}catch(e){}};
  fwdBtn.onclick=()=>{try{iframe.contentWindow.history.forward()}catch(e){}};
  refreshBtn.onclick=()=>{try{iframe.contentWindow.location.reload()}catch(e){}};
  
  win.querySelectorAll('.quickLink').forEach(btn=>{btn.onclick=()=>{urlInput.value=btn.dataset.url;loadUrl();}});
  loadUrl();
}

// ---------------- Storage Management Functions ----------------
function getStorageInfo() {
  try {
    // Calculate total storage used by filesystem
    const fs = getFS();
    let totalSize = 0;
    let fileCount = 0;
    
    for(const path in fs) {
      const entry = fs[path];
      if(entry && entry.type === 'file' && entry.data) {
        totalSize += entry.data.length;
        fileCount++;
      }
    }
    
    // Convert to MB (rough estimate)
    const usedMB = Math.round((totalSize / (1024 * 1024)) * 100) / 100;
    const maxMB = 5; // 5MB limit for demo purposes
    const percent = Math.min(100, Math.round((usedMB / maxMB) * 100));
    
    let status = 'Good';
    if(percent > 90) status = 'Critical';
    else if(percent > 70) status = 'Warning';
    
    return {
      used: usedMB,
      max: maxMB,
      percent: percent,
      files: fileCount,
      status: status
    };
  } catch(e) {
    return {
      used: 0,
      max: 5,
      percent: 0,
      files: 0,
      status: 'Good'
    };
  }
}

function cleanupStorage() {
  const fs = getFS();
  let cleanedCount = 0;
  
  // Simple cleanup: remove files that are too large or empty
  for(const path in fs) {
    const entry = fs[path];
    if(entry && entry.type === 'file') {
      // Remove empty files or very large files (>1MB)
      if(!entry.data || entry.data.length === 0 || entry.data.length > 1024 * 1024) {
        // Also remove from parent directory
        const fileName = path.split('/').pop();
        const parentPath = path.split('/').slice(0, -1).join('/') || '/';
        
        if(fs[parentPath] && Array.isArray(fs[parentPath].children)) {
          const idx = fs[parentPath].children.indexOf(fileName);
          if(idx >= 0) fs[parentPath].children.splice(idx, 1);
        }
        
        delete fs[path];
        cleanedCount++;
      }
    }
  }
  
  setFS(fs);
  
  if(cleanedCount > 0) {
    showNotification('Cleanup Complete', `Removed ${cleanedCount} files`, 'success', 3000);
  } else {
    showNotification('Cleanup', 'No files needed cleanup', 'info', 3000);
  }
}

function deleteLargeFiles() {
  const fs = getFS();
  let deletedCount = 0;
  
  for(const path in fs) {
    const entry = fs[path];
    if(entry && entry.type === 'file' && entry.data && entry.data.length > 500 * 1024) { // 500KB threshold
      const fileName = path.split('/').pop();
      const parentPath = path.split('/').slice(0, -1).join('/') || '/';
      
      if(fs[parentPath] && Array.isArray(fs[parentPath].children)) {
        const idx = fs[parentPath].children.indexOf(fileName);
        if(idx >= 0) fs[parentPath].children.splice(idx, 1);
      }
      
      delete fs[path];
      deletedCount++;
    }
  }
  
  setFS(fs);
  
  if(deletedCount > 0) {
    showNotification('Large Files Removed', `Deleted ${deletedCount} large files`, 'warning', 3000);
  } else {
    showNotification('No Large Files', 'No files over 500KB found', 'info', 3000);
  }
}

// Settings
function openSettings() {
  const win = makeWin('Settings', 520, 560, `
    <div style="display:flex;height:100%">
      
      <div style="width:150px;background:rgba(255,255,255,0.03);padding:10px;display:flex;flex-direction:column;gap:6px;">
        <div class="setBtn active" data-page="system">System</div>
        <div class="setBtn" data-page="display">Display</div>
        <div class="setBtn" data-page="sound">Sound</div>
        <div class="setBtn" data-page="notify">Notifications</div>
        <div class="setBtn" data-page="wallpaper">Wallpaper</div>
      </div>

      <div style="flex:1;padding:12px;overflow:auto">

        <div class="page page-system">
          <div class="card">
            <b>Storage</b><br><br>
            <div id="sysStorageBar" style="height:10px;border-radius:6px;background:#1e293b;overflow:hidden;">
              <div id="sysStorageFill" style="height:100%;width:0%;background:#3b82f6"></div>
            </div>
            <div style="font-size:12px;margin-top:6px" id="sysStorageText"></div>
            <button id="sysCleanup" class="btn" style="margin-top:10px;background:#f59e0b;">Clean Up</button>
          </div>

          <div class="card">
            <b>Reset Filesystem</b><br><br>
            <button id="sysReset" class="btn" style="background:#ef4444;">Reset</button>
          </div>
        </div>

        <div class="page page-display" style="display:none">
          <div class="card">
            <b>Brightness</b><br><br>
            <input id="dispBright" type="range" min="50" max="150" value="100" style="width:100%">
          </div>

          <div class="card">
            <b>UI Scaling</b><br><br>
            <input id="dispScale" type="range" min="80" max="120" value="100" style="width:100%">
          </div>
        </div>

        <div class="page page-sound" style="display:none">
          <div class="card">
            <b>Master Volume</b><br><br>
            <input id="sndVol" type="range" min="0" max="100" value="80" style="width:100%">
          </div>

          <div class="card">
            <b>System Sounds</b><br><br>
            <label style="font-size:13px;display:flex;align-items:center;gap:6px;">
              <input id="sndClicks" type="checkbox" checked> Click Sounds
            </label>
            <label style="font-size:13px;display:flex;align-items:center;gap:6px;margin-top:6px;">
              <input id="sndNotif" type="checkbox" checked> Notification Sounds
            </label>
          </div>
        </div>

        <div class="page page-notify" style="display:none">
          <div class="card">
            <b>Notification Style</b><br><br>
            <select id="notType" class="input">
              <option value="modern">Modern</option>
              <option value="compact">Compact</option>
              <option value="silent">Silent</option>
            </select>
          </div>

          <div class="card">
            <b>Preview</b><br><br>
            <button id="notTest" class="btn">Test Notification</button>
          </div>
        </div>

        <div class="page page-wallpaper" style="display:none">
          <div class="card">
            <b>Wallpapers</b>
            <div class="wall-grid" id="wallGrid">
  <div class="wallBox" data-id="wall1" style="background:#3B82F6"></div>
  <div class="wallBox" data-id="wall2" style="background:#6D28D9"></div>
  <div class="wallBox" data-id="wall3" style="background:#DC2626"></div>
  <div class="wallBox" data-id="wall4" style="background:#059669"></div>
  <div class="wallBox" data-id="wall5" style="background:#F97316"></div>
  <div class="wallBox" data-id="wall6" style="background:#EC4899"></div>
  <div class="wallBox" data-id="wall7" style="background:#06B6D4"></div>
  <div class="wallBox" data-id="wall8" style="background:#FACC15"></div>
  <div class="wallBox" data-id="wall9" style="background:#334155"></div>
</div>

          </div>

          <div class="card">
            <b>Custom Wallpaper</b><br><br>
            <input type="file" id="wallUpload" accept="image/*" style="display:none">
            <button class="btn" id="wallCustomBtn">Upload</button>
          </div>
        </div>

      </div>
    </div>
  `);
  function applyWall() {
  const desk = document.getElementById("wallpaper");
  let chosen = localStorage.getItem("wallpaper") || "wall1";

  if (chosen === "custom") {
    const img = localStorage.getItem("wall_custom");
    if (img) {
      desk.style.background = `url(${img}) center/cover`;
      return;
    }
    chosen = "wall1";
  }

  const color = wallpaperList[chosen] || "#3B82F6";
  desk.style.background = color;
}


  const pages = win.querySelectorAll('.setBtn');
  pages.forEach(b=>{
    b.onclick=()=>{
      pages.forEach(x=>x.classList.remove('active'));
      b.classList.add('active');
      win.querySelectorAll('.page').forEach(p=>p.style.display='none');
      win.querySelector('.page-'+b.dataset.page).style.display='block';
    };
  });

  const info = getStorageInfo();
  win.querySelector('#sysStorageFill').style.width = info.percent + '%';
  win.querySelector('#sysStorageText').textContent = info.used + 'MB / ' + info.max + 'MB';

  win.querySelector('#sysCleanup').onclick = () => {
    cleanupStorage();
    const i = getStorageInfo();
    win.querySelector('#sysStorageFill').style.width = i.percent + '%';
    win.querySelector('#sysStorageText').textContent = i.used + 'MB / ' + i.max + 'MB';
  };

  win.querySelector('#sysReset').onclick = () => {
    if(confirm('Reset all files?')) resetFilesystem();
  };

  win.querySelector('#dispBright').oninput = e => {
    document.body.style.filter = `brightness(${e.target.value}%)`;
  };

  win.querySelector('#dispScale').oninput = e => {
    document.documentElement.style.transform = `scale(${e.target.value/100})`;
    document.documentElement.style.transformOrigin = 'top left';
  };

  win.querySelector('#sndVol').oninput = e => {
    localStorage.setItem('sound_vol', e.target.value);
  };

  win.querySelector('#sndClicks').onchange = e => {
    localStorage.setItem('sound_clicks', e.target.checked ? 1 : 0);
  };

  win.querySelector('#sndNotif').onchange = e => {
    localStorage.setItem('sound_notif', e.target.checked ? 1 : 0);
  };

  win.querySelector('#notType').onchange = e => {
    localStorage.setItem('notif_style', e.target.value);
  };

  win.querySelector('#notTest').onclick = () => {
    showNotification('Test', 'This is a preview', 'info', 2000);
  };

  win.querySelector('#wallCustomBtn').onclick = () => {
    win.querySelector('#wallUpload').click();
  };

  win.querySelector('#wallUpload').onchange = e => {
    const f = e.target.files[0];
    if(!f) return;
    const r = new FileReader();
    r.onload = ev => {
      localStorage.setItem('wall_custom', ev.target.result);
      localStorage.setItem('wallpaper', 'custom');
      applyWall();
    };
    r.readAsDataURL(f);
  };

  win.querySelectorAll('.wallBox').forEach(box=>{
    box.onclick=()=>{
      localStorage.setItem('wallpaper', box.dataset.id);
      applyWall();
    };
  });
}



function openAbout(){
  makeWin('About',210,145,`<div style="text-align:center"><h3 style="margin:0 0 8px">WebOS</h3><p class="small">A browser-based OS simulation</p><p class="small">made by Ilyes</p></div>`);
}

// Paint (FIXED: Now draws where cursor actually is)
// Paint - MEGA ENHANCED with 15+ tools and shapes
function openPaint(){
  const win=makeWin('Paint Pro',900,650,`
    <div style="display:flex;flex-direction:column;height:100%;gap:8px">
      <!-- Top Toolbar -->
      <div style="display:flex;gap:8px;flex-wrap:wrap;padding:8px;background:rgba(255,255,255,0.05);border-radius:8px;align-items:center">
        <input type="color" id="pColor" value="#3b82f6" style="width:40px;height:40px;border:none;cursor:pointer;border-radius:6px">
        <input type="color" id="pColor2" value="#ffffff" title="Secondary Color" style="width:40px;height:40px;border:none;cursor:pointer;border-radius:6px">
        <div style="display:flex;flex-direction:column;gap:2px">
          <input type="range" id="pSize" min="1" max="50" value="6" style="width:100px">
          <span id="pSizeL" class="small" style="text-align:center">6px</span>
        </div>
        <button class="btn" id="pUndo" title="Undo">‚Ü∂</button>
        <button class="btn" id="pRedo" title="Redo">‚Ü∑</button>
        <button class="btn" id="pClear" title="Clear Canvas">üóëÔ∏è</button>
        <button class="btn" id="pSave" style="background:#10b981">üíæ Save</button>
      </div>
      
      <!-- Tools Panel & Canvas -->
      <div style="display:flex;gap:8px;flex:1;overflow:hidden">
        <!-- Left Toolbar -->
        <div style="width:70px;display:flex;flex-direction:column;gap:4px;overflow-y:auto;padding:4px;background:rgba(255,255,255,0.03);border-radius:8px">
          <button class="tool-btn" data-tool="brush" title="Brush">üñåÔ∏è</button>
          <button class="tool-btn" data-tool="pencil" title="Pencil">‚úèÔ∏è</button>
          <button class="tool-btn" data-tool="eraser" title="Eraser">üßΩ</button>
          <button class="tool-btn" data-tool="fill" title="Fill Bucket">ü™£</button>
          <button class="tool-btn" data-tool="eyedropper" title="Eyedropper">üíß</button>
          <button class="tool-btn" data-tool="spray" title="Spray Paint">üé®</button>
          <button class="tool-btn" data-tool="line" title="Line">üìè</button>
          <button class="tool-btn" data-tool="rectangle" title="Rectangle">‚ñ≠</button>
          <button class="tool-btn" data-tool="circle" title="Circle">‚≠ï</button>
          <button class="tool-btn" data-tool="triangle" title="Triangle">‚ñ≤</button>
          <button class="tool-btn" data-tool="star" title="Star">‚≠ê</button>
          <button class="tool-btn" data-tool="heart" title="Heart">‚ù§Ô∏è</button>
          <button class="tool-btn" data-tool="arrow" title="Arrow">‚û°Ô∏è</button>
          <button class="tool-btn" data-tool="polygon" title="Polygon">‚¨°</button>
          <button class="tool-btn" data-tool="text" title="Text">üìù</button>
          <button class="tool-btn" data-tool="gradient" title="Gradient">üåà</button>
          <button class="tool-btn" data-tool="blur" title="Blur">üí´</button>
        </div>
        
        <!-- Canvas -->
        <canvas id="pCanvas" style="flex:1;background:#fff;border-radius:8px;cursor:crosshair;box-shadow:0 4px 12px rgba(0,0,0,0.2)"></canvas>
      </div>
    </div>
  `);
  
  const canvas=win.querySelector('#pCanvas'),ctx=canvas.getContext('2d');
  let painting=false,tool='brush',color='#3b82f6',color2='#ffffff',size=6;
  let startX=0,startY=0;
  let history=[],historyStep=-1;
  let textInput=null;
  
  function setupCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    ctx.fillStyle='#fff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
    saveState();
  }
  
  setTimeout(setupCanvas, 50);
  new ResizeObserver(setupCanvas).observe(canvas);
  
  function saveState(){
    historyStep++;
    if(historyStep<history.length){history.length=historyStep;}
    history.push(canvas.toDataURL());
    if(history.length>50)history.shift();
  }
  
  function restoreState(step){
    if(step<0||step>=history.length)return;
    const img=new Image();
    img.onload=()=>{ctx.clearRect(0,0,canvas.width,canvas.height);ctx.drawImage(img,0,0);};
    img.src=history[step];
  }
  
  win.querySelector('#pUndo').onclick=()=>{if(historyStep>0){historyStep--;restoreState(historyStep);}};
  win.querySelector('#pRedo').onclick=()=>{if(historyStep<history.length-1){historyStep++;restoreState(historyStep);}};
  win.querySelector('#pColor').oninput=e=>color=e.target.value;
  win.querySelector('#pColor2').oninput=e=>color2=e.target.value;
  win.querySelector('#pSize').oninput=e=>{size=e.target.value;win.querySelector('#pSizeL').textContent=size+'px'};
  win.querySelector('#pClear').onclick=()=>{if(confirm('Clear canvas?')){ctx.fillStyle='#fff';ctx.fillRect(0,0,canvas.width,canvas.height);saveState();sfx('click');}};
  
  win.querySelectorAll('.tool-btn').forEach(btn=>{
    btn.onclick=()=>{
      tool=btn.dataset.tool;
      win.querySelectorAll('.tool-btn').forEach(b=>b.style.background='');
      btn.style.background='rgba(59,130,246,0.3)';
      canvas.style.cursor=tool==='eyedropper'?'crosshair':tool==='text'?'text':'crosshair';
    };
  });
  
  win.querySelector('#pSave').onclick=()=>{
    const data = canvas.toDataURL('image/png');
    const fs=getFS();
    let i=1; let name='painting.png';
    while(fs['/Pictures/'+name]){name = 'painting-'+(i++)+'.png'}
    const path='/Pictures/'+name;
    fs[path]={type:'file',mime:'image/png',data:data};
    if(!fs['/Pictures'].children.includes(name))fs['/Pictures'].children.push(name);
    setFS(fs);
    showNotification('Saved', `${name} saved to Pictures`, 'success', 3000);
    sfx('save');
  };
  
  function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    return {x: e.clientX - rect.left, y: e.clientY - rect.top};
  }
  
  function drawLine(x1,y1,x2,y2){
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
  }
  
  function drawRectangle(x1,y1,x2,y2,fill){
    if(fill){ctx.fillRect(x1,y1,x2-x1,y2-y1);}
    else{ctx.strokeRect(x1,y1,x2-x1,y2-y1);}
  }
  
  function drawCircle(x1,y1,x2,y2,fill){
    const rx=Math.abs(x2-x1)/2,ry=Math.abs(y2-y1)/2;
    const cx=Math.min(x1,x2)+rx,cy=Math.min(y1,y2)+ry;
    ctx.beginPath();
    ctx.ellipse(cx,cy,rx,ry,0,0,Math.PI*2);
    fill?ctx.fill():ctx.stroke();
  }
  
  function drawTriangle(x1,y1,x2,y2,fill){
    const w=x2-x1,h=y2-y1;
    ctx.beginPath();
    ctx.moveTo(x1+w/2,y1);
    ctx.lineTo(x2,y2);
    ctx.lineTo(x1,y2);
    ctx.closePath();
    fill?ctx.fill():ctx.stroke();
  }
  
  function drawStar(cx,cy,r,fill){
    ctx.beginPath();
    for(let i=0;i<5;i++){
      const angle=Math.PI*2*i/5-Math.PI/2;
      const x=cx+Math.cos(angle)*r;
      const y=cy+Math.sin(angle)*r;
      if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
      const innerAngle=angle+Math.PI/5;
      ctx.lineTo(cx+Math.cos(innerAngle)*r*0.4,cy+Math.sin(innerAngle)*r*0.4);
    }
    ctx.closePath();
    fill?ctx.fill():ctx.stroke();
  }
  
  function drawHeart(cx,cy,size,fill){
    ctx.beginPath();
    ctx.moveTo(cx,cy+size/4);
    ctx.bezierCurveTo(cx,cy,cx-size/2,cy-size/2,cx-size/2,cy);
    ctx.bezierCurveTo(cx-size/2,cy+size/3,cx,cy+size/2,cx,cy+size);
    ctx.bezierCurveTo(cx,cy+size/2,cx+size/2,cy+size/3,cx+size/2,cy);
    ctx.bezierCurveTo(cx+size/2,cy-size/2,cx,cy,cx,cy+size/4);
    ctx.closePath();
    fill?ctx.fill():ctx.stroke();
  }
  
  function drawArrow(x1,y1,x2,y2){
    const angle=Math.atan2(y2-y1,x2-x1);
    const headlen=size*2;
    ctx.beginPath();
    ctx.moveTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2-headlen*Math.cos(angle-Math.PI/6),y2-headlen*Math.sin(angle-Math.PI/6));
    ctx.moveTo(x2,y2);
    ctx.lineTo(x2-headlen*Math.cos(angle+Math.PI/6),y2-headlen*Math.sin(angle+Math.PI/6));
    ctx.stroke();
  }
  
  function drawPolygon(cx,cy,r,sides,fill){
    ctx.beginPath();
    for(let i=0;i<sides;i++){
      const angle=Math.PI*2*i/sides-Math.PI/2;
      const x=cx+Math.cos(angle)*r;
      const y=cy+Math.sin(angle)*r;
      if(i===0)ctx.moveTo(x,y);else ctx.lineTo(x,y);
    }
    ctx.closePath();
    fill?ctx.fill():ctx.stroke();
  }
  
  function sprayPaint(x,y){
    const density=20;
    for(let i=0;i<density;i++){
      const offsetX=(Math.random()-0.5)*size*2;
      const offsetY=(Math.random()-0.5)*size*2;
      ctx.fillRect(x+offsetX,y+offsetY,1,1);
    }
  }
  
  function floodFill(x,y,targetColor,fillColor){
    const imageData=ctx.getImageData(0,0,canvas.width,canvas.height);
    const pixels=imageData.data;
    const stack=[{x:Math.floor(x),y:Math.floor(y)}];
    const visited=new Set();
    
    function getColorKey(px,py){return py*canvas.width+px;}
    function getPixel(px,py){const i=(py*canvas.width+px)*4;return [pixels[i],pixels[i+1],pixels[i+2],pixels[i+3]];}
    function setPixel(px,py){const i=(py*canvas.width+px)*4;pixels[i]=fillColor[0];pixels[i+1]=fillColor[1];pixels[i+2]=fillColor[2];pixels[i+3]=fillColor[3];}
    function colorsMatch(c1,c2){return c1[0]===c2[0]&&c1[1]===c2[1]&&c1[2]===c2[2]&&c1[3]===c2[3];}
    
    const target=getPixel(stack[0].x,stack[0].y);
    if(colorsMatch(target,fillColor))return;
    
    while(stack.length){
      const {x:px,y:py}=stack.pop();
      const key=getColorKey(px,py);
      if(visited.has(key))continue;
      if(px<0||px>=canvas.width||py<0||py>=canvas.height)continue;
      const current=getPixel(px,py);
      if(!colorsMatch(current,target))continue;
      visited.add(key);
      setPixel(px,py);
      stack.push({x:px+1,y:py},{x:px-1,y:py},{x:px,y:py+1},{x:px,y:py-1});
    }
    ctx.putImageData(imageData,0,0);
  }
  
  function hexToRgba(hex){
    const r=parseInt(hex.slice(1,3),16);
    const g=parseInt(hex.slice(3,5),16);
    const b=parseInt(hex.slice(5,7),16);
    return [r,g,b,255];
  }
  
  let tempCanvas=null;
  
  canvas.onmousedown=e=>{
    const pos = getMousePos(e);
    startX=pos.x;startY=pos.y;
    
    if(tool==='eyedropper'){
      const pixel=ctx.getImageData(pos.x,pos.y,1,1).data;
      const hex='#'+[pixel[0],pixel[1],pixel[2]].map(x=>x.toString(16).padStart(2,'0')).join('');
      color=hex;
      win.querySelector('#pColor').value=hex;
      return;
    }
    
    if(tool==='text'){
      if(textInput)textInput.remove();
      textInput=document.createElement('input');
      textInput.style.position='absolute';
      textInput.style.left=(e.clientX-canvas.getBoundingClientRect().left)+'px';
      textInput.style.top=(e.clientY-canvas.getBoundingClientRect().top)+'px';
      textInput.style.font=size+'px Arial';
      textInput.style.color=color;
      textInput.style.background='transparent';
      textInput.style.border='1px dashed '+color;
      textInput.placeholder='Type text...';
      canvas.parentElement.style.position='relative';
      canvas.parentElement.appendChild(textInput);
      textInput.focus();
      textInput.onblur=()=>{
        if(textInput.value){
          ctx.font=size+'px Arial';
          ctx.fillStyle=color;
          ctx.fillText(textInput.value,pos.x,pos.y);
          saveState();
        }
        textInput.remove();
        textInput=null;
      };
      return;
    }
    
    if(tool==='fill'){
      const targetColor=ctx.getImageData(pos.x,pos.y,1,1).data;
      floodFill(pos.x,pos.y,targetColor,hexToRgba(color));
      saveState();
      return;
    }
    
    painting=true;
    tempCanvas=ctx.getImageData(0,0,canvas.width,canvas.height);
    
    ctx.strokeStyle=color;
    ctx.fillStyle=color;
    ctx.lineWidth=size;
    
    if(tool==='brush'||tool==='pencil'){
      ctx.beginPath();
      ctx.moveTo(pos.x,pos.y);
    }
    if(tool==='eraser'){
      ctx.strokeStyle='#fff';
      ctx.beginPath();
      ctx.moveTo(pos.x,pos.y);
    }
  };
  
  canvas.onmousemove=e=>{
    if(!painting)return;
    const pos = getMousePos(e);
    
    if(tool==='brush'||tool==='pencil'){
      ctx.lineTo(pos.x,pos.y);
      ctx.stroke();
    }
    else if(tool==='eraser'){
      ctx.lineTo(pos.x,pos.y);
      ctx.stroke();
    }
    else if(tool==='spray'){
      sprayPaint(pos.x,pos.y);
    }
    else{
      ctx.putImageData(tempCanvas,0,0);
      ctx.strokeStyle=color;
      ctx.fillStyle=color;
      ctx.lineWidth=size;
      
      const filled=e.shiftKey;
      
      if(tool==='line')drawLine(startX,startY,pos.x,pos.y);
      else if(tool==='rectangle')drawRectangle(startX,startY,pos.x,pos.y,filled);
      else if(tool==='circle')drawCircle(startX,startY,pos.x,pos.y,filled);
      else if(tool==='triangle')drawTriangle(startX,startY,pos.x,pos.y,filled);
      else if(tool==='star'){const r=Math.hypot(pos.x-startX,pos.y-startY);drawStar(startX,startY,r,filled);}
      else if(tool==='heart'){const s=Math.hypot(pos.x-startX,pos.y-startY);drawHeart(startX,startY,s,filled);}
      else if(tool==='arrow')drawArrow(startX,startY,pos.x,pos.y);
      else if(tool==='polygon'){const r=Math.hypot(pos.x-startX,pos.y-startY);drawPolygon(startX,startY,r,6,filled);}
      else if(tool==='gradient'){
        const grd=ctx.createLinearGradient(startX,startY,pos.x,pos.y);
        grd.addColorStop(0,color);
        grd.addColorStop(1,color2);
        ctx.fillStyle=grd;
        ctx.fillRect(startX,startY,pos.x-startX,pos.y-startY);
      }
    }
  };
  
  canvas.onmouseup=canvas.onmouseleave=()=>{
    if(painting){painting=false;saveState();}
  };
  
  // Set initial tool
  win.querySelector('[data-tool="brush"]').click();
}

// Image Viewer
// Image Viewer - FIXED to show correct images
function openImageViewer(nameOrNull){
  const fs = getFS();
  
  // Get ALL image files from the filesystem
  let filenames = [];
  for(const key in fs){
    if(fs[key] && fs[key].type === 'file' && 
       fs[key].mime && fs[key].mime.startsWith('image/') &&
       fs[key].data){
      filenames.push(key);
    }
  }
  
  if(!filenames.length){
    alert('No images found in files');
    return;
  }
  
  // Find the correct starting index
  let idx = 0;
  if(nameOrNull){
    idx = filenames.indexOf(nameOrNull);
    if(idx < 0) idx = 0; // Fallback if not found
  }
  
  const currentFile = filenames[idx];
  const content = fs[currentFile]?.data || '';
  
  const win = makeWin('Image Viewer',640,520,`
    <div style="display:flex;flex-direction:column;height:100%">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
        <button class="btn" id="imgPrev">‚Üê</button>
        <button class="btn" id="imgNext">‚Üí</button>
        <button class="btn" id="imgZoom">Zoom</button>
        <button class="btn" id="imgFit">Fit</button>
        <div style="flex:1;text-align:center" id="imgName">${currentFile.split('/').pop() || 'Image'}</div>
        <button class="btn" id="imgDel" style="background:#ef4444">Delete</button>
      </div>
      <div style="flex:1;display:flex;align-items:center;justify-content:center;overflow:auto;background:rgba(0,0,0,0.1);border-radius:6px">
        <img id="imgView" src="${content}" style="max-width:100%;max-height:100%;" onerror="this.style.display='none'" />
      </div>
      <div class="small" style="text-align:center;margin-top:8px;color:var(--muted)">
        ${idx + 1} of ${filenames.length} images
      </div>
    </div>
  `);
  
  const img = win.querySelector('#imgView');
  const nameEl = win.querySelector('#imgName');
  let zoomed = false;
  let currentIndex = idx;
  let imageList = filenames;
  
  function updateImage(){
    const file = imageList[currentIndex];
    const imgData = fs[file]?.data;
    
    if(imgData){
      img.src = imgData;
      img.style.display = 'block';
      nameEl.textContent = file.split('/').pop();
      
      // Update counter
      win.querySelector('.small:last-child').textContent = 
        `${currentIndex + 1} of ${imageList.length} images`;
    } else {
      img.style.display = 'none';
      nameEl.textContent = 'Image not found';
    }
    
    // Reset zoom when changing images
    if(zoomed){
      img.style.maxWidth = 'none';
      img.style.maxHeight = 'none';
      img.style.width = 'auto';
      img.style.height = 'auto';
    } else {
      img.style.maxWidth = '100%';
      img.style.maxHeight = '100%';
    }
  }
  
  win.querySelector('#imgPrev').onclick = () => {
    currentIndex = (currentIndex - 1 + imageList.length) % imageList.length;
    updateImage();
  };
  
  win.querySelector('#imgNext').onclick = () => {
    currentIndex = (currentIndex + 1) % imageList.length;
    updateImage();
  };
  
  win.querySelector('#imgZoom').onclick = () => {
    zoomed = !zoomed;
    if(zoomed){
      img.style.maxWidth = 'none';
      img.style.maxHeight = 'none';
      img.style.width = 'auto';
      img.style.height = 'auto';
    } else {
      img.style.maxWidth = '100%';
      img.style.maxHeight = '100%';
    }
  };
  
  win.querySelector('#imgFit').onclick = () => {
    img.style.maxWidth = '100%';
    img.style.maxHeight = '100%';
    zoomed = false;
  };
  
  win.querySelector('#imgDel').onclick = () => {
    const currentFile = imageList[currentIndex];
    if(!confirm('Delete '+ currentFile.split('/').pop() +'?')) return;
    
    const fs = getFS();
    delete fs[currentFile];
    
    // Remove from parent folder children
    const fileName = currentFile.split('/').pop();
    const parentPath = currentFile.split('/').slice(0,-1).join('/') || "/";
    if(fs[parentPath] && Array.isArray(fs[parentPath].children)){
      const idx = fs[parentPath].children.indexOf(fileName);
      if(idx >= 0) fs[parentPath].children.splice(idx,1);
    }
    
    setFS(fs);
    sfx('close');
    
    // Refresh image list and close or show next image
    const newFs = getFS();
    const newImageList = [];
    for(const key in newFs){
      if(newFs[key] && newFs[key].type === 'file' && 
         newFs[key].mime && newFs[key].mime.startsWith('image/') &&
         newFs[key].data){
        newImageList.push(key);
      }
    }
    
    if(newImageList.length === 0){
      ctrl('close',win);
      showNotification('Image Deleted', 'No images remaining', 'info', 3000);
    } else {
      imageList = newImageList;
      currentIndex = Math.min(currentIndex, imageList.length - 1);
      updateImage();
      showNotification('Image Deleted', 'Image removed successfully', 'warning', 3000);
    }
  };
  
  // Keyboard navigation
  win.onkeydown = (e) => {
    if(e.key === 'ArrowLeft') {
      currentIndex = (currentIndex - 1 + imageList.length) % imageList.length;
      updateImage();
    } else if(e.key === 'ArrowRight') {
      currentIndex = (currentIndex + 1) % imageList.length;
      updateImage();
    } else if(e.key === 'Escape') {
      ctrl('close', win);
    }
  };
  
  // Focus the window for keyboard events
  focus(win);
}


// Snake
function openSnake(){
  const win = makeWin('Snake', 400, 500,`<div style="text-align:center"><div style="margin-bottom:8px"><span class="small">Score: <b id="snScore">0</b></span> &nbsp; <span class="small">Best: <b id="snBest">0</b></span></div><canvas id="snCanvas" width="360" height="360" style="background:#0f172a;border-radius:6px"></canvas><div class="small" style="margin-top:8px">Arrow keys / WASD</div><button class="btn" id="snStart" style="margin-top:8px">Start Game</button></div>`);
  const canvas=win.querySelector('#snCanvas'),ctx=canvas.getContext('2d');
  const scoreEl=win.querySelector('#snScore'),bestEl=win.querySelector('#snBest');
  const G=15,C=20;
  let snake,dir,food,score,best=+localStorage.getItem('snakeBest')||0,running=false,loop;
  bestEl.textContent=best;
  
  function init(){
    snake=[{x:10,y:10}];dir={x:1,y:0};score=0;scoreEl.textContent=0;placeFood();running=true; if(loop)clearInterval(loop); loop=setInterval(update,100);
  }
  function placeFood(){food={x:Math.floor(Math.random()*C),y:Math.floor(Math.random()*C)} }
  function update(){
    if(!running)return;
    const head={x:snake[0].x+dir.x,y:snake[0].y+dir.y};
    if(head.x<0||head.x>=C||head.y<0||head.y>=C||snake.some(s=>s.x===head.x&&s.y===head.y)){
      running=false;clearInterval(loop); sfx('error'); 
      if(score>best){best=score;localStorage.setItem('snakeBest',best);bestEl.textContent=best;}
      return;
    }
    snake.unshift(head);
    if(head.x===food.x&&head.y===food.y){score++;scoreEl.textContent=score;placeFood(); sfx('save')} else snake.pop();
    draw();
  }
  function draw(){ctx.fillStyle='#0f172a';ctx.fillRect(0,0,300,300);ctx.fillStyle='#22c55e';snake.forEach(s=>ctx.fillRect(s.x*G,s.y*G,G-1,G-1));ctx.fillStyle='#ef4444';ctx.fillRect(food.x*G,food.y*G,G-1,G-1);}  
  win.querySelector('#snStart').onclick=init;
  window.addEventListener('keydown',e=>{if(!running)return; if((e.key==='ArrowUp'||e.key==='w')&&dir.y!==1)dir={x:0,y:-1}; else if((e.key==='ArrowDown'||e.key==='s')&&dir.y!==-1)dir={x:0,y:1}; else if((e.key==='ArrowLeft'||e.key==='a')&&dir.x!==1)dir={x:-1,y:0}; else if((e.key==='ArrowRight'||e.key==='d')&&dir.x!==-1)dir={x:1,y:0};});
  draw();
}
// Flappy Bird - SUPER FUN VERSION!
function openFlappyBird(){
  const win = makeWin('Flappy Bird', 400, 550,`<div style="display:flex;flex-direction:column;height:100%;position:relative;background:linear-gradient(180deg, #4ec0ca 0%, #4299ad 100%)"><div style="display:flex;justify-content:space-between;align-items:center;padding:12px;background:rgba(0,0,0,0.3);border-radius:8px;margin-bottom:8px"><div><div class="small" style="color:#fff">SCORE</div><div style="font-size:32px;font-weight:bold;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,0.5)" id="fbScore">0</div></div><div><div class="small" style="color:#fff">BEST</div><div style="font-size:32px;font-weight:bold;color:#fbbf24;text-shadow:2px 2px 4px rgba(0,0,0,0.5)" id="fbBest">0</div></div></div><div style="flex:1;position:relative;overflow:hidden;border-radius:8px;box-shadow:inset 0 0 20px rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center"><canvas id="fbCanvas" width="360" height="400" style="display:block;cursor:pointer"></canvas></div><div style="text-align:center;margin-top:12px;color:#fff;text-shadow:1px 1px 2px rgba(0,0,0,0.5)"><div class="small">Click or SPACE to flap! üê¶</div><button class="btn" id="fbStart" style="margin-top:8px;background:#fbbf24;color:#000;font-weight:bold;padding:10px 24px">START GAME</button></div></div>`);
  const canvas=win.querySelector('#fbCanvas');
  const ctx=canvas.getContext('2d');
  const scoreEl=win.querySelector('#fbScore');
  const bestEl=win.querySelector('#fbBest');
  const startBtn=win.querySelector('#fbStart');
  
  // Lock canvas size
  const CANVAS_WIDTH = 380;
  const CANVAS_HEIGHT = 500;
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  
  let bird, pipes, score, best, gameRunning, gravity, jumpPower, gameLoop, pipeTimer;
  best = +localStorage.getItem('flappyBest') || 0;
  bestEl.textContent = best;
  
  // Particle system for effects
  let particles = [];
  
  function init(){
    bird = {
      x: 80,
      y: 250,
      vy: 0,
      size: 20,
      rotation: 0
    };
    pipes = [];
    score = 0;
    gravity = 0.5;
    jumpPower = -9;
    gameRunning = true;
    scoreEl.textContent = 0;
    particles = [];
    
    if(gameLoop) cancelAnimationFrame(gameLoop);
    if(pipeTimer) clearInterval(pipeTimer);
    
    gameLoop = requestAnimationFrame(update);
    
    // Add new pipes periodically - FIXED spacing
    pipeTimer = setInterval(()=>{
      if(gameRunning) {
        const lastPipe = pipes[pipes.length - 1];
        // Only add pipe if last one is far enough
        if(!lastPipe || lastPipe.x < CANVAS_WIDTH - 200){
          createPipe(CANVAS_WIDTH);
        }
      }
    }, 1800);
    
    startBtn.textContent = 'RESTART';
    playSFX('start');
  }
  
  function createPipe(x){
    const gap = 150;
    const minHeight = 80;
    const maxHeight = 280;
    const topHeight = Math.random() * (maxHeight - minHeight) + minHeight;
    
    pipes.push({
      x: x,
      topHeight: topHeight,
      bottomY: topHeight + gap,
      width: 60,
      scored: false,
      color: `hsl(${Math.random()*60 + 80}, 70%, 50%)` // Random green shades
    });
  }
  
  function jump(){
    if(!gameRunning) return;
    bird.vy = jumpPower;
    bird.rotation = -25;
    
    // Create flap particles
    for(let i=0; i<8; i++){
      particles.push({
        x: bird.x - 10,
        y: bird.y + bird.size/2,
        vx: -Math.random() * 3 - 1,
        vy: Math.random() * 4 - 2,
        life: 1,
        size: Math.random() * 4 + 2,
        color: '#fff'
      });
    }
  }
  
  function update(){
    if(!gameRunning) return;
    
    // Update bird
    bird.vy += gravity;
    bird.y += bird.vy;
    
    // Rotation based on velocity
    bird.rotation = Math.min(Math.max(bird.vy * 3, -25), 90);
    
    // Update pipes
    for(let i = pipes.length - 1; i >= 0; i--){
      const pipe = pipes[i];
      pipe.x -= 3;
      
      // Score when passing pipe
      if(!pipe.scored && pipe.x + pipe.width < bird.x){
        pipe.scored = true;
        score++;
        scoreEl.textContent = score;
        playSFX('score');
        
        // Score particles
        for(let j=0; j<15; j++){
          particles.push({
            x: bird.x,
            y: bird.y,
            vx: Math.random() * 6 - 3,
            vy: Math.random() * 6 - 3,
            life: 1,
            size: Math.random() * 5 + 3,
            color: '#fbbf24'
          });
        }
        
        if(score > best){
          best = score;
          localStorage.setItem('flappyBest', best);
          bestEl.textContent = best;
        }
      }
      
      // Remove off-screen pipes
      if(pipe.x + pipe.width < 0){
        pipes.splice(i, 1);
      }
    }
    
    // Update particles
    particles = particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.2;
      p.life -= 0.02;
      return p.life > 0;
    });
    
    // Check collisions
    checkCollisions();
    
    // Draw everything
    draw();
    
    gameLoop = requestAnimationFrame(update);
  }
  
  function checkCollisions(){
    // Ground and ceiling
    if(bird.y + bird.size > CANVAS_HEIGHT - 50 || bird.y < 0){
      gameOver();
      return;
    }
    
    // Pipes
    pipes.forEach(pipe => {
      const birdRight = bird.x + bird.size;
      const birdBottom = bird.y + bird.size;
      
      if(birdRight > pipe.x && bird.x < pipe.x + pipe.width){
        if(bird.y < pipe.topHeight || birdBottom > pipe.bottomY){
          gameOver();
        }
      }
    });
  }
  
  function gameOver(){
    gameRunning = false;
    clearInterval(pipeTimer);
    playSFX('gameover');
    
    // Death explosion particles
    for(let i=0; i<30; i++){
      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * 8 + 3;
      particles.push({
        x: bird.x + bird.size/2,
        y: bird.y + bird.size/2,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1,
        size: Math.random() * 6 + 4,
        color: '#ef4444'
      });
    }
    
    setTimeout(() => {
      const msg = score === best && score > 0 ? 
        `Game Over! NEW BEST: ${score} üèÜ` : 
        `Game Over! Score: ${score}`;
      showNotification('Flappy Bird', msg, score === best ? 'success' : 'info', 4000);
    }, 500);
  }
  
  function draw(){
    // Sky with clouds effect
    ctx.fillStyle = '#4ec0ca';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Clouds
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    for(let i=0; i<5; i++){
      const x = ((Date.now() * 0.01 + i * 100) % (CANVAS_WIDTH + 100)) - 50;
      ctx.beginPath();
      ctx.arc(x, 50 + i * 30, 20, 0, Math.PI * 2);
      ctx.arc(x + 20, 50 + i * 30, 25, 0, Math.PI * 2);
      ctx.arc(x + 40, 50 + i * 30, 20, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw pipes
    pipes.forEach(pipe => {
      // Pipe shadow
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.fillRect(pipe.x + 4, 0, pipe.width, pipe.topHeight + 4);
      ctx.fillRect(pipe.x + 4, pipe.bottomY + 4, pipe.width, CANVAS_HEIGHT - pipe.bottomY);
      
      // Top pipe
      ctx.fillStyle = pipe.color;
      ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight);
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.fillRect(pipe.x, 0, 8, pipe.topHeight);
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(pipe.x + pipe.width - 8, 0, 8, pipe.topHeight);
      
      // Bottom pipe
      ctx.fillStyle = pipe.color;
      ctx.fillRect(pipe.x, pipe.bottomY, pipe.width, CANVAS_HEIGHT - pipe.bottomY);
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.fillRect(pipe.x, pipe.bottomY, 8, CANVAS_HEIGHT - pipe.bottomY);
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(pipe.x + pipe.width - 8, pipe.bottomY, 8, CANVAS_HEIGHT - pipe.bottomY);
      
      // Pipe caps
      ctx.fillStyle = pipe.color;
      ctx.fillRect(pipe.x - 5, pipe.topHeight - 30, pipe.width + 10, 30);
      ctx.fillRect(pipe.x - 5, pipe.bottomY, pipe.width + 10, 30);
    });
    
    // Draw particles
    particles.forEach(p => {
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    
    // Draw bird with rotation
    ctx.save();
    ctx.translate(bird.x + bird.size/2, bird.y + bird.size/2);
    ctx.rotate(bird.rotation * Math.PI / 180);
    
    // Bird shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(-bird.size/2 + 2, -bird.size/2 + 2, bird.size, bird.size);
    
    // Bird body
    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(-bird.size/2, -bird.size/2, bird.size, bird.size);
    
    // Bird eye
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(bird.size/4, -bird.size/4, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(bird.size/4, -bird.size/4, 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Bird beak
    ctx.fillStyle = '#f97316';
    ctx.beginPath();
    ctx.moveTo(bird.size/2, 0);
    ctx.lineTo(bird.size/2 + 8, -2);
    ctx.lineTo(bird.size/2 + 8, 2);
    ctx.fill();
    
    // Wing
    ctx.fillStyle = '#f59e0b';
    ctx.beginPath();
    ctx.ellipse(-2, 2, 8, 5, Math.sin(Date.now() * 0.01) * 0.5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
    
    // Ground
    ctx.fillStyle = '#8b4513';
    ctx.fillRect(0, CANVAS_HEIGHT - 50, CANVAS_WIDTH, 50);
    ctx.fillStyle = '#6b3410';
    for(let i=0; i<CANVAS_WIDTH; i+=20){
      ctx.fillRect(i, CANVAS_HEIGHT - 50, 10, 50);
    }
  }
  
  // Sound effects
  function playSFX(type){
    const actx = audioCtx;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.connect(g);
    g.connect(actx.destination);
    const now = actx.currentTime;
    
    if(type === 'flap'){
      o.type = 'sine';
      o.frequency.setValueAtTime(400, now);
      o.frequency.exponentialRampToValueAtTime(600, now + 0.1);
      g.gain.setValueAtTime(0.15, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
    } else if(type === 'score'){
      o.type = 'square';
      o.frequency.setValueAtTime(800, now);
      o.frequency.setValueAtTime(1000, now + 0.05);
      o.frequency.setValueAtTime(1200, now + 0.1);
      g.gain.setValueAtTime(0.1, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
    } else if(type === 'gameover'){
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(400, now);
      o.frequency.exponentialRampToValueAtTime(100, now + 0.5);
      g.gain.setValueAtTime(0.2, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
    } else if(type === 'start'){
      o.type = 'sine';
      o.frequency.setValueAtTime(600, now);
      o.frequency.setValueAtTime(800, now + 0.1);
      g.gain.setValueAtTime(0.1, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
    }
    
    o.start(now);
    o.stop(now + 0.6);
  }
  
  // Controls
  canvas.onclick = jump;
  window.addEventListener('keydown', e => {
    if(e.code === 'Space' && win.style.display !== 'none'){
      e.preventDefault();
      jump();
    }
  });
  
  startBtn.onclick = init;
  
  draw();
}

// Debounce rapid renders
let renderTimeout;
function debounceRender(fn, delay = 100) {
  clearTimeout(renderTimeout);
  renderTimeout = setTimeout(fn, delay);
}

// Optimize window rendering
function requestIdleCallbackPolyfill(callback) {
  if('requestIdleCallback' in window) {
    return requestIdleCallback(callback);
  }
  return setTimeout(callback, 0);
}
// Space Invaders Game - ENHANCED VERSION
function openSpaceInvaders() {
    const win = makeWin("Space Invaders", 700, 600, "");

    const html = `
        <div style="padding:10px;display:flex;flex-direction:column;gap:10px;height:100%">
            <div style="display:flex;justify-content:space-between;align-items:center;">
                <div style="display:flex;gap:20px;font-size:16px">
                    <span>SCORE: <b id="siScore">0</b></span>
                    <span>LIVES: <b id="siLives">3</b></span>
                    <span>LEVEL: <b id="siLevel">1</b></span>
                </div>
                <button id="siStart" class="btn" style="padding:5px 12px;font-size:14px">START</button>
            </div>
            <canvas id="siCanvas" width="680" height="520" style="background:#000;border-radius:12px;border:2px solid rgba(255,255,255,0.15)"></canvas>
        </div>
    `;
    win.querySelector(".win-body").innerHTML = html;

    // Elements
    const canvas = win.querySelector("#siCanvas");
    const ctx = canvas.getContext("2d");

    const scoreEl = win.querySelector("#siScore");
    const livesEl = win.querySelector("#siLives");
    const levelEl = win.querySelector("#siLevel");
    const startBtn = win.querySelector("#siStart");

    // Game Vars
    let player, invaders, bullets, invaderBullets, particles;
    let score, lives, level;
    let gameRunning = false;
    let keys = {};
    let gameLoop;

    let canShoot = true;
    let bulletSafeTime = 0;

    // Key Input
    window.addEventListener("keydown", e => keys[e.code] = true);
    window.addEventListener("keyup", e => keys[e.code] = false);

    startBtn.onclick = init;

    function init() {
        // Player
        player = {
            x: canvas.width/2 - 20,
            y: canvas.height - 40,
            width: 40,
            height: 15,
            speed: 5
        };

        // Invaders
        invaders = [];
        const rows = 4;
        const cols = 9;
        const w = 30, h = 20;
        const gap = 12;

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                invaders.push({
                    x: 40 + c * (w + gap),
                    y: 40 + r * (h + gap),
                    width: w,
                    height: h,
                    alive: true,
                    dx: 1,
                    type: r % 3
                });
            }
        }

        bullets = [];
        invaderBullets = [];
        particles = [];

        score = 0;
        lives = 3;
        level = 1;

        scoreEl.textContent = score;
        livesEl.textContent = lives;
        levelEl.textContent = level;

        bulletSafeTime = performance.now() + 300;

        gameRunning = true;
        cancelAnimationFrame(gameLoop);
        gameLoop = requestAnimationFrame(update);

        startBtn.textContent = "RESTART";
    }

    function update() {
        if (!gameRunning) return;

        drawStarfield();

        // Move Player
        if (keys["ArrowLeft"] || keys["KeyA"]) player.x = Math.max(0, player.x - player.speed);
        if (keys["ArrowRight"] || keys["KeyD"]) player.x = Math.min(canvas.width - player.width, player.x + player.speed);
        if (keys["Space"]) shoot();

        // Move Invaders
        let moveDown = false;
        const speed = 0.4 + level * 0.12;

        invaders.forEach(inv => {
            if (!inv.alive) return;

            inv.x += inv.dx * speed;

            if (inv.x <= 0 || inv.x + inv.width >= canvas.width) {
                moveDown = true;
            }
        });

        if (moveDown) {
            invaders.forEach(inv => {
                inv.y += 16;
                inv.dx *= -1;
            });
        }

        // Player Bullets
        bullets = bullets.filter(b => {
            b.y -= b.speed;
            return b.y > 0;
        });

        // Invader Bullets
        invaderBullets = invaderBullets.filter(b => {
            b.y += b.speed;
            return b.y < canvas.height;
        });

        // Invader shooting
        if (Math.random() < 0.02 + level * 0.005) {
            const alive = invaders.filter(i => i.alive);
            if (alive.length > 0) {
                const shooter = alive[Math.floor(Math.random() * alive.length)];

                invaderBullets.push({
                    x: shooter.x + shooter.width/2,
                    y: shooter.y + shooter.height,
                    width: 4,
                    height: 10,
                    speed: 3 + level * 0.3
                });
            }
        }

        // Bullet ‚Üí Invader collision
        bullets.forEach((b, bi) => {
            invaders.forEach(inv => {
                if (inv.alive && check(b, inv)) {
                    inv.alive = false;
                    bullets.splice(bi, 1);
                    score += 10;
                    scoreEl.textContent = score;
                    explode(inv.x, inv.y);
                }
            });
        });

        // Invader bullet ‚Üí player
        invaderBullets.forEach((b, bi) => {
            if (performance.now() > bulletSafeTime && check(b, player)) {
                invaderBullets.splice(bi, 1);
                lives--;
                livesEl.textContent = lives;
                explode(player.x, player.y);
                if (lives <= 0) return gameOver();
            }
        });

        // Invaders reach player
        if (invaders.some(i => i.alive && i.y > player.y - 30)) return gameOver();

        // Level complete
        if (invaders.every(i => !i.alive)) {
            level++;
            levelEl.textContent = level;
            setTimeout(init, 1200);
            return;
        }

        draw();
        gameLoop = requestAnimationFrame(update);
    }

    function drawStarfield() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    //----------------------
    // MODERN INVADER DRAW
    //----------------------
    function drawModernInvader(inv) {
        ctx.save();
        ctx.translate(inv.x + inv.width / 2, inv.y + inv.height / 2);

        const colors = ["#4ade80", "#38bdf8", "#f472b6"];
        ctx.fillStyle = colors[inv.type];
        ctx.shadowColor = colors[inv.type];
        ctx.shadowBlur = 12;

        switch (inv.type) {
            case 0: // diamond
                ctx.beginPath();
                ctx.moveTo(0, -12);
                ctx.lineTo(12, 0);
                ctx.lineTo(0, 12);
                ctx.lineTo(-12, 0);
                ctx.closePath();
                ctx.fill();
                break;

            case 1: // triangle
                ctx.beginPath();
                ctx.moveTo(0, -13);
                ctx.lineTo(13, 10);
                ctx.lineTo(-13, 10);
                ctx.closePath();
                ctx.fill();
                break;

            case 2: // hexagon
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    ctx.lineTo(Math.cos(angle) * 12, Math.sin(angle) * 12);
                }
                ctx.closePath();
                ctx.fill();
                break;
        }

        ctx.restore();
    }

    function draw() {
        // Player Ship (modern V)
        ctx.save();
        ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
        ctx.fillStyle = "#3b82f6";
        ctx.shadowColor = "#3b82f6";
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(14, 10);
        ctx.lineTo(-14, 10);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Invaders
        invaders.forEach(inv => inv.alive && drawModernInvader(inv));

        // Player Bullets
        ctx.fillStyle = "#3b82f6";
        ctx.shadowColor = "#3b82f6";
        ctx.shadowBlur = 8;

        bullets.forEach(b => {
            ctx.beginPath();
            ctx.arc(b.x + 2, b.y, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        ctx.shadowBlur = 0;

        // Invader Bullets
        ctx.fillStyle = "#f59e0b";
        invaderBullets.forEach(b =>
            ctx.fillRect(b.x, b.y, b.width, b.height)
        );

        // Particles
        particles = particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
            ctx.fillStyle = `rgba(255,200,80,${p.life})`;
            ctx.fillRect(p.x, p.y, 3, 3);
            return p.life > 0;
        });
    }

    //----------------------
    // SHOOT
    //----------------------
    function shoot() {
        if (!gameRunning || !canShoot) return;
        if (bullets.length >= 1) return;

        bullets.push({
            x: player.x + player.width / 2 - 2,
            y: player.y - 20,
            width: 4,
            height: 10,
            speed: 7
        });

        canShoot = false;
        setTimeout(() => (canShoot = true), 200);
    }

    function explode(x, y) {
        for (let i = 0; i < 20; i++) {
            particles.push({
                x,
                y,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3,
                life: 1
            });
        }
    }

    function check(a, b) {
        return (
            a.x < b.x + b.width &&
            a.x + a.width > b.x &&
            a.y < b.y + b.height &&
            a.y + a.height > b.y
        );
    }

    function gameOver() {
        gameRunning = false;
        alert("GAME OVER\nScore: " + score);
    }
}




function openGames(){
  const scoreSnake = localStorage.getItem('snakeBest') || 0;
  const scoreFlappy = localStorage.getItem('flappyBest') || 0;
  const scoreSpace = localStorage.getItem('spaceBest') || 0;

  const content = `
    <div style="
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:12px;
      padding:10px;
    ">

      <div class="game-tile" data-game="snake">
        <div class="game-icon">üêç</div>
        <div class="game-title">Snake</div>
        <div class="game-score">Score: <b>${scoreSnake}</b></div>
      </div>
      
      <div class="game-tile" data-game="game2048">
        <div class="game-icon">üß©</div>
        <div class="game-title">2048</div>
        <div class="game-score">Score: <b>${localStorage.getItem('g2048best') || 0}</b></div>
      </div>

      <div class="game-tile" data-game="pong">
        <div class="game-icon">üèì</div>
        <div class="game-title">Pong</div>
      </div>

      <div class="game-tile" data-game="tetris">
        <div class="game-icon">üß±</div>
        <div class="game-title">Tetris</div>
        <div class="game-score">Score: <b>${localStorage.getItem('tetrisBest') || 0}</b></div>
      </div>

      <div class="game-tile" data-game="dino">
        <div class="game-icon">ü¶ñ</div>
        <div class="game-title">Dino Chrome</div>
        <div class="game-score">Best: <b>${localStorage.getItem('dinoBest') || 0}</b></div>
      </div>

      <div class="game-tile" data-game="flappybird">
        <div class="game-icon">ü¶Ö</div>
        <div class="game-title">Flappy Bird</div>
        <div class="game-score">Score: <b>${scoreFlappy}</b></div>
      </div>

      <div class="game-tile" data-game="spaceinvaders">
        <div class="game-icon">üëæ</div>
        <div class="game-title">Space Invaders</div>
        <div class="game-score">Score: <b>${scoreSpace}</b></div>
      </div>

    </div>
  `;


  const win = makeWin('Games', 360, 480, content);

  win.querySelectorAll('.game-tile').forEach(tile => {
    tile.onclick = () => {
      const game = tile.dataset.game;
      if(game === 'snake') openSnake();
      if(game === 'flappybird') openFlappyBird();
      if(game === 'spaceinvaders') openSpaceInvaders();
      if(game === 'game2048') open2048();
      if(game === 'pong') openPong();
	  if(game === 'tetris') openTetris();
	  if(game==="dino") return openDino();
    };
  });
}
function openDino(){
  // create window content
  const html = `
    <style>
      .dino-wrap { width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,#87CEEB 0%, #BFE9FF 60%, #9FD6FF 100%); }
      .dino-canvas { border-radius:10px; box-shadow: 0 10px 40px rgba(2,6,23,0.6); background: transparent; }
      .dino-hud { position:absolute; right:18px; top:12px; color:#07304a; font-weight:700; font-family: Inter, system-ui, sans-serif; text-shadow: 0 1px 0 rgba(255,255,255,0.4);}
      .dino-controls { position:absolute; left:18px; top:12px; color:#07304a; font-size:13px; opacity:0.85; }
      .dino-footer { position:absolute; bottom:18px; left:18px; color:#083047; font-size:12px; }
      .btn-small { background: rgba(255,255,255,0.12); padding:6px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); color:inherit; cursor:pointer; margin-left:8px; }
    </style>
    <div style="position:relative;height:100%;display:flex;align-items:center;justify-content:center;">
      <div class="dino-wrap" id="dinoWrap" style="width:calc(100% - 40px);height:calc(100% - 80px);">
        <canvas class="dino-canvas" id="dinoCanvas" width="1100" height="360"></canvas>
        <div class="dino-hud" id="dinoHud">SCORE: <span id="dinoScore">0</span></div>
        <div class="dino-controls">SPACE / ‚Üë Jump ¬∑ ‚Üì Duck ¬∑ TAP to jump
          <button id="dinoRestart" class="btn-small">Restart</button>
        </div>
        <div class="dino-footer" id="dinoFooter">Highscore: <span id="dinoHigh">0</span></div>
      </div>
    </div>
  `;
  const win = makeWin('Dino ‚Äî Offline Game', 1100,420, html);
  const canvas = win.querySelector('#dinoCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  const scoreEl = win.querySelector('#dinoScore');
  const highEl = win.querySelector('#dinoHigh');
  const restartBtn = win.querySelector('#dinoRestart');

  // --- Procedural textures (small offscreen canvases used as patterns) ---
  function makeNoisePattern(size, density=0.06, tint='#ffffff', alpha=0.06){
    const c = document.createElement('canvas');
    c.width = c.height = size;
    const g = c.getContext('2d');
    g.fillStyle = tint;
    g.globalAlpha = alpha;
    for(let i=0;i<size*size*density;i++){
      g.fillRect(Math.random()*size, Math.random()*size, Math.random()*2+0.5, Math.random()*2+0.5);
    }
    g.globalAlpha = 1;
    return ctx.createPattern(c, 'repeat');
  }
  function makeStripPattern(w, h, color1, color2, stripeWidth=6){
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const g = c.getContext('2d');
    // stripes
    g.fillStyle = color1; g.fillRect(0,0,w,h);
    g.fillStyle = color2;
    for(let x = -w; x < w*2; x += stripeWidth*2){
      g.fillRect(x,0,stripeWidth,h);
    }
    return ctx.createPattern(c, 'repeat');
  }

  const grain = makeNoisePattern(64, 0.03, '#000000', 0.06);
  const rockPattern = makeNoisePattern(48, 0.02, '#2b2b2b', 0.07);
  const cactusBark = makeStripPattern(40,40, '#0b7a36', '#08602b', 6);
  const dinoSkin = makeStripPattern(24,24, '#1b2b12', '#22321c', 4);
  const cloudPattern = makeNoisePattern(80,0.01,'#ffffff',0.06);

  // --- Game variables ---
  const W = canvas.width, H = canvas.height;
  let running = true;
  let speed = 6;
  let gravity = 0.9;
  let groundY = H - 80;
  let score = 0;
  let high = parseInt(localStorage.getItem('webos_dino_high') || '0', 10);
  highEl.textContent = high;
  let tick = 0;

  // player
  const player = {
    x: 80,
    y: groundY - 48,
    w: 44,
    h: 48,
    vy: 0,
    jumping: false,
    ducking: false,
    runFrame: 0,
    blink: 0
  };

  // obstacles & clouds
  let obstacles = [];
  let clouds = [];
  let spawnTimer = 0;
  let nextSpawn = 80 + Math.random()*120;

  // Input
  const keys = {};
  function onKeyDown(e){
    if(e.key === ' ' || e.key === 'ArrowUp') { e.preventDefault(); jump(); }
    if(e.key === 'ArrowDown') { e.preventDefault(); duck(true); }
    if(e.key === 'p') { running = !running; }
  }
  function onKeyUp(e){
    if(e.key === 'ArrowDown') { duck(false); }
  }
  function onTouchStart(e){
    jump();
  }
  window.addEventListener('keydown', onKeyDown);
  window.addEventListener('keyup', onKeyUp);
  canvas.addEventListener('touchstart', onTouchStart, {passive:true});
  canvas.addEventListener('mousedown', onTouchStart);

  restartBtn.onclick = () => reset();

  // Utilities
  function rand(min,max){ return min + Math.random()*(max-min); }
  function rectsIntersect(a,b){
    return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
  }

  // Spawn obstacles: cacti or pterodactyl
  function spawnObstacle(){
    const kind = Math.random() < 0.15 ? 'ptero' : 'cactus';
    if(kind === 'cactus'){
      const sizes = [{w:18,h:36},{w:30,h:46},{w:40,h:56}];
      const s = sizes[Math.floor(Math.random()*sizes.length)];
      obstacles.push({
        type:'cactus',
        x: W + 40,
        y: groundY - s.h,
        w: s.w,
        h: s.h,
        pattern: cactusBark
      });
    } else {
      // pterodactyl - variable height
      const height = groundY - 120 - Math.random()*80;
      obstacles.push({
        type:'ptero',
        x: W + 40,
        y: height,
        w: 52,
        h: 32,
        flap: 0
      });
    }
  }

  // Clouds spawn
  function spawnCloud(){
    clouds.push({
      x: W + Math.random()*200,
      y: 40 + Math.random()*120,
      w: 120 + Math.random()*80,
      h: 40 + Math.random()*30,
      speed: 0.6 + Math.random()*0.9,
      alpha: 0.5 + Math.random()*0.5
    });
  }

  // Player controls
  function jump(){
    if(player.jumping || !running) return;
    player.vy = -15 - Math.random()*2;
    player.jumping = true;
    player.ducking = false;
    sfx('jump');
  }
  function duck(on){
    player.ducking = !!on && !player.jumping;
    if(player.ducking) player.h = 28; else player.h = 48;
  }

  // Simple SFX using WebAudio (non-blocking)
  const audioCtxLocal = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
  function sfx(name){
    if(!audioCtxLocal) return;
    try{
      const o = audioCtxLocal.createOscillator();
      const g = audioCtxLocal.createGain();
      o.connect(g); g.connect(audioCtxLocal.destination);
      const now = audioCtxLocal.currentTime;
      if(name==='jump'){ o.type='sine'; o.frequency.setValueAtTime(700,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.06, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.3); }
      else if(name==='hit'){ o.type='sawtooth'; o.frequency.setValueAtTime(160,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.12, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.25); }
      o.start(now); o.stop(now+0.25);
    }catch(e){}
  }

  // Reset / init
  function reset(){
    obstacles = [];
    clouds = [];
    player.y = groundY - player.h;
    player.vy = 0;
    player.jumping = false;
    player.ducking = false;
    speed = 6;
    score = 0;
    tick = 0;
    spawnTimer = 0;
    nextSpawn = 80 + Math.random()*120;
    running = true;
  }

  reset();
  // initial cloud cover
  for(let i=0;i<4;i++) spawnCloud();

  // Game loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(40, now - last);
    last = now;
    if(running){
      update(dt/16);
      render();
    } else {
      // paused - draw still
      render();
      // muting logic could be added
    }
    if(!win || !document.getElementById(win.id)) {
      // window closed -> cleanup listeners
      window.removeEventListener('keydown', onKeyDown);
      window.removeEventListener('keyup', onKeyUp);
      canvas.removeEventListener('touchstart', onTouchStart);
      canvas.removeEventListener('mousedown', onTouchStart);
      return;
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function update(speedFactor){
    tick++;
    // update clouds
    for(let i=clouds.length-1;i>=0;i--){
      clouds[i].x -= clouds[i].speed * speedFactor * 0.8;
      if(clouds[i].x + clouds[i].w < -40) clouds.splice(i,1);
    }
    if(Math.random() < 0.02) spawnCloud();

    // obstacles
    spawnTimer++;
    if(spawnTimer > nextSpawn){
      spawnObstacle();
      spawnTimer = 0;
      nextSpawn = 60 + Math.random()*140 - Math.min(80, score/10);
    }

    for(let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      o.x -= (speed + score*0.01) * speedFactor;
      if(o.type === 'ptero'){ o.flap += 0.2 * speedFactor; o.y += Math.sin(o.flap)*0.4; }
      if(o.x + o.w < -40){
        obstacles.splice(i,1);
        continue;
      }
      // collision with player (simple box)
      const playerBox = { x: player.x, y: player.y, w: player.w, h: player.h };
      const obsBox = { x: o.x, y: o.y, w: o.w, h: o.h };
      if(rectsIntersect(playerBox, obsBox)){
        // hit
        sfx('hit');
        running = false;
        // check highscore
        if(score > high){ high = Math.floor(score); localStorage.setItem('webos_dino_high', high.toString()); highEl.textContent = high; }
        // flash effect
        flashScreen();
      }
    }

    // player physics
    if(player.jumping){
      player.vy += gravity * (0.9 + score*0.0004) * speedFactor;
      player.y += player.vy * speedFactor;
      if(player.y >= groundY - player.h){
        player.y = groundY - player.h;
        player.vy = 0;
        player.jumping = false;
        player.blink = 30;
      }
    }

    // duck friction
    if(player.ducking) {
      player.runFrame = 0;
      player.blink = 0;
    } else {
      // run animation frame
      if(!player.jumping){
        if(tick % 6 === 0) player.runFrame = (player.runFrame + 1) % 2;
      } else {
        player.runFrame = 0;
      }
    }

    // score & speed scaling
    score += 0.08 * speedFactor;
    if(Math.floor(score) % 100 === 0 && Math.floor(score) !== 0){
      speed += 0.002 * Math.max(1, score/100); // gradual speed up
    }

    scoreEl.textContent = Math.floor(score);

    // occasionally spawn big rock
    if(Math.random() < 0.001) {
      obstacles.push({ type:'rock', x: W + 80 + Math.random()*200, y: groundY - 28, w: 36, h: 28, pattern: rockPattern });
    }
  }

  // nice flash on death
  let flashAlpha = 0;
  function flashScreen(){
    flashAlpha = 1;
    const t = setInterval(()=>{ flashAlpha -= 0.06; if(flashAlpha <= 0){ clearInterval(t); flashAlpha = 0; } }, 60);
  }

  // render everything textured & with style
  function render(){
    // background gradient (sky -> horizon)
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#87CEEB');
    g.addColorStop(0.6, '#BFE9FF');
    g.addColorStop(1, '#9FD6FF');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // distant mountains ‚Äî procedural textured shapes
    ctx.save();
    ctx.translate(0, 0);
    for(let i=0;i<3;i++){
      const offset = i*160;
      ctx.beginPath();
      ctx.moveTo(-50 + i*120, groundY - 60);
      for(let x= -50; x < W + 50; x+=40){
        ctx.lineTo(x, groundY - 120 - Math.sin((x/120)+i)*28 - (i*12));
      }
      ctx.lineTo(W+50, H);
      ctx.lineTo(-50,H);
      ctx.closePath();
      ctx.fillStyle = `rgba(10,30,40,${0.03 + i*0.03})`;
      ctx.fill();
    }
    ctx.restore();

    // clouds (with subtle pattern)
    clouds.forEach(c=>{
      ctx.save();
      ctx.globalAlpha = c.alpha;
      // cloud body
      const cloudX = c.x, cloudY = c.y;
      ctx.beginPath();
      ctx.ellipse(cloudX, cloudY, c.w*0.45, c.h*0.5, 0, 0, Math.PI*2);
      ctx.ellipse(cloudX + c.w*0.2, cloudY - 4, c.w*0.25, c.h*0.35, 0,0,Math.PI*2);
      ctx.ellipse(cloudX - c.w*0.22, cloudY - 6, c.w*0.22, c.h*0.32,0,0,Math.PI*2);
      ctx.closePath();
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      // texture overlay
      ctx.globalCompositeOperation = 'overlay';
      ctx.fillStyle = cloudPattern;
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
      ctx.restore();
    });

    // ground (textured)
    ctx.save();
    ctx.fillStyle = '#dedede';
    ctx.fillRect(0, groundY, W, H - groundY);
    // textured overlay
    ctx.fillStyle = grain;
    ctx.globalAlpha = 0.18;
    ctx.fillRect(0, groundY, W, H - groundY);
    ctx.globalAlpha = 1;
    ctx.restore();

    // obstacles
    obstacles.forEach(o=>{
      ctx.save();
      if(o.type === 'cactus'){
        ctx.fillStyle = '#0b7a36';
        ctx.fillRect(o.x, o.y, o.w, o.h);
        // trunk texture overlay
        ctx.fillStyle = o.pattern;
        ctx.globalAlpha = 0.9;
        ctx.fillRect(o.x, o.y, o.w, o.h);
        // little spikes
        ctx.fillStyle = '#7fe29d';
        for(let i=0;i<3;i++){
          const sx = o.x + 4 + i*(o.w/3);
          ctx.beginPath();
          ctx.moveTo(sx, o.y + 4);
          ctx.lineTo(sx+6, o.y + 10);
          ctx.lineTo(sx-4, o.y + 10);
          ctx.closePath();
          ctx.fill();
        }
      } else if(o.type === 'ptero'){
        // pterodactyl stylized
        ctx.translate(o.x+o.w/2, o.y+o.h/2);
        ctx.rotate(Math.sin(tick/8 + o.x/200)*0.06);
        ctx.fillStyle = '#2f2f2f';
        ctx.beginPath();
        ctx.moveTo(-o.w/2, 0);
        ctx.quadraticCurveTo(0, -o.h, o.w/2, 0);
        ctx.quadraticCurveTo(0, o.h, -o.w/2, 0);
        ctx.closePath();
        ctx.fill();
      } else if(o.type === 'rock'){
        ctx.fillStyle = '#444';
        ctx.fillRect(o.x, o.y, o.w, o.h);
        ctx.fillStyle = o.pattern;
        ctx.globalAlpha = 0.9;
        ctx.fillRect(o.x, o.y, o.w, o.h);
      }
      ctx.restore();
    });

    // player (textured dino)
    ctx.save();
    const px = player.x, py = player.y, pw = player.w, ph = player.h;
    // body
    ctx.fillStyle = '#2b6a2e';
    if(player.ducking) {
      ctx.fillRect(px-4, py+8, pw+12, ph-12);
    } else {
      const rad = 8;
      roundRect(ctx, px-8, py, pw+16, ph, rad, true, false);
    }
    // skin pattern
    ctx.fillStyle = dinoSkin;
    ctx.globalAlpha = 0.85;
    if(player.ducking) ctx.fillRect(px-4, py+8, pw+12, ph-12);
    else roundRect(ctx, px-8, py, pw+16, ph, 8, true, false);
    ctx.globalAlpha = 1;
    // eye
    ctx.fillStyle = '#fff';
    if(!player.ducking){
      ctx.beginPath();
      ctx.ellipse(px + pw/2 + 6, py + 12, 6, 6, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#0b2b10';
      ctx.beginPath();
      ctx.ellipse(px + pw/2 + 8, py + 12, 3, 3, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // small shadow
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath();
    ctx.ellipse(player.x + player.w/2 + 6, groundY + 8, 28, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // HUD drawn already as DOM; draw flashes on death
    if(flashAlpha > 0){
      ctx.fillStyle = `rgba(255,255,255,${flashAlpha})`;
      ctx.fillRect(0,0,W,H);
      flashAlpha -= 0.02;
      if(flashAlpha < 0) flashAlpha = 0;
    }
  }

  // handy rounded rect
  function roundRect(ctx,x,y,w,h,r,fill,stroke){
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // close-detection: on window close remove listeners
  // (makeWin's close button removes DOM; loop checks for presence)

  // For mobile: simple top area tap = jump, bottom area = duck while pressed (optional)
  // NOTE: We already listen to canvas touch and click for jump

  // expose game controls to the window for debugging
  window.dinoGame = {
    reset, getScore: ()=>score, stop: ()=>running=false, resume: ()=>running=true
  };
}

function open2048(){
  const win = makeWin("2048", 350, 450, `
    <div style="padding:10px;display:flex;flex-direction:column;gap:10px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="small">Score: <b id="g2048Score">0</b></div>
        <div class="small">Best: <b id="g2048Best">${localStorage.getItem('g2048best') || 0}</b></div>
      </div>
      <div id="g2048Grid" style="
        display:grid;
        grid-template-columns:repeat(4,1fr);
        gap:8px;
        background:#1e293b;
        padding:8px;
        border-radius:10px;
        position:relative;
      "></div>
      <button class="btn" id="g2048Restart">Restart</button>
    </div>
  `);

  let grid = [];
  let score = 0;

  let lastAdded = null;
  let lastMerged = [];

  const gridEl = win.querySelector("#g2048Grid");
  const scoreEl = win.querySelector("#g2048Score");
  const bestEl = win.querySelector("#g2048Best");

  function init(){
    grid = Array(4).fill().map(()=>Array(4).fill(0));
    score = 0;
    updateScore();
    addRandom();
    addRandom();
    render();
  }

  function updateScore(){
    scoreEl.textContent = score;
    const best = parseInt(localStorage.getItem('g2048best') || 0);
    if(score > best){
      localStorage.setItem("g2048best", score);
      bestEl.textContent = score;
    }
  }

  function addRandom(){
    let empty = [];
    for(let r=0;r<4;r++){
      for(let c=0;c<4;c++){
        if(grid[r][c] === 0) empty.push({r,c});
      }
    }
    if(empty.length === 0) return;
    const spot = empty[Math.floor(Math.random()*empty.length)];
    grid[spot.r][spot.c] = Math.random() < 0.9 ? 2 : 4;

    lastAdded = {r: spot.r, c: spot.c};
  }

  function render(){
    gridEl.innerHTML = "";

    for(let r=0;r<4;r++){
      for(let c=0;c<4;c++){
        const val = grid[r][c];
        const tile = document.createElement("div");

        tile.classList.add("tile");
        if(lastAdded && lastAdded.r === r && lastAdded.c === c) tile.classList.add("tile-new");
        if(lastMerged.some(m=>m.r===r && m.c===c)) tile.classList.add("tile-merge");

        tile.textContent = val || "";
        tile.style = `
          height:70px;
          border-radius:8px;
          display:flex;
          align-items:center;
          justify-content:center;
          font-size:22px;
          font-weight:bold;
          color:#fff;
          background:${getTileColor(val)};
        `;

        gridEl.appendChild(tile);
      }
    }

    lastAdded = null;
    lastMerged = [];
  }

  function getTileColor(v){
    const colors = {
      0:"rgba(255,255,255,0.07)",
      2:"#334155",
      4:"#475569",
      8:"#0ea5e9",
      16:"#38bdf8",
      32:"#6366f1",
      64:"#8b5cf6",
      128:"#f59e0b",
      256:"#fbbf24",
      512:"#f87171",
      1024:"#ef4444",
      2048:"#10b981"
    };
    return colors[v] || "#14b8a6";
  }

  function slide(row, rowIndex){
    let arr = row.filter(v=>v);

    for(let i=0;i<arr.length-1;i++){
      if(arr[i] === arr[i+1]){
        arr[i] *= 2;
        score += arr[i];
        lastMerged.push({r: rowIndex, c: i});
        arr[i+1] = 0;
      }
    }

    arr = arr.filter(v=>v);
    while(arr.length<4) arr.push(0);

    return arr;
  }

  function moveLeft(){
    for(let r=0;r<4;r++) grid[r] = slide(grid[r], r);
    finishMove();
  }

  function moveRight(){
    for(let r=0;r<4;r++) grid[r] = slide(grid[r].reverse(), r).reverse();
    finishMove();
  }

  function moveUp(){
    for(let c=0;c<4;c++){
      let col = [grid[0][c], grid[1][c], grid[2][c], grid[3][c]];
      col = slide(col, 0);
      for(let r=0;r<4;r++) grid[r][c] = col[r];
    }
    finishMove();
  }

  function moveDown(){
    for(let c=0;c<4;c++){
      let col = [grid[0][c], grid[1][c], grid[2][c], grid[3][c]].reverse();
      col = slide(col, 0).reverse();
      for(let r=0;r<4;r++) grid[r][c] = col[r];
    }
    finishMove();
  }

  function finishMove(){
    addRandom();
    updateScore();
    render();
  }

  window.addEventListener("keydown", e=>{
    if(e.key==="ArrowLeft"||e.key==="a") moveLeft();
    if(e.key==="ArrowRight"||e.key==="d") moveRight();
    if(e.key==="ArrowUp"||e.key==="w") moveUp();
    if(e.key==="ArrowDown"||e.key==="s") moveDown();
  });

  win.querySelector("#g2048Restart").onclick = init;
  init();
}
// Tetris Game
function openTetris() {
  const win = makeWin("Tetris", 400, 600, `
    <div style="display:flex;flex-direction:column;height:100%;padding:12px;gap:10px;background:linear-gradient(135deg,#1e293b,#0f172a)">
      <div style="display:flex;justify-content:space-between;align-items:center;background:rgba(255,255,255,0.05);padding:12px;border-radius:10px">
        <div>
          <div class="small" style="color:#94a3b8">SCORE</div>
          <div id="tetrisScore" style="font-size:28px;font-weight:bold;color:#fff">0</div>
        </div>
        <div>
          <div class="small" style="color:#94a3b8">LEVEL</div>
          <div id="tetrisLevel" style="font-size:28px;font-weight:bold;color:#3b82f6">1</div>
        </div>
        <div>
          <div class="small" style="color:#94a3b8">BEST</div>
          <div id="tetrisBest" style="font-size:28px;font-weight:bold;color:#fbbf24">${localStorage.getItem('tetrisBest') || 0}</div>
        </div>
      </div>
      
      <div style="display:flex;gap:10px;flex:1">
        <div style="background:rgba(0,0,0,0.3);padding:10px;border-radius:10px;display:flex;flex-direction:column;gap:8px">
          <div class="small" style="color:#94a3b8">NEXT</div>
          <canvas id="tetrisNext" width="80" height="80" style="background:rgba(0,0,0,0.5);border-radius:6px"></canvas>
          <div class="small" style="color:#94a3b8;margin-top:10px">LINES</div>
          <div id="tetrisLines" style="font-size:20px;font-weight:bold;color:#10b981">0</div>
        </div>
        
        <canvas id="tetrisCanvas" width="240" height="480" style="background:#000;border-radius:10px;box-shadow:0 8px 32px rgba(0,0,0,0.5)"></canvas>
      </div>
      
      <div style="text-align:center;color:#94a3b8;font-size:12px">
        √¢‚Ä†/√¢‚Ä†'/√¢‚Ä†"/√¢‚Ä†" or WASD to move ‚Ä¢ SPACE to hard drop
      </div>
      
      <button id="tetrisStart" class="btn" style="background:linear-gradient(135deg,#3b82f6,#1e40af);font-weight:bold;padding:12px">START GAME</button>
    </div>
  `);

  const canvas = win.querySelector("#tetrisCanvas");
  const ctx = canvas.getContext("2d");
  const nextCanvas = win.querySelector("#tetrisNext");
  const nextCtx = nextCanvas.getContext("2d");
  
  const scoreEl = win.querySelector("#tetrisScore");
  const levelEl = win.querySelector("#tetrisLevel");
  const bestEl = win.querySelector("#tetrisBest");
  const linesEl = win.querySelector("#tetrisLines");
  const startBtn = win.querySelector("#tetrisStart");

  const COLS = 10;
  const ROWS = 20;
  const BLOCK_SIZE = 24;
  
  let board = [];
  let score = 0;
  let level = 1;
  let lines = 0;
  let gameRunning = false;
  let gameLoop;
  let dropCounter = 0;
  let dropInterval = 1000;
  let lastTime = 0;

  const SHAPES = [
    [[1,1,1,1]], // I
    [[1,1],[1,1]], // O
    [[0,1,0],[1,1,1]], // T
    [[1,0,0],[1,1,1]], // L
    [[0,0,1],[1,1,1]], // J
    [[0,1,1],[1,1,0]], // S
    [[1,1,0],[0,1,1]]  // Z
  ];

  const COLORS = ['#00f0f0', '#f0f000', '#a000f0', '#f0a000', '#0000f0', '#00f000', '#f00000'];

  let currentPiece = null;
  let nextPiece = null;

  function createPiece() {
    const shapeIndex = Math.floor(Math.random() * SHAPES.length);
    return {
      shape: SHAPES[shapeIndex],
      color: COLORS[shapeIndex],
      x: Math.floor(COLS / 2) - 1,
      y: 0
    };
  }

  function drawBlock(ctx, x, y, color, size = BLOCK_SIZE) {
    ctx.fillStyle = color;
    ctx.fillRect(x * size, y * size, size, size);
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 2;
    ctx.strokeRect(x * size, y * size, size, size);
    
    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fillRect(x * size, y * size, size / 4, size / 4);
  }

  function drawBoard() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Grid
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= COLS; i++) {
      ctx.beginPath();
      ctx.moveTo(i * BLOCK_SIZE, 0);
      ctx.lineTo(i * BLOCK_SIZE, canvas.height);
      ctx.stroke();
    }
    for (let i = 0; i <= ROWS; i++) {
      ctx.beginPath();
      ctx.moveTo(0, i * BLOCK_SIZE);
      ctx.lineTo(canvas.width, i * BLOCK_SIZE);
      ctx.stroke();
    }
    
    // Board pieces
    board.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value) {
          drawBlock(ctx, x, y, value);
        }
      });
    });
    
    // Current piece
    if (currentPiece) {
      currentPiece.shape.forEach((row, dy) => {
        row.forEach((value, dx) => {
          if (value) {
            drawBlock(ctx, currentPiece.x + dx, currentPiece.y + dy, currentPiece.color);
          }
        });
      });
    }
  }

  function drawNext() {
  // Clear the canvas first
  nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
  nextCtx.fillStyle = 'rgba(0,0,0,0.5)';
  nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
  
  if (nextPiece) {
    const offsetX = (4 - nextPiece.shape[0].length) / 2;
    const offsetY = (4 - nextPiece.shape.length) / 2;
    
    nextPiece.shape.forEach((row, dy) => {
      row.forEach((value, dx) => {
        if (value) {
          drawBlock(nextCtx, offsetX + dx, offsetY + dy, nextPiece.color, 20);
        }
      });
    });
  }
}

  function collide() {
    for (let y = 0; y < currentPiece.shape.length; y++) {
      for (let x = 0; x < currentPiece.shape[y].length; x++) {
        if (currentPiece.shape[y][x]) {
          const newX = currentPiece.x + x;
          const newY = currentPiece.y + y;
          
          if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
          if (newY >= 0 && board[newY][newX]) return true;
        }
      }
    }
    return false;
  }

  function merge() {
    currentPiece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value) {
          const boardY = currentPiece.y + y;
          const boardX = currentPiece.x + x;
          if (boardY >= 0) {
            board[boardY][boardX] = currentPiece.color;
          }
        }
      });
    });
  }

  function rotate() {
    const rotated = currentPiece.shape[0].map((_, i) =>
      currentPiece.shape.map(row => row[i]).reverse()
    );
    
    const previousShape = currentPiece.shape;
    currentPiece.shape = rotated;
    
    if (collide()) {
      currentPiece.shape = previousShape;
    } else {
      playSFX('rotate');
    }
  }

  function clearLines() {
    let linesCleared = 0;
    
    for (let y = ROWS - 1; y >= 0; y--) {
      if (board[y].every(cell => cell !== 0)) {
        board.splice(y, 1);
        board.unshift(Array(COLS).fill(0));
        linesCleared++;
        y++;
      }
    }
    
    if (linesCleared > 0) {
      lines += linesCleared;
      linesEl.textContent = lines;
      
      const points = [0, 100, 300, 500, 800][linesCleared] * level;
      score += points;
      scoreEl.textContent = score;
      
      level = Math.floor(lines / 10) + 1;
      levelEl.textContent = level;
      dropInterval = Math.max(100, 1000 - (level - 1) * 100);
      
      if (score > parseInt(localStorage.getItem('tetrisBest') || 0)) {
        localStorage.setItem('tetrisBest', score);
        bestEl.textContent = score;
      }
      
      playSFX('clear');
    }
  }

  function drop() {
    currentPiece.y++;
    if (collide()) {
      currentPiece.y--;
      merge();
      clearLines();
      currentPiece = nextPiece;
      nextPiece = createPiece();
      drawNext();
      
      if (collide()) {
        gameOver();
      }
    }
    dropCounter = 0;
  }

  function hardDrop() {
    while (!collide()) {
      currentPiece.y++;
      score += 2;
    }
    currentPiece.y--;
    scoreEl.textContent = score;
    merge();
    clearLines();
    currentPiece = nextPiece;
    nextPiece = createPiece();
    drawNext();
    
    if (collide()) {
      gameOver();
    }
    playSFX('drop');
  }

  function move(dir) {
    currentPiece.x += dir;
    if (collide()) {
      currentPiece.x -= dir;
    }
  }

  function gameOver() {
    gameRunning = false;
    cancelAnimationFrame(gameLoop);
    playSFX('gameover');
    showNotification('Game Over', `Score: ${score} | Lines: ${lines}`, 'info', 4000);
    startBtn.textContent = 'RESTART';
  }

  function playSFX(type) {
    const actx = audioCtx;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.connect(g);
    g.connect(actx.destination);
    const now = actx.currentTime;
    
    if (type === 'rotate') {
      o.type = 'sine';
      o.frequency.setValueAtTime(400, now);
      g.gain.setValueAtTime(0.05, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
    } else if (type === 'clear') {
      o.type = 'square';
      o.frequency.setValueAtTime(600, now);
      o.frequency.setValueAtTime(800, now + 0.1);
      g.gain.setValueAtTime(0.1, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
    } else if (type === 'drop') {
      o.type = 'triangle';
      o.frequency.setValueAtTime(200, now);
      g.gain.setValueAtTime(0.08, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
    } else if (type === 'gameover') {
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(300, now);
      o.frequency.exponentialRampToValueAtTime(100, now + 0.5);
      g.gain.setValueAtTime(0.15, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
    }
    
    o.start(now);
    o.stop(now + 0.6);
  }

  function update(time = 0) {
    if (!gameRunning) return;
    
    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;
    
    if (dropCounter > dropInterval) {
      drop();
    }
    
    drawBoard();
    gameLoop = requestAnimationFrame(update);
  }

  function init() {
    board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    score = 0;
    level = 1;
    lines = 0;
    dropCounter = 0;
    dropInterval = 1000;
    
    scoreEl.textContent = 0;
    levelEl.textContent = 1;
    linesEl.textContent = 0;
    
    currentPiece = createPiece();
    nextPiece = createPiece();
    
    gameRunning = true;
    startBtn.textContent = 'RESTART';
    
    drawNext();
    lastTime = 0;
    gameLoop = requestAnimationFrame(update);
  }

  // Controls
  const keys = {};
  window.addEventListener('keydown', e => {
    if (!gameRunning) return;
    keys[e.key] = true;
    
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
      e.preventDefault();
      move(-1);
    } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
      e.preventDefault();
      move(1);
    } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
      e.preventDefault();
      drop();
    } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
      e.preventDefault();
      rotate();
    } else if (e.key === ' ') {
      e.preventDefault();
      hardDrop();
    }
    
    drawBoard();
  });

  window.addEventListener('keyup', e => {
    keys[e.key] = false;
  });

  startBtn.onclick = init;
  
  drawBoard();
}

function openPong(){
  const win = makeWin("Pong", 280, 160, `
    <div style="color:white;text-align:center;padding:15px;">
      <h2 style="margin-bottom:10px;font-size:16px;">Select Mode</h2>
      <button class="btn" id="pong1p" style="margin-bottom:8px;width:90%;font-size:12px;">1 Player (vs AI)</button>
      <button class="btn" id="pong2p" style="width:90%;font-size:12px;">2 Players</button>
    </div>
  `);

  win.querySelector("#pong1p").onclick = () => {
    startPong("1p");
    win.remove();
  };

  win.querySelector("#pong2p").onclick = () => {
    startPong("2p");
    win.remove();
  };
}

function startPong(mode){
  const win = makeWin("Pong - " + (mode === "1p" ? "Single Player" : "Multiplayer"), 720, 580, `
    <div style="display:flex;flex-direction:column;height:100%;background:radial-gradient(circle at center,#0a0f2a 0%,#000 100%);padding:20px;border-radius:15px;position:relative;overflow:hidden;">
      <!-- Animated background elements -->
      <div class="bg-particle" style="position:absolute;width:4px;height:4px;background:#fff;border-radius:50%;opacity:0.6;"></div>
      
      <!-- Score Display -->
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;z-index:2;position:relative;">
        <div style="text-align:center;background:linear-gradient(45deg,#667eea,#764ba2);padding:15px 25px;border-radius:15px;box-shadow:0 8px 25px rgba(102,126,234,0.4);border:2px solid rgba(255,255,255,0.2);">
          <div style="font-size:14px;color:#a5b4fc;margin-bottom:5px;">PLAYER 1</div>
          <div id="p1Score" style="font-size:36px;font-weight:bold;color:#fff;text-shadow:0 0 20px #667eea;">0</div>
        </div>
        
        <div style="text-align:center;background:rgba(255,255,255,0.1);padding:10px 20px;border-radius:12px;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1);">
          <div style="font-size:12px;color:#94a3b8;">BEST SCORE</div>
          <div id="pongBest" style="font-size:24px;font-weight:bold;color:#feca57;">${localStorage.getItem("pongBest") || 0}</div>
        </div>
        
        <div style="text-align:center;background:linear-gradient(45deg,#f5576c,#f093fb);padding:15px 25px;border-radius:15px;box-shadow:0 8px 25px rgba(245,87,108,0.4);border:2px solid rgba(255,255,255,0.2);">
          <div style="font-size:14px;color:#f8a5c2;margin-bottom:5px;">${mode === "1p" ? "AI" : "PLAYER 2"}</div>
          <div id="p2Score" style="font-size:36px;font-weight:bold;color:#fff;text-shadow:0 0 20px #f5576c;">0</div>
        </div>
      </div>

      <!-- Game Canvas -->
      <div style="flex:1;position:relative;border-radius:20px;overflow:hidden;box-shadow:0 0 50px rgba(59,130,246,0.3);border:3px solid rgba(59,130,246,0.3);">
        <canvas id="pongCanvas" width="680" height="400" style="display:block;background:radial-gradient(ellipse at center,#1a1f3a 0%,#0a0f2a 70%);"></canvas>
        
        <!-- Center Line -->
        <div style="position:absolute;left:50%;top:0;bottom:0;width:2px;background:linear-gradient(to bottom,transparent 0%,rgba(59,130,246,0.6) 50%,transparent 100%);transform:translateX(-50%);"></div>
        
        <!-- Center Circle -->
        <div style="position:absolute;left:50%;top:50%;width:100px;height:100px;border:2px solid rgba(59,130,246,0.4);border-radius:50%;transform:translate(-50%,-50%);"></div>
      </div>

      <!-- Controls Info -->
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-top:15px;z-index:2;position:relative;">
        <div style="background:rgba(59,130,246,0.1);padding:12px;border-radius:10px;border:1px solid rgba(59,130,246,0.3);">
          <div style="font-size:11px;color:#3b82f6;margin-bottom:4px;">PLAYER 1 CONTROLS</div>
          <div style="font-size:10px;color:#94a3b8;">W/S or ‚Üë/‚Üì Keys</div>
        </div>
        <div style="background:rgba(245,87,108,0.1);padding:12px;border-radius:10px;border:1px solid rgba(245,87,108,0.3);">
          <div style="font-size:11px;color:#f5576c;margin-bottom:4px;">${mode === "1p" ? "AI" : "PLAYER 2"} CONTROLS</div>
          <div style="font-size:10px;color:#94a3b8;">${mode === "1p" ? "Auto-play" : "W/S or ‚Üë/‚Üì Keys"}</div>
        </div>
      </div>
    </div>
  `);

  const canvas = win.querySelector("#pongCanvas");
  const ctx = canvas.getContext("2d");
  const p1ScoreEl = win.querySelector("#p1Score");
  const p2ScoreEl = win.querySelector("#p2Score");
  const bestEl = win.querySelector("#pongBest");

  // Enhanced game variables
  let p1Y = canvas.height / 2 - 50;
  let p2Y = canvas.height / 2 - 50;
  const paddleWidth = 16;
  const paddleHeight = 100;
  
  let ballX = canvas.width / 2;
  let ballY = canvas.height / 2;
  let ballDX = 5;
  let ballDY = 4;
  const ballSize = 12;
  
  let p1Score = 0;
  let p2Score = 0;
  let gameRunning = true;
  
  // Visual effects
  let particles = [];
  let trail = [];
  let glowIntensity = 0;
  let screenShake = 0;
  
  // Enhanced AI for single player
  let aiDifficulty = 0.08; // Lower = harder AI

  // Controls
  const keys = { 
    w: false, s: false, 
    ArrowUp: false, ArrowDown: false 
  };

  // Create background particles
  function createBackgroundParticles() {
    const particles = win.querySelectorAll('.bg-particle');
    particles.forEach(particle => {
      const size = Math.random() * 3 + 1;
      const x = Math.random() * 100;
      const y = Math.random() * 100;
      const duration = Math.random() * 20 + 10;
      
      particle.style.width = size + 'px';
      particle.style.height = size + 'px';
      particle.style.left = x + '%';
      particle.style.top = y + '%';
      particle.style.animation = `float ${duration}s infinite linear`;
      particle.style.opacity = Math.random() * 0.4 + 0.1;
    });
  }

  // Add CSS for animations
  const style = document.createElement('style');
  style.textContent = `
    @keyframes float {
      0% { transform: translateY(0px) rotate(0deg); }
      100% { transform: translateY(-100vh) rotate(360deg); }
    }
    @keyframes glow {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.8; }
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
  `;
  document.head.appendChild(style);

  createBackgroundParticles();

  // Enhanced paddle movement with smooth acceleration
  function updatePaddles() {
    // Player 1 movement
    if (keys.w) p1Y = Math.max(20, p1Y - 8);
    if (keys.s) p1Y = Math.min(canvas.height - paddleHeight - 20, p1Y + 8);
    
    // Player 2 movement (AI or player)
    if (mode === "2p") {
      if (keys.ArrowUp) p2Y = Math.max(20, p2Y - 8);
      if (keys.ArrowDown) p2Y = Math.min(canvas.height - paddleHeight - 20, p2Y + 8);
    } else {
      // Enhanced AI with prediction and imperfection
      const targetY = ballY - paddleHeight / 2;
      const diff = targetY - p2Y;
      p2Y += diff * aiDifficulty + (Math.random() - 0.5) * 2; // Add some randomness
      p2Y = Math.max(20, Math.min(canvas.height - paddleHeight - 20, p2Y));
    }
  }

  function createParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
      particles.push({
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 10,
        vy: (Math.random() - 0.5) * 10,
        life: 1,
        size: Math.random() * 4 + 2,
        color: color
      });
    }
  }

  function updateParticles() {
    particles = particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.1;
      p.life -= 0.02;
      return p.life > 0;
    });
  }

  function drawParticles() {
    particles.forEach(p => {
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
  }

  function drawTrail() {
    for (let i = 0; i < trail.length; i++) {
      const point = trail[i];
      const alpha = i / trail.length * 0.3;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = `hsl(${200 + i * 2}, 100%, 60%)`;
      ctx.beginPath();
      ctx.arc(point.x, point.y, ballSize * (i / trail.length), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawPaddle(x, y, color, isPlayer1) {
    // Shadow
    ctx.shadowColor = color;
    ctx.shadowBlur = 20;
    
    // Main paddle with gradient
    const gradient = ctx.createLinearGradient(x, y, x + paddleWidth, y + paddleHeight);
    gradient.addColorStop(0, color);
    gradient.addColorStop(1, 'rgba(255,255,255,0.8)');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(x, y, paddleWidth, paddleHeight);
    
    // Inner glow
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(x + 2, y + 2, paddleWidth - 4, paddleHeight - 4);
    
    // Energy lines
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 3; i++) {
      const lineY = y + 10 + i * 30;
      ctx.beginPath();
      ctx.moveTo(x + 4, lineY);
      ctx.lineTo(x + paddleWidth - 4, lineY);
      ctx.stroke();
    }
    
    ctx.shadowBlur = 0;
  }

  function drawBall() {
    // Ball trail
    trail.unshift({x: ballX, y: ballY});
    if (trail.length > 10) trail.pop();
    drawTrail();
    
    // Main ball with glow
    ctx.shadowColor = '#3b82f6';
    ctx.shadowBlur = glowIntensity;
    
    // Outer glow
    const gradient = ctx.createRadialGradient(ballX, ballY, 0, ballX, ballY, ballSize * 2);
    gradient.addColorStop(0, 'rgba(59,130,246,0.8)');
    gradient.addColorStop(1, 'rgba(59,130,246,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(ballX, ballY, ballSize * 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Main ball
    const ballGradient = ctx.createRadialGradient(
      ballX - ballSize/3, ballY - ballSize/3, 0,
      ballX, ballY, ballSize
    );
    ballGradient.addColorStop(0, '#fff');
    ballGradient.addColorStop(0.5, '#3b82f6');
    ballGradient.addColorStop(1, '#1e40af');
    
    ctx.fillStyle = ballGradient;
    ctx.beginPath();
    ctx.arc(ballX, ballY, ballSize, 0, Math.PI * 2);
    ctx.fill();
    
    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.arc(ballX - ballSize/3, ballY - ballSize/3, ballSize/3, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
  }

  function updateBall() {
    ballX += ballDX;
    ballY += ballDY;
    
    // Ball trail effect
    glowIntensity = Math.min(50, glowIntensity + 1);
    
    // Wall collision with enhanced physics
    if (ballY < ballSize || ballY > canvas.height - ballSize) {
      ballDY *= -1;
      createParticles(ballX, ballY, '#3b82f6', 8);
      playPongSFX('wall');
      screenShake = 5;
    }
    
    // Paddle collision with enhanced physics
    const hitP1 = ballX - ballSize < 30 + paddleWidth && 
                  ballY > p1Y && ballY < p1Y + paddleHeight;
                  
    const hitP2 = ballX + ballSize > canvas.width - 30 - paddleWidth && 
                  ballY > p2Y && ballY < p2Y + paddleHeight;
    
    if (hitP1 || hitP2) {
      // Enhanced ball physics based on hit position
      const paddle = hitP1 ? p1Y : p2Y;
      const hitPos = (ballY - paddle) / paddleHeight;
      const angle = (hitPos - 0.5) * Math.PI / 2; // -45 to 45 degrees
      
      const speed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
      ballDX = hitP1 ? Math.cos(angle) * speed : -Math.cos(angle) * speed;
      ballDY = Math.sin(angle) * speed;
      
      // Speed up slightly
      ballDX *= 1.05;
      ballDY *= 1.05;
      
      // Visual effects
      createParticles(ballX, ballY, hitP1 ? '#667eea' : '#f5576c', 15);
      glowIntensity = 80;
      screenShake = 8;
      playPongSFX('paddle');
    }
    
    // Scoring
    if (ballX < 0) {
      p2Score++;
      p2ScoreEl.textContent = p2Score;
      resetBall();
      playPongSFX('score');
      createParticles(canvas.width/2, canvas.height/2, '#f5576c', 30);
    } else if (ballX > canvas.width) {
      p1Score++;
      p1ScoreEl.textContent = p1Score;
      resetBall();
      playPongSFX('score');
      createParticles(canvas.width/2, canvas.height/2, '#667eea', 30);
    }
  }

  function resetBall() {
    ballX = canvas.width / 2;
    ballY = canvas.height / 2;
    ballDX = (Math.random() > 0.5 ? 5 : -5);
    ballDY = (Math.random() - 0.5) * 8;
    trail = [];
    glowIntensity = 0;
    
    // Update best score
    const currentBest = parseInt(localStorage.getItem("pongBest") || 0);
    const maxScore = Math.max(p1Score, p2Score);
    if (maxScore > currentBest) {
      localStorage.setItem("pongBest", maxScore.toString());
      bestEl.textContent = maxScore;
    }
  }

  function draw() {
    // Clear with screen shake
    ctx.save();
    if (screenShake > 0) {
      ctx.translate((Math.random() - 0.5) * screenShake, (Math.random() - 0.5) * screenShake);
      screenShake *= 0.8;
      if (screenShake < 0.1) screenShake = 0;
    }
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw background elements
    drawBackground();
    
    // Draw game elements
    drawPaddle(30, p1Y, '#667eea', true);
    drawPaddle(canvas.width - 30 - paddleWidth, p2Y, '#f5576c', false);
    drawBall();
    drawParticles();
    
    ctx.restore();
  }

  function drawBackground() {
    // Grid pattern
    ctx.strokeStyle = 'rgba(59,130,246,0.1)';
    ctx.lineWidth = 1;
    
    for (let x = 0; x < canvas.width; x += 40) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    
    for (let y = 0; y < canvas.height; y += 40) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }
    
    // Pulsing center dot
    const pulse = Math.sin(Date.now() * 0.005) * 3 + 5;
    ctx.fillStyle = 'rgba(59,130,246,0.3)';
    ctx.beginPath();
    ctx.arc(canvas.width/2, canvas.height/2, pulse, 0, Math.PI * 2);
    ctx.fill();
  }

  function playPongSFX(type) {
    const actx = audioCtx;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.connect(g);
    g.connect(actx.destination);
    const now = actx.currentTime;
    
    if (type === 'paddle') {
      o.type = 'sine';
      o.frequency.setValueAtTime(400, now);
      o.frequency.setValueAtTime(600, now + 0.1);
      g.gain.setValueAtTime(0.1, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
    } else if (type === 'wall') {
      o.type = 'triangle';
      o.frequency.setValueAtTime(300, now);
      o.frequency.setValueAtTime(200, now + 0.1);
      g.gain.setValueAtTime(0.08, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
    } else if (type === 'score') {
      o.type = 'square';
      o.frequency.setValueAtTime(200, now);
      o.frequency.setValueAtTime(300, now + 0.1);
      o.frequency.setValueAtTime(400, now + 0.2);
      g.gain.setValueAtTime(0.15, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
    }
    
    o.start(now);
    o.stop(now + 0.5);
  }

  function gameLoop() {
    if (!gameRunning) return;
    
    updatePaddles();
    updateBall();
    updateParticles();
    draw();
    
    requestAnimationFrame(gameLoop);
  }

  // Controls
  window.addEventListener("keydown", e => {
    if (['w', 's', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
      keys[e.key] = true;
      e.preventDefault();
    }
  });
  
  window.addEventListener("keyup", e => {
    if (['w', 's', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
      keys[e.key] = false;
      e.preventDefault();
    }
  });

  // Start the game
  gameLoop();

  // Clean up when window closes
  const originalClose = win.querySelector('[data-act="close"]').onclick;
  win.querySelector('[data-act="close"]').onclick = () => {
    gameRunning = false;
    document.head.removeChild(style);
    originalClose();
  };
}

function openMusicPlayer(fileKey) {
  const fsObj = getFS();
  
  // If specific file requested, play it directly
  if(fileKey && fsObj[fileKey] && fsObj[fileKey].type === 'file' && fsObj[fileKey].mime && fsObj[fileKey].mime.startsWith('audio/')) {
    const audioWin = makeWin('Music Player', 480, 200, `
      <div style="display:flex;flex-direction:column;height:100%;align-items:center;gap:8px;padding:8px">
        <div id="mpTitle" class="small" style="font-weight:600">${fileKey.split('/').pop()}</div>
        <audio id="mpAudio" controls style="width:100%">
          Your browser does not support the audio element.
        </audio>
        <div style="display:flex;gap:8px">
          <button class="btn" id="mpStop">Stop</button>
          <button class="btn" id="mpLibrary" style="background:rgba(255,255,255,0.1)">Library</button>
        </div>
        <div id="mpStatus" class="small" style="color:var(--muted)"></div>
      </div>
    `);
    
    const audioEl = audioWin.querySelector('#mpAudio');
    const statusEl = audioWin.querySelector('#mpStatus');
    
    // Use the data URL directly
    audioEl.src = fsObj[fileKey].data;
    
    audioEl.onerror = () => {
      statusEl.textContent = 'Error: Could not play audio file';
      statusEl.style.color = '#ef4444';
    };
    
    audioEl.oncanplay = () => {
      statusEl.textContent = 'Ready to play';
      statusEl.style.color = '#10b981';
    };
    
    audioEl.play().catch(e => {
      statusEl.textContent = 'Click play to start audio';
      statusEl.style.color = '#f59e0b';
    });
    
    audioWin.querySelector('#mpStop').onclick = () => { 
      audioEl.pause(); 
      audioEl.currentTime = 0; 
      statusEl.textContent = 'Stopped';
    };
    
    audioWin.querySelector('#mpLibrary').onclick = () => {
      openMusicPlayer(); // Open library
      ctrl('close', audioWin);
    };
    
    return;
  }
  
  // Show music library
  const win = makeWin('Music Library', 520, 380, `
    <div style="padding:10px;display:flex;flex-direction:column;height:100%">
      <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center">
        <div style="flex:1;font-weight:600">Music Library</div>
        <input type="file" id="musicImporter" accept="audio/*" multiple style="display:none" />
        <button class="btn" id="btnImportMusic">üìÅ Import Music</button>
      </div>
      <div id="musicList" style="flex:1;overflow:auto"></div>
    </div>
  `);
  
  const list = win.querySelector('#musicList');
  const importer = win.querySelector('#musicImporter');
  
  win.querySelector('#btnImportMusic').onclick = () => importer.click();
  
  importer.onchange = async (e) => {
    const files = Array.from(e.target.files || []);
    if(files.length === 0) return;
    
    const fsObj = getFS();
    let importedCount = 0;
    
    for(const file of files) {
      const reader = new FileReader();
      await new Promise(res => {
        reader.onload = () => {
          // Create proper file path
          const fileName = file.name;
          const filePath = '/Music/' + fileName;
          
          // Check if file already exists
          if(fsObj[filePath]) {
            console.log('File already exists:', fileName);
            res();
            return;
          }
          
          // Store file with proper structure
          fsObj[filePath] = { 
            type: 'file', 
            mime: file.type || 'audio/mpeg', 
            data: reader.result
          };
          
          // Ensure Music directory exists with correct structure
          if(!fsObj['/Music']) {
            fsObj['/Music'] = { type: 'dir', children: [] };
          }
          
          // Add to Music folder's children if not already there
          if(!fsObj['/Music'].children.includes(fileName)) {
            fsObj['/Music'].children.push(fileName);
          }
          
          importedCount++;
          res();
        };
        
        reader.onerror = () => {
          console.error('Error reading file:', file.name);
          res();
        };
        
        // Read as data URL
        reader.readAsDataURL(file);
      });
    }
    
    setFS(fsObj);
    
    if(importedCount > 0) {
      showNotification('Music Imported', `${importedCount} songs added to library`, 'success', 3500);
      renderMusicList();
    } else {
      showNotification('Import Failed', 'No new files were imported', 'error', 3000);
    }
    
    importer.value = '';
  };
  
  function renderMusicList() {
    const fsObj = getFS();
    const musicFiles = [];
    
    // Find all audio files by checking directories
    function scanDirectory(path) {
      const dir = fsObj[path];
      if(dir && dir.type === 'dir' && dir.children) {
        dir.children.forEach(childName => {
          const childPath = path === '/' ? '/' + childName : path + '/' + childName;
          const childEntry = fsObj[childPath];
          
          if(childEntry && childEntry.type === 'file' && childEntry.mime && childEntry.mime.startsWith('audio/')) {
            musicFiles.push(childPath);
          } else if(childEntry && childEntry.type === 'dir') {
            scanDirectory(childPath);
          }
        });
      }
    }
    
    // Start scanning from root
    scanDirectory('/');
    
    if(musicFiles.length === 0) {
      list.innerHTML = '<div class="small" style="padding:20px;text-align:center">No music files found. Click "Import Music" to add songs.</div>';
      return;
    }
    
    list.innerHTML = '';
    musicFiles.forEach(filePath => {
      const entry = fsObj[filePath];
      const fileName = filePath.split('/').pop();
      
      const item = document.createElement('div');
      item.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:12px;border-radius:6px;background:rgba(255,255,255,0.02);margin-bottom:6px';
      item.innerHTML = `
        <div style="display:flex;align-items:center;gap:10px">
          <div style="font-size:24px">üéµ</div>
          <div style="flex:1">
            <div style="font-weight:600">${fileName}</div>
            <div class="small">${entry.mime} ‚Ä¢ ${Math.ceil((entry.data.length || 0) / 1024)} KB</div>
          </div>
        </div>
        <div style="display:flex;gap:6px">
          <button class="btn playM" data-k="${filePath}">Play</button>
          <button class="btn" style="background:#ef4444" data-del="${filePath}">Delete</button>
        </div>
      `;
      
      list.appendChild(item);
    });
    
    list.querySelectorAll('.playM').forEach(b => {
      b.onclick = () => openMusicPlayer(b.dataset.k);
    });
    
    list.querySelectorAll('[data-del]').forEach(b => {
      b.onclick = () => {
        if(!confirm('Delete this song?')) return;
        const filePath = b.dataset.del;
        const fileName = filePath.split('/').pop();
        const parentPath = filePath.split('/').slice(0, -1).join('/') || '/';
        
        const fs2 = getFS();
        
        // Remove from parent directory
        if(fs2[parentPath] && Array.isArray(fs2[parentPath].children)) {
          const idx = fs2[parentPath].children.indexOf(fileName);
          if(idx >= 0) fs2[parentPath].children.splice(idx, 1);
        }
        
        // Delete the file
        delete fs2[filePath];
        
        setFS(fs2);
        showNotification('Deleted', fileName, 'warning', 2500);
        renderMusicList();
      };
    });
  }
  
  renderMusicList();
}

function openVideoPlayer(fileKey) {
  const fsObj = getFS();
  
  // If specific file requested, play it directly
  if(fileKey && fsObj[fileKey] && fsObj[fileKey].type === 'file' && fsObj[fileKey].mime && fsObj[fileKey].mime.startsWith('video/')) {
    const vwin = makeWin('Video Player', 720, 420, `
      <div style="display:flex;flex-direction:column;height:100%">
        <div style="padding:8px;background:rgba(0,0,0,0.3);border-radius:6px 6px 0 0">
          <div class="small" style="text-align:center">${fileKey.split('/').pop()}</div>
        </div>
        <video id="vid" controls style="width:100%;height:100%;background:#000"></video>
      </div>
    `);
    const vid = vwin.querySelector('#vid');
    vid.src = fsObj[fileKey].data;
    vid.play().catch(() => {});
    return;
  }
  
  // Show video library
  const win = makeWin('Video Library', 520, 380, `
    <div style="padding:10px;display:flex;flex-direction:column;height:100%">
      <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center">
        <div style="flex:1;font-weight:600">Video Library</div>
        <input type="file" id="videoImporter" accept="video/*" multiple style="display:none" />
        <button class="btn" id="btnImportVideo">üìÅ Import Videos</button>
      </div>
      <div id="videoList" style="flex:1;overflow:auto"></div>
    </div>
  `);
  
  const list = win.querySelector('#videoList');
  const importer = win.querySelector('#videoImporter');
  
  win.querySelector('#btnImportVideo').onclick = () => importer.click();
  
  importer.onchange = async (e) => {
    const files = Array.from(e.target.files || []);
    if(files.length === 0) return;
    
    const fsObj = getFS();
    let importedCount = 0;
    
    for(const file of files) {
      const reader = new FileReader();
      await new Promise(res => {
        reader.onload = () => {
          const fileName = file.name;
          const filePath = '/Videos/' + fileName;
          
          // Check if file already exists
          if(fsObj[filePath]) {
            console.log('File already exists:', fileName);
            res();
            return;
          }
          
          // Store file
          fsObj[filePath] = { 
            type: 'file', 
            mime: file.type || 'video/mp4', 
            data: reader.result 
          };
          
          // Ensure Videos directory exists
          if(!fsObj['/Videos']) {
            fsObj['/Videos'] = { type: 'dir', children: [] };
          }
          
          // Add to Videos folder's children
          if(!fsObj['/Videos'].children.includes(fileName)) {
            fsObj['/Videos'].children.push(fileName);
          }
          
          importedCount++;
          res();
        };
        reader.readAsDataURL(file);
      });
    }
    
    setFS(fsObj);
    
    if(importedCount > 0) {
      showNotification('Videos Imported', `${importedCount} videos added to library`, 'success', 3500);
      renderVideoList();
    } else {
      showNotification('Import Failed', 'No new files were imported', 'error', 3000);
    }
    
    importer.value = '';
  };
  
  function renderVideoList() {
    const fsObj = getFS();
    const videoFiles = [];
    
    // Find all video files by checking directories
    function scanDirectory(path) {
      const dir = fsObj[path];
      if(dir && dir.type === 'dir' && dir.children) {
        dir.children.forEach(childName => {
          const childPath = path === '/' ? '/' + childName : path + '/' + childName;
          const childEntry = fsObj[childPath];
          
          if(childEntry && childEntry.type === 'file' && childEntry.mime && childEntry.mime.startsWith('video/')) {
            videoFiles.push(childPath);
          } else if(childEntry && childEntry.type === 'dir') {
            scanDirectory(childPath);
          }
        });
      }
    }
    
    // Start scanning from root
    scanDirectory('/');
    
    if(videoFiles.length === 0) {
      list.innerHTML = '<div class="small" style="padding:20px;text-align:center">No videos found. Click "Import Videos" to add videos.</div>';
      return;
    }
    
    list.innerHTML = '';
    videoFiles.forEach(filePath => {
      const entry = fsObj[filePath];
      const fileName = filePath.split('/').pop();
      
      const item = document.createElement('div');
      item.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:12px;border-radius:6px;background:rgba(255,255,255,0.02);margin-bottom:6px';
      item.innerHTML = `
        <div style="display:flex;align-items:center;gap:10px">
          <div style="font-size:24px">üé¨</div>
          <div>
            <div style="font-weight:600">${fileName}</div>
            <div class="small">${entry.mime} ‚Ä¢ ${Math.ceil(entry.data.length / 1024)} KB</div>
          </div>
        </div>
        <div style="display:flex;gap:6px">
          <button class="btn playV" data-k="${filePath}">Play</button>
          <button class="btn" style="background:#ef4444" data-del="${filePath}">Delete</button>
        </div>
      `;
      
      list.appendChild(item);
    });
    
    list.querySelectorAll('.playV').forEach(b => {
      b.onclick = () => openVideoPlayer(b.dataset.k);
    });
    
    list.querySelectorAll('[data-del]').forEach(b => {
      b.onclick = () => {
        if(!confirm('Delete this video?')) return;
        const filePath = b.dataset.del;
        const fileName = filePath.split('/').pop();
        const parentPath = filePath.split('/').slice(0, -1).join('/') || '/';
        
        const fs2 = getFS();
        
        // Remove from parent directory
        if(fs2[parentPath] && Array.isArray(fs2[parentPath].children)) {
          const idx = fs2[parentPath].children.indexOf(fileName);
          if(idx >= 0) fs2[parentPath].children.splice(idx, 1);
        }
        
        // Delete the file
        delete fs2[filePath];
        
        setFS(fs2);
        showNotification('Deleted', fileName, 'warning', 2500);
        renderVideoList();
      };
    });
  }
  
  renderVideoList();
}


// ---------------- Screenshot App (capture + editor) ----------------

// ---------------- Screenshot App (capture + editor) ----------------

function openScreenshotTool() {

    startRegionCapture();

    function startRegionCapture() {

        const overlay = document.createElement("div");
        overlay.style.position = "fixed";
        overlay.style.left = "0";
        overlay.style.top = "0";
        overlay.style.width = "100vw";
        overlay.style.height = "100vh";
        overlay.style.cursor = "crosshair";
        overlay.style.background = "rgba(0,0,0,0.1)";
        overlay.style.zIndex = "999999999";
        document.body.appendChild(overlay);

        let startX = 0, startY = 0, endX = 0, endY = 0;
        let dragging = false;

        const box = document.createElement("div");
        box.style.position = "fixed";
        box.style.border = "2px solid #3b82f6";
        box.style.background = "rgba(59,130,246,0.2)";
        box.style.zIndex = "9999999999";
        box.style.display = "none";
        document.body.appendChild(box);

        overlay.addEventListener("mousedown", e => {
            dragging = true;
            startX = e.clientX;
            startY = e.clientY;
            box.style.display = "block";
        });

        overlay.addEventListener("mousemove", e => {
            if (!dragging) return;

            endX = e.clientX;
            endY = e.clientY;

            const x = Math.min(startX, endX);
            const y = Math.min(startY, endY);
            const w = Math.abs(startX - endX);
            const h = Math.abs(startY - endY);

            box.style.left = x + "px";
            box.style.top = y + "px";
            box.style.width = w + "px";
            box.style.height = h + "px";
        });

        overlay.addEventListener("mouseup", async () => {
            dragging = false;
            box.style.display = "none";

            const x = parseInt(box.style.left);
            const y = parseInt(box.style.top);
            const w = parseInt(box.style.width);
            const h = parseInt(box.style.height);

            // Remove overlays BEFORE capture
            overlay.remove();
            box.remove();
            document.body.classList.add("screenshot-clean");

            // Disable blur to avoid screenshot glitches
            document.body.classList.add("screenshot-clean");

            // Wait one frame so browser repaints cleanly
            await new Promise(r => requestAnimationFrame(r));
            await new Promise(r => requestAnimationFrame(r));

            // Capture ONLY the selected region
            const capture = await html2canvas(document.body, {
                x: x,
                y: y,
                width: w,
                height: h,
                scrollX: 0,
                scrollY: 0,
                backgroundColor: null,
                useCORS: true,
                scale: 1
            });

            // Restore blur
            document.body.classList.remove("screenshot-clean");

            openScreenshotEditor(capture);

        });
    }
}

function openScreenshotEditor(imageCanvas) {
    const win = makeWin("Screenshot Editor", 1000, 600, `
        <div style="display:flex;height:100%;padding:10px;gap:10px;">
            <div style="display:flex;flex-direction:column;gap:10px;width:150px;">
                <button id="toolBrush" class="btn">üñåÔ∏è Brush</button>
                <button id="toolText" class="btn">üî§ Text</button>
                <input id="textSize" type="number" value="32" min="10" style="padding:5px;border-radius:5px;">
                <button id="saveImg" class="btn" style="background:#22c55e;">üíæ Save</button>
            </div>
            <div style="flex:1;background:#111;border-radius:10px;overflow:auto;">
                <canvas id="editCanvas"></canvas>
            </div>
        </div>
    `);

    const canvas = win.querySelector("#editCanvas");
    const ctx = canvas.getContext("2d");

    canvas.width = imageCanvas.width;
    canvas.height = imageCanvas.height;

    ctx.drawImage(imageCanvas, 0, 0);

    let tool = "brush";
    let drawing = false;

    win.querySelector("#toolBrush").onclick = () => tool = "brush";
    win.querySelector("#toolText").onclick = () => tool = "text";

    canvas.onmousedown = (e) => {
        if (tool === "brush") {
            drawing = true;
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.strokeStyle = "#ffffff";
            ctx.beginPath();
            ctx.moveTo(e.offsetX, e.offsetY);

        } else if (tool === "text") {
            const size = parseInt(win.querySelector("#textSize").value);
            ctx.font = size + "px Arial";
            ctx.fillStyle = "white";
            const t = prompt("Enter text:");
            if (t) ctx.fillText(t, e.offsetX, e.offsetY);
        }
    };

    canvas.onmousemove = (e) => {
        if (tool === "brush" && drawing) {
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
        }
    };

    canvas.onmouseup = () => drawing = false;

    // Save button
    win.querySelector("#saveImg").onclick = () => {
        const dataURL = canvas.toDataURL("image/png");
        const fileName = "Screenshot_" + Date.now() + ".png";

        const fs = getFS();

        if (!fs['/Pictures']) {
            fs['/Pictures'] = { type: 'dir', children: [] };
            fs['/'].children.push('Pictures');
        }

        if (!fs['/Pictures/Screenshots']) {
            fs['/Pictures/Screenshots'] = { type: 'dir', children: [] };
            fs['/Pictures'].children.push('Screenshots');
        }

        const path = "/Pictures/Screenshots/" + fileName;
        fs[path] = { type: 'file', mime: 'image/png', data: dataURL };

        fs['/Pictures/Screenshots'].children.push(fileName);

        setFS(fs);

        showNotification("Screenshot Saved", fileName, "success", 3000);
        ctrl("close", win);
    };
}




// Search
$('startSearch').onkeydown=e=>{
  if(e.key==='Enter'){
    const q=e.target.value.toLowerCase();
    const apps=['explorer','editor','terminal','paint','snake','calculator','settings','about','browser'];
    const found=apps.find(a=>a.includes(q));
    if(found){
      openApp(found);
    }
    startMenu.classList.remove('open');
    e.target.value='';
    sfx('click');
  }
};
}


</script>
<script type="module">

import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";

import {
  getFirestore, doc, setDoc, getDoc, collection, addDoc, deleteDoc,
  query, orderBy, onSnapshot, runTransaction, where, getDocs, updateDoc,
  arrayUnion
} from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

import {
  getAuth, signInAnonymously, onAuthStateChanged
} from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";

// ------------------------------------------------------
// STYLES (inject)
const style = document.createElement('style');
style.textContent = `
/* --- chat styles (kept same as you provided, slightly tuned) --- */
.chat-wrap { display:flex; height:100%; width:100%; gap:12px; padding:12px; box-sizing:border-box; }
.friends-col { width:240px; display:flex; flex-direction:column; gap:8px; background:rgba(255,255,255,0.04); padding:12px; border-radius:12px; overflow:auto; }
.friend-item { display:flex; gap:10px; align-items:center; padding:10px; border-radius:10px; cursor:pointer; transition:all .12s; color: #fff; }
.friend-item:hover { transform: translateY(-2px); background: rgba(255,255,255,0.03); }
.friend-item.active { background: linear-gradient(135deg,#667eea,#764ba2); box-shadow:0 6px 18px rgba(0,0,0,0.25); }
.friend-name { font-weight:700; font-size:14px; color:inherit; }
.friend-sub { font-size:12px; opacity:0.8; color:inherit; }
.chat-col { flex:1; display:flex; flex-direction:column; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; overflow:hidden; }
.chat-header { padding:14px; display:flex; justify-content:space-between; align-items:center; gap:12px; backdrop-filter:blur(6px); border-bottom:1px solid rgba(255,255,255,0.03); }
.chat-title { font-weight:800; color:#fff; }
.messages-area { flex:1; padding:16px; display:flex; flex-direction:column; gap:10px; overflow:auto; background:linear-gradient(180deg, rgba(0,0,0,0), rgba(255,255,255,0.01)); }
.input-area { display:flex; gap:8px; padding:12px; border-top:1px solid rgba(255,255,255,0.03); align-items:center; }
.modern-input { padding:10px 12px; border-radius:10px; border:none; outline:none; flex:1; }
.send-btn, .record-btn { width:44px; height:44px; border-radius:50%; border:none; cursor:pointer; }
.message-wrapper { max-width:70%; display:flex; align-items:flex-end; gap:8px; position:relative; }
.message-wrapper.sent { margin-left:auto; }
.message-bubble { padding:10px 14px; border-radius:14px; font-size:14px; }
.message-bubble.sent { background:linear-gradient(135deg,#667eea,#764ba2); color:#fff; }
.message-bubble.received { background:rgba(255,255,255,0.95); color:#222; }
.voice-player { min-width: 200px; max-width: 420px; padding:10px; border-radius:14px; display:flex; gap:8px; align-items:center; }
.context-menu { position:fixed; background:#111; color:#fff; padding:6px; border-radius:6px; z-index:99999; box-shadow:0 6px 20px rgba(0,0,0,0.5); }
.context-menu button { display:block; width:100%; text-align:left; padding:6px 8px; border:none; background:transparent; color:inherit; cursor:pointer; }
.empty-state { text-align:center; opacity:0.8; padding:40px; }
.typing-indicator { font-size:13px; color:rgba(255,255,255,0.8); margin-bottom:6px; }

/* delete icon on hover */
.msg-del { opacity: 0; cursor:pointer; transition: opacity .15s ease; margin-left:6px; user-select:none; }
.message-wrapper:hover .msg-del { opacity: 1; }

/* friend item small adjustments */
.friend-item .friend-sub { font-size:12px; opacity:0.7; }

/* compact media queries */
@media (max-width:700px) {
  .friends-col { display:none; }
  .chat-col { border-radius:0; padding:0; }
}
`;
document.head.appendChild(style);

// ------------------------------------------------------
// GLOBALS
let myUid = null;
let db;
const firebaseConfig = {
  apiKey: "AIzaSyBgZJthL9SsgS3kxw-nr8d5Pqrufru3-1A",
  authDomain: "webos-chat.firebaseapp.com",
  projectId: "webos-chat",
  storageBucket: "webos-chat.firebasestorage.app",
  messagingSenderId: "864010564614",
  appId: "1:864010564614:web:6bc59f10b8f61a5222ff87"
};

const appFirebase = initializeApp(firebaseConfig);
const auth = getAuth(appFirebase);

// ---------------- Auth + helpers ----------------
async function login() {
  return new Promise((res) => {
    onAuthStateChanged(auth, async (user) => {
      if (user) return res(user);
      const u = await signInAnonymously(auth);
      res(u.user);
    });
  });
}

async function pickUsername(myUid) {
  const myRef = doc(db, "users", myUid);
  const snap = await getDoc(myRef);
  if (snap.exists() && snap.data().username) return snap.data().username;

  let username = null;
  while (!username) {
    let chosen = prompt("Choose a username:");
    if (!chosen) continue;
    chosen = chosen.trim().toLowerCase();
    const nameRef = doc(db, "usernames", chosen);
    try {
      await runTransaction(db, async (tx) => {
        const exists = await tx.get(nameRef);
        if (exists.exists()) throw "taken";
        tx.set(nameRef, { uid: myUid });
        tx.set(myRef, { username: chosen, friends: [] }, { merge: true });
      });
      username = chosen;
      alert("Username created: " + chosen);
    } catch (e) {
      alert("Username is taken. Try another.");
    }
  }
  return username;
}

async function addFriendByName(myUid, friendName) {
  const q = query(collection(db, "users"), where("username", "==", friendName));
  const snap = await getDocs(q);
  if (snap.empty) return { ok:false, reason:"User not found" };
  const user = snap.docs[0];
  const friendUid = user.id;
  if (friendUid === myUid) return { ok:false, reason:"You can't add yourself" };
  const ref1 = doc(db, "friends", `${myUid}_${friendUid}`);
  const ref2 = doc(db, "friends", `${friendUid}_${myUid}`);
  const snap1 = await getDoc(ref1);
  const snap2 = await getDoc(ref2);
  if (snap1.exists() || snap2.exists()) {
    return { ok:false, reason:"Already friends or pending request" };
  }
  await setDoc(ref1, {
    from: myUid,
    to: friendUid,
    status: "pending",
    ts: Date.now()
  });
  return { ok:true };
}

// ----------------- MEDIUM modern voice player (version C) -----------------
function createVoicePlayer(audioSrc, isSent) {
  // inject CSS once
  if (!document.getElementById('vp-medium-css')) {
    const css = document.createElement('style');
    css.id = 'vp-medium-css';
    css.textContent = `
      .vp-med { display:flex; gap:10px; align-items:center; padding:8px 10px; border-radius:12px; box-shadow: 0 8px 20px rgba(0,0,0,0.12); max-width:460px; }
      .vp-med.sent { background: linear-gradient(135deg,#6ea0ff, #8367e6); color:#fff; }
      .vp-med.received { background: rgba(255,255,255,0.95); color:#222; }

      .vp-btn { width:48px; height:48px; border-radius:50%; border:none; display:flex; align-items:center; justify-content:center; font-size:18px; cursor:pointer; box-shadow: 0 6px 14px rgba(0,0,0,0.12); }
      .vp-btn.playing { transform: scale(1.02); }
      .vp-btn.gradient { background: linear-gradient(135deg,#667eea 0%, #764ba2 100%); color:#fff; }

      .vp-body { flex:1; min-width:0; display:flex; flex-direction:column; gap:6px; }
      .vp-row { display:flex; align-items:center; gap:8px; }
      .vp-progress-wrap { position:relative; height:6px; background: rgba(255,255,255,0.12); border-radius:999px; cursor:pointer; overflow:hidden; flex:1; }
      .vp-progress { height:100%; width:0%; background: linear-gradient(90deg,#fff,#dfe8ff); border-radius:999px; transition: width 0.08s linear; }

      .vp-time { font-size:12px; opacity:0.9; min-width:60px; text-align:right; }
      .vp-wave { display:flex; gap:4px; align-items:flex-end; height:22px; width:110px; }
      .vp-wave .bar { width:4px; background: rgba(255,255,255,0.22); border-radius:2px; transition: height 0.12s ease; }
      .vp-wave.playing .bar { background: linear-gradient(135deg,#fff,#dfe8ff); }
      .vp-med.received .vp-wave .bar { background: rgba(0,0,0,0.08); }
    `;
    document.head.appendChild(css);
  }

  const container = document.createElement('div');
  container.className = 'vp-med ' + (isSent ? 'sent' : 'received');

  const audio = document.createElement('audio');
  audio.src = audioSrc;
  audio.preload = 'metadata';
  audio.style.display = 'none';

  const btn = document.createElement('button');
  btn.className = 'vp-btn gradient';
  btn.textContent = '‚ñ∂';

  const body = document.createElement('div');
  body.className = 'vp-body';

  const row = document.createElement('div');
  row.className = 'vp-row';

  const progressWrap = document.createElement('div');
  progressWrap.className = 'vp-progress-wrap';
  const progress = document.createElement('div');
  progress.className = 'vp-progress';
  progressWrap.appendChild(progress);

  const time = document.createElement('div');
  time.className = 'vp-time';
  time.textContent = '0:00 / 0:00';

  row.appendChild(progressWrap);
  row.appendChild(time);

  const wave = document.createElement('div');
  wave.className = 'vp-wave';
  for (let i = 0; i < 7; i++) {
    const bar = document.createElement('div');
    bar.className = 'bar';
    bar.style.height = `${4 + Math.floor(Math.random() * 8)}px`;
    wave.appendChild(bar);
  }

  body.appendChild(row);
  body.appendChild(wave);

  container.appendChild(btn);
  container.appendChild(body);
  container.appendChild(audio);

  let anim = null;

  function startWave() {
    if (anim) return;
    wave.classList.add('playing');
    anim = setInterval(() => {
      wave.querySelectorAll('.bar').forEach((b, i) => {
        const h = 4 + Math.round(Math.random() * (10 + (i % 3) * 4));
        b.style.height = h + 'px';
      });
    }, 120);
    btn.classList.add('playing');
  }

  function stopWave() {
    wave.classList.remove('playing');
    if (anim) { clearInterval(anim); anim = null; }
    wave.querySelectorAll('.bar').forEach((b, idx) => b.style.height = (4 + (idx % 4)) + 'px');
    btn.classList.remove('playing');
  }

  btn.onclick = () => {
    if (audio.paused) {
      audio.play().catch(()=>{});
      btn.textContent = '‚è∏';
      startWave();
    } else {
      audio.pause();
      btn.textContent = '‚ñ∂';
      stopWave();
    }
  };

  audio.onloadedmetadata = () => {
    const total = Math.floor(audio.duration || 0);
    time.textContent = `0:00 / ${Math.floor(total/60)}:${(total%60).toString().padStart(2,'0')}`;
  };

  audio.ontimeupdate = () => {
    const cur = Math.floor(audio.currentTime || 0);
    const total = Math.floor(audio.duration || 0) || 1;
    time.textContent = `${Math.floor(cur/60)}:${(cur%60).toString().padStart(2,'0')} / ${Math.floor(total/60)}:${(total%60).toString().padStart(2,'0')}`;
    const pct = (audio.currentTime / total) * 100;
    progress.style.width = `${pct}%`;
  };

  audio.onended = () => {
    btn.textContent = '‚ñ∂';
    stopWave();
    progress.style.width = '0%';
    audio.currentTime = 0;
  };

  progressWrap.onclick = (e) => {
    const rect = progressWrap.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const pct = x / rect.width;
    if (!isFinite(audio.duration) || audio.duration === 0) return;
    audio.currentTime = pct * audio.duration;
  };

  audio.onpause = () => { stopWave(); btn.textContent = '‚ñ∂'; };

  return container;
}

// ----------------- openChat (main) -----------------
async function openChat() {
  const user = await login();
  myUid = user.uid;
  db = getFirestore(appFirebase);
  const myUsername = await pickUsername(myUid);

  // Watch friend requests
  const reqRef = collection(db, "friends");
  const qReq = query(reqRef, where("to", "==", myUid), where("status", "==", "pending"));
  onSnapshot(qReq, snap => {
    snap.forEach(docSnap => {
      const data = docSnap.data();
      showFriendRequest(docSnap.id, data.from);
    });
  });

  // --- window markup: friends column + chat column ---
  const win = makeWin("Chat ‚Äî " + myUsername, 760, 520, `
    <div style="height:100%; display:flex; gap:12px;">
      <div id="friendsPanel" class="friends-col">
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
          <input id="addFriendName" class="modern-input" placeholder="Add friend by username" style="flex:1;" />
          <button id="addFriendBtn" class="modern-btn">Add</button>
        </div>
        <div id="friendsListInner" style="display:flex;flex-direction:column;gap:6px;"></div>
      </div>

      <div class="chat-col" style="flex:1;">
        <div class="chat-header">
          <div>
            <div class="chat-title" id="chatTitle">Select a friend</div>
            <div id="chatSubtitle" style="font-size:12px; opacity:0.75; color:rgba(255,255,255,0.85)">Online</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;">
            <button id="refreshFriends" class="modern-btn">‚ü≥</button>
          </div>
        </div>

        <div id="messages" class="messages-area">
          <div id="typingIndicator" class="typing-indicator" style="display:none;">‚úçÔ∏è Typing...</div>
          <div id="emptyState" class="empty-state">
            <div style="font-size:40px; margin-bottom:10px;">üí¨</div>
            Start a conversation by selecting a friend
          </div>
        </div>

        <div class="input-area">
          <button id="recBtn" class="record-btn" title="Record voice">üé§</button>
          <input id="msg" class="modern-input" placeholder="Type a message..." />
          <button id="sendMsg" class="send-btn">‚û§</button>
        </div>
      </div>
    </div>
  `);

  // --- elements & state ---
  const addFriendName = win.querySelector("#addFriendName");
  const addFriendBtn = win.querySelector("#addFriendBtn");
  const friendsListInner = win.querySelector("#friendsListInner");
  const refreshFriends = win.querySelector("#refreshFriends");
  const messagesEl = win.querySelector("#messages");
  const msgInput = win.querySelector("#msg");
  const sendMsgBtn = win.querySelector("#sendMsg");
  const recBtn = win.querySelector("#recBtn");
  const chatTitle = win.querySelector("#chatTitle");
  const emptyState = win.querySelector("#emptyState");

  let selectedFriend = null; // uid of currently opened friend
  let unsub = null;
  let localTypingTimeout = null;
  let mediaStream = null, mediaRecorder = null, recordedChunks = [], isRecording = false;

  // --- recording UI ---
  function setRecUI(recording){
    if(recording){
      recBtn.classList.add('recording');
      recBtn.textContent = '‚è∫';
    } else {
      recBtn.classList.remove('recording');
      recBtn.textContent = 'üé§';
    }
  }

  async function startRecording() {
    if (isRecording) return;
    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (e) {
      alert("Microphone access denied or not available.");
      return;
    }
    recordedChunks = [];
    const mime = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : (MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : '');
    mediaRecorder = mime ? new MediaRecorder(mediaStream, { mimeType: mime }) : new MediaRecorder(mediaStream);
    mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) recordedChunks.push(e.data); };
    mediaRecorder.onstop = async () => {
      const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
      await uploadAndSendVoice(blob, mediaRecorder.mimeType || 'audio/webm');
      try { mediaStream.getTracks().forEach(t => t.stop()); } catch(e){}
      mediaStream = null; mediaRecorder = null; recordedChunks = []; isRecording = false; setRecUI(false);
    };
    mediaRecorder.start();
    isRecording = true; setRecUI(true);
    setTimeout(() => { if (isRecording) stopRecording(); }, 60_000);
  }

  function stopRecording() { if (!isRecording || !mediaRecorder) return; mediaRecorder.stop(); }

  async function uploadAndSendVoice(blob, contentType) {
    try {
      if (!selectedFriend) return alert("Pick a friend first.");
      const id = chatId(myUid, selectedFriend);
      const msgsRef = collection(db, "chats", id, "messages");

      const reader = new FileReader();
      reader.onload = async () => {
        const base64Audio = reader.result; // data:...;base64,...
        await addDoc(msgsRef, {
          from: myUid,
          audioBase64: base64Audio,
          audioType: contentType,
          ts: Date.now()
        });
      };
      reader.readAsDataURL(blob);

    } catch (err) {
      console.error("Voice DB error:", err);
      alert("Failed to send voice message.");
    }
  }

  recBtn.onclick = async () => {
    if (!isRecording) await startRecording();
    else stopRecording();
  };

  // ---------------- friends list (left column)
  async function loadFriendsPanel() {
    friendsListInner.innerHTML = '';
    const meRef = doc(db, "users", myUid);
    const snap = await getDoc(meRef);
    if (!snap.exists()) return;
    const friends = snap.data().friends || [];

    // remove duplicates using Set and preserve order
    const unique = [...new Set(friends)];

    // show placeholder if empty
    if (unique.length === 0) {
      friendsListInner.innerHTML = `<div style="opacity:0.8">No friends yet</div>`;
      return;
    }

    // For each friend, create a list item
    for (const f of unique) {
      const fUser = await getDoc(doc(db, "users", f));
      const uname = fUser.exists() ? fUser.data().username : f;

      const item = document.createElement('div');
      item.className = 'friend-item';
      item.dataset.uid = f;

      const name = document.createElement('div');
      name.className = 'friend-name';
      name.textContent = uname;

      const sub = document.createElement('div');
      sub.className = 'friend-sub';
      sub.textContent = 'Tap to chat';

      item.appendChild(name);
      item.appendChild(sub);

      item.onclick = () => {
        // mark active
        document.querySelectorAll('.friend-item').forEach(i=>i.classList.remove('active'));
        item.classList.add('active');
        openConversation(f, uname);
      };

      friendsListInner.appendChild(item);
    }
  }

  // Use a single snapshot listener to load friends (prevents duplicates)
  const friendDoc = doc(db, "users", myUid);
  onSnapshot(friendDoc, () => { loadFriendsPanel(); });

  window.loadFriends = loadFriendsPanel;

  addFriendBtn.onclick = async () => {
    const name = addFriendName.value.trim();
    if (!name) return;
    const res = await addFriendByName(myUid, name);
    if (!res.ok) return alert("Could not add friend: " + res.reason);
    addFriendName.value = "";
    alert("Friend request sent!");
  };

  refreshFriends.onclick = loadFriendsPanel;

  // chat helpers
  function chatId(a,b){ return [a,b].sort().join("_"); }

  // ---------- typing indicator (SHORT typing) ----------
  function setTypingState(targetId, val) {
    const id = chatId(myUid, targetId);
    const typingRef = doc(db, "chats", id, "typing", myUid);
    setDoc(typingRef, { typing: val });
  }

  msgInput.oninput = () => {
    if (!selectedFriend) return;
    setTypingState(selectedFriend, true);
    if (localTypingTimeout) clearTimeout(localTypingTimeout);
    localTypingTimeout = setTimeout(() => {
      setTypingState(selectedFriend, false);
    }, 900); // short typing window
  };

  // ---------- open conversation (loads messages for friend) ----------
  async function openConversation(friendUid, friendName) {
    selectedFriend = friendUid;
    chatTitle.textContent = friendName || friendUid;
    emptyState.style.display = 'none';
    messagesEl.querySelectorAll('.message-wrapper').forEach(n=>n.remove());

    const id = chatId(myUid, friendUid);
    const cRef = doc(db, "chats", id);
    const cSnap = await getDoc(cRef);
    if (!cSnap.exists()) await setDoc(cRef, { participants:[myUid, friendUid] });

    // unsubscribe previous
    if (unsub) unsub();

    // subscribe typing sub and messages combined
    const msgsRef = collection(db, "chats", id, "messages");
    const q = query(msgsRef, orderBy("ts","asc"));
    unsub = onSnapshot(q, (snap) => {
      messagesEl.innerHTML = '';
      // typing indicator subscribe
      const typingRef = collection(db, "chats", id, "typing");
      onSnapshot(typingRef, (tSnap) => {
        let friendTyping = false;
        tSnap.forEach((docSnap) => {
          if (docSnap.id !== myUid && docSnap.data().typing) friendTyping = true;
        });
        const typingEl = document.getElementById("typingIndicator");
        if (!typingEl) return;
        typingEl.style.display = friendTyping ? "block" : "none";
      });

      snap.forEach((m) => {
        const d = m.data();
        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${d.from === myUid ? 'sent' : 'received'}`;
        wrapper.dataset.msgId = m.id;

        // construct content
        if (d.audioBase64) {
          const player = createVoicePlayer(d.audioBase64, d.from === myUid);
          wrapper.appendChild(player);
        } else if (d.text) {
          const bubble = document.createElement("div");
          bubble.className = `message-bubble ${d.from === myUid ? 'sent' : 'received'}`;
          bubble.textContent = d.text;
          wrapper.appendChild(bubble);
        } else {
          const bubble = document.createElement("div");
          bubble.className = `message-bubble ${d.from === myUid ? 'sent' : 'received'}`;
          bubble.textContent = "(unknown message)";
          wrapper.appendChild(bubble);
        }

        // small delete icon (hover to reveal)
        const del = document.createElement('div');
        del.className = 'msg-del';
        del.textContent = 'üóëÔ∏è';
        del.title = 'Delete';

        del.onclick = async (ev) => {
          ev.stopPropagation();
          const confirmEveryone = d.from === myUid ? confirm("Delete for everyone? (OK = yes, Cancel = delete locally)") : null;
          const chatIdVal = chatId(myUid, friendUid);

          if (d.from === myUid && confirmEveryone) {
            try {
              await deleteDoc(doc(db, "chats", chatIdVal, "messages", m.id));
            } catch (err) {
              console.error("Delete failed", err);
              alert("Could not delete for everyone.");
            }
          } else {
            // local only: remove DOM node
            wrapper.remove();
          }
        };

        wrapper.appendChild(del);

        // Right-click context menu for extra options (keeps old behavior)
        wrapper.oncontextmenu = (ev) => {
          ev.preventDefault();
          showContextMenu(ev.clientX, ev.clientY, {
            deleteLocal: () => { wrapper.remove(); },
            deleteForEveryone: async () => {
              if (d.from !== myUid) return alert("Only message sender can delete for everyone.");
              try {
                await deleteDoc(doc(db, "chats", id, "messages", m.id));
              } catch (err) {
                console.error(err);
                alert("Could not delete for everyone.");
              }
            }
          }, d.from === myUid);
        };

        messagesEl.appendChild(wrapper);
      });

      // scroll bottom
      messagesEl.scrollTop = messagesEl.scrollHeight;
    });
  }

  // ---------- send text message ----------
  sendMsgBtn.onclick = async () => {
    if (!selectedFriend) return alert("Pick a friend first!");
    const text = msgInput.value.trim();
    if (!text) return;
    const id = chatId(myUid, selectedFriend);
    const msgsRef = collection(db, "chats", id, "messages");
    await addDoc(msgsRef, { from: myUid, text, ts: Date.now() });
    msgInput.value = '';
    // turn off typing quickly
    setTypingState(selectedFriend, false);
  };

  msgInput.onkeypress = (e) => { if (e.key === 'Enter') sendMsgBtn.click(); };

  // ---------- context menu helper ----------
  function showContextMenu(x, y, actions, canDeleteForEveryone) {
    document.querySelectorAll('.context-menu').forEach(n=>n.remove());
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';

    const btnLocal = document.createElement('button');
    btnLocal.textContent = 'Delete locally';
    btnLocal.onclick = () => { actions.deleteLocal(); menu.remove(); };
    menu.appendChild(btnLocal);

    if (canDeleteForEveryone) {
      const btnEveryone = document.createElement('button');
      btnEveryone.textContent = 'Delete for everyone';
      btnEveryone.onclick = () => { actions.deleteForEveryone(); menu.remove(); };
      menu.appendChild(btnEveryone);
    }

    const btnCancel = document.createElement('button');
    btnCancel.textContent = 'Cancel';
    btnCancel.onclick = () => { menu.remove(); };
    menu.appendChild(btnCancel);

    document.body.appendChild(menu);

    const rm = (ev) => { if (!menu.contains(ev.target)) menu.remove(); document.removeEventListener('click', rm); };
    setTimeout(()=>document.addEventListener('click', rm), 30);
  }

  // ---------- utility: friend requests UI ----------
  function showFriendRequest(reqId, fromUid) {
    const winFr = makeWin("Friend Request", 300, 160, `
      <div style="padding:10px;">
        <p><b>${fromUid}</b> wants to be your friend.</p>
        <button id="acc">Accept</button>
        <button id="rej">Reject</button>
      </div>
    `);
    winFr.setAttribute("data-friend-req", reqId);
    winFr.querySelector("#acc").onclick = async () => {
      await updateDoc(doc(db, "friends", reqId), { status: "accepted" });
      const meRef = doc(db, "users", myUid);
      const himRef = doc(db, "users", fromUid);
      await updateDoc(meRef, { friends: arrayUnion(fromUid) });
      await updateDoc(himRef, { friends: arrayUnion(myUid) });
      window.loadFriends();
      winFr.remove();
    };
    winFr.querySelector("#rej").onclick = async () => {
      await updateDoc(doc(db, "friends", reqId), { status: "rejected" });
      winFr.remove();
    };
  }

  // ---------- (do NOT call loadFriendsPanel() manually here; snapshot will call it) ----------
  // loadFriendsPanel();

}

window.openChat = openChat;

</script>
</body>
</html>

<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>WebOS (Updated)</title>
<style>
:root{--bg:#0f1724;--panel:#0b1220;--accent:#3b82f6;--muted:#94a3b8}
*{box-sizing:border-box;font-family:Inter,Segoe UI,sans-serif}
html,body{height:100%;margin:0;background:var(--bg);color:#e6eef8}
#desktop{position:relative;height:100vh;overflow:hidden}
.wallpaper{position:absolute;inset:0;background-size:cover;background-position:center;transition:background 0.5s}
.desktop-cards{position:absolute;top:16px;left:16px;display:flex;flex-direction:column;gap:10px;z-index:2;height:calc(100vh - 80px);overflow-y:auto}
.app-card{width:100px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.03);display:flex;flex-direction:column;align-items:center;gap:4px;cursor:pointer;transition:all .15s}
.app-card:hover{transform:translateY(-3px);background:rgba(255,255,255,0.07)}

.screenshot-clean * {
    backdrop-filter: none !important;
    filter: none !important;
    box-shadow: none !important;
    background-blend-mode: normal !important;
    mix-blend-mode: normal !important;
}
.screenshot-clean .window {
    background: #0b1220 !important;   /* your original panel color */
    opacity: 1 !important;
}

.screenshot-clean .win-title {
    background: rgba(0,0,0,0.3) !important;
    opacity: 1 !important;
}

.screenshot-clean .win-body {
    opacity: 1 !important;
    background: none !important;
}


. window {
  will-change: transform;
}

.file-item {
  will-change: background, transform;
}

.app-card {
  will-change: transform;
}
.app-card:active{transform:scale(0.95)}
.app-card span{font-size:12px;color:var(--muted)}
/* File Manager Styles */
.sidebar-item {
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  margin-bottom: 4px;
  transition: all 0.15s;
}

.sidebar-item:hover {
  background: rgba(59, 130, 246, 0.2);
}

.file-item {
  margin-bottom: 4px;
  transition: all 0.15s;
}

.file-item:hover {
  background: rgba(255, 255, 255, 0.05);
}
.taskbar{position:absolute;left:0;right:0;bottom:0;height:46px;background:rgba(4,8,15,0.9);backdrop-filter:blur(10px);display:flex;align-items:center;padding:0 10px;gap:8px;z-index:1000}
.start-btn{width:40px;height:34px;border-radius:8px;background:var(--panel);display:flex;align-items:center;justify-content:center;cursor:pointer;transition:all .15s}
.start-btn:hover{background:#1e293b}
.tasks{display:flex;gap:6px;flex:1}
.task-item{height:32px;padding:0 10px;background:rgba(255,255,255,0.04);border-radius:6px;display:flex;align-items:center;cursor:pointer;font-size:12px;transition:all .15s}
.task-item:hover{background:rgba(255,255,255,0.08)}
.task-item.active{background:rgba(59,130,246,0.3)}
.clock{color:var(--muted);font-size:12px}
.start-menu{position:absolute;left:10px;bottom:56px;width:280px;background:rgba(11,18,32,0.95);backdrop-filter:blur(20px);border-radius:10px;padding:10px;box-shadow:0 8px 32px rgba(0,0,0,0.5);z-index:1001;opacity:0;transform:translateY(10px);pointer-events:none;transition:all .2s}
.start-menu.open{opacity:1;transform:translateY(0);pointer-events:auto}
.start-menu input{width:100%;padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.05);background:rgba(0,0,0,0.3);color:inherit;margin-bottom:10px}
.apps-grid{display:grid;grid-template-columns:repeat(3,1fr);gap:6px}
.app-card-small{padding:8px;border-radius:6px;background:rgba(255,255,255,0.03);text-align:center;cursor:pointer;font-size:11px;transition:all .15s}
.app-card-small:hover{background:rgba(255,255,255,0.08)}
.window{position:absolute;background:var(--panel);border-radius:10px;box-shadow:0 10px 40px rgba(0,0,0,0.7);display:flex;flex-direction:column;z-index:50;animation:winOpen .2s ease-out}
@keyframes winOpen{from{opacity:0;transform:scale(0.92)}to{opacity:1;transform:scale(1)}}
.window.closing{animation:winClose .15s ease-out forwards}
.tile {
  position: relative;
  transition: transform 0.15s ease-in-out, background 0.15s;
}

.tile-new {
  animation: tileSpawn 0.2s ease-out;
}

@keyframes tileSpawn {
  from { transform: scale(0.3); opacity: 0; }
  to   { transform: scale(1); opacity: 1; }
}

.tile-merge {
  animation: tileMerge 0.2s ease-out;
}

@keyframes tileMerge {
  from { transform: scale(1); }
  50%  { transform: scale(1.25); }
  to   { transform: scale(1); }
}

@keyframes winClose{to{opacity:0;transform:scale(0.92)}}
.window.minimizing{animation:winMin .2s ease-out forwards}
.game-tile {
  background: rgba(255,255,255,0.06);
  border-radius: 10px;
  padding: 12px;
  display: flex;
  flex-direction: column;
  align-items: center;
  cursor: pointer;
  transition: 0.15s;
  box-shadow: 0 4px 10px rgba(0,0,0,0.25);
}

.game-tile:hover {
  transform: translateY(-4px);
  background: rgba(255,255,255,0.12);
}

.game-icon {
  font-size: 40px;
  margin-bottom: 6px;
  text-shadow: 0 2px 6px rgba(0,0,0,0.4);
}

.game-title {
  font-size: 15px;
  font-weight: bold;
  margin-bottom: 4px;
}

.game-score {
  font-size: 12px;
  color: #a5b4fc;
}

@keyframes winMin{to{opacity:0;transform:translateY(50px) scale(0.8)}}
.win-title{height:36px;display:flex;align-items:center;padding:0 10px;background:rgba(0,0,0,0.2);cursor:grab;border-radius:10px 10px 0 0}
.win-title .title{flex:1;font-size:12px;font-weight:600}
.win-controls{display:flex;gap:4px}
.win-controls button{width:26px;height:22px;border:0;background:transparent;color:var(--muted);cursor:pointer;border-radius:4px;font-size:10px;transition:all .1s}
.win-controls button:hover{background:rgba(255,255,255,0.1)}
.win-controls button[data-act="close"]:hover{background:#ef4444;color:#fff}
.win-body{flex:1;padding:10px;overflow:auto}
.btn{padding:6px 12px;border-radius:6px;background:var(--accent);border:0;color:#fff;cursor:pointer;font-size:12px;transition:all .1s}
.btn:hover{opacity:0.85}
.input{padding:8px;border-radius:6px;border:1px solid rgba(255,255,255,0.05);background:rgba(0,0,0,0.2);color:inherit;width:100%}
.input:focus{outline:none;border-color:var(--accent)}
.small{font-size:11px;color:var(--muted)}
.resizer{position:absolute;right:2px;bottom:2px;width:12px;height:12px;cursor:se-resize;opacity:0.3}
.file-thumb{height:48px;width:48px;object-fit:cover;border-radius:6px;margin-right:8px;border:1px solid rgba(255,255,255,0.04)}

.file-item.dragging {
  opacity: 0.5;
  cursor: grabbing;
}

.file-item.drag-over {
  background: rgba(59, 130, 246, 0.2);
  border: 2px dashed var(--accent);
}

.drop-zone {
  position: relative;
}

.drop-zone::after {
  content: 'Drop here';
  position: absolute;
  inset: 0;
  background: rgba(59, 130, 246, 0.1);
  border: 3px dashed var(--accent);
  border-radius: 8px;
  display: none;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  color: var(--accent);
  pointer-events: none;
  z-index: 100;
}

.drop-zone.drag-active::after {
  display: flex;
}

/* NEW: Notification System */
.notifications-container {
  position: fixed;
  top: 16px;
  right: 16px;
  width: 320px;
  z-index: 10000;
  display: flex;
  flex-direction: column;
  gap: 10px;
  pointer-events: none;
}

.notification {
  background: rgba(11, 18, 32, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 10px;
  padding: 14px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  gap: 12px;
  transform: translateX(400px);
  opacity: 0;
  transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  pointer-events: all;
  border-left: 4px solid var(--accent);
}

.notification.show {
  transform: translateX(0);
  opacity: 1;
}

.notification.hide {
  transform: translateX(400px);
  opacity: 0;
}

.notification-icon {
  font-size: 20px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 8px;
  background: rgba(59, 130, 246, 0.2);
}

.notification-content {
  flex: 1;
}

.notification-title {
  font-weight: 600;
  font-size: 13px;
  margin-bottom: 2px;
}

.notification-message {
  font-size: 12px;
  color: var(--muted);
  line-height: 1.4;
}

.notification-close {
  background: none;
  border: none;
  color: var(--muted);
  cursor: pointer;
  font-size: 14px;
  padding: 0;
  width: 20px;
  height: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 4px;
  transition: all 0.1s;
}

.sidebar-item {
  padding: 8px 12px;
  border-radius: 6px;
  cursor: pointer;
  font-size: 12px;
  margin-bottom: 4px;
  transition: all 0.2s ease;
}

.sidebar-item:hover {
  background: rgba(59, 130, 246, 0.2);
  transform: translateX(4px);
}

.notification-close:hover {
  background: rgba(255, 255, 255, 0.1);
}

/* Notification types */
.notification.success {
  border-left-color: #10b981;
}

.notification.success .notification-icon {
  background: rgba(16, 185, 129, 0.2);
}

.notification.error {
  border-left-color: #ef4444;
}

.notification.error .notification-icon {
  background: rgba(239, 68, 68, 0.2);
}

.notification.warning {
  border-left-color: #f59e0b;
}

.notification.warning .notification-icon {
  background: rgba(245, 158, 11, 0.2);
}

.notification.info {
  border-left-color: #3b82f6;
}

.notification.info .notification-icon {
  background: rgba(59, 130, 246, 0.2);
}

/* NEW: Right-click Context Menu */
.context-menu {
  position: fixed;
  background: rgba(11, 18, 32, 0.95);
  backdrop-filter: blur(20px);
  border-radius: 8px;
  padding: 6px;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
  z-index: 10000;
  min-width: 160px;
  opacity: 0;
  transform: scale(0.95);
  transition: all 0.1s ease;
  pointer-events: none;
}

.context-menu.show {
  opacity: 1;
  transform: scale(1);
  pointer-events: all;
}

.context-item {
  padding: 8px 12px;
  border-radius: 4px;
  cursor: pointer;
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 8px;
  transition: all 0.1s;
}

.context-item:hover {
  background: rgba(59, 130, 246, 0.2);
}

.context-item:active {
  background: rgba(59, 130, 246, 0.3);
}

.context-divider {
  height: 1px;
  background: rgba(255, 255, 255, 0.1);
  margin: 4px 0;
}

/* Wallpaper Grid */
.wallpaper-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 8px;
  margin-top: 8px;
  max-height: 200px;
  overflow-y: auto;
}

.wallpaper-item {
  aspect-ratio: 16/9;
  border-radius: 6px;
  cursor: pointer;
  background-size: cover;
  background-position: center;
  border: 2px solid transparent;
  transition: all 0.15s;
}

.wallpaper-item:hover {
  transform: scale(1.05);
}

.wallpaper-item.active {
  border-color: var(--accent);
}

.wallpaper-item.custom {
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  background: rgba(255, 255, 255, 0.05);
}

.wallpaper-item.custom::before {
  content: '+';
  font-size: 24px;
  color: var(--muted);
}

.wallpaper-item.custom:hover::before {
  color: var(--accent);
}

</style>
</head>
<body>
<div id="desktop">
  <div class="wallpaper" id="wallpaper"></div>
  <div class="desktop-cards" id="desktopCards">
    <div class="app-card" data-app="explorer"><span>üìÅ</span><span>Files</span></div>
    <div class="app-card" data-app="editor"><span>üìù</span><span>Editor</span></div>
    <div class="app-card" data-app="terminal"><span>üíª</span><span>Terminal</span></div>
    <div class="app-card" data-app="paint"><span>üé®</span><span>Paint</span></div>
    <div class="app-card" data-app="screenshot">
        <span>üì∏</span>
        <span>Screenshot</span>
    </div>
    <div class="app-card" data-app="games"><span>üéÆ</span><span>Games</span></div>
	<div class="app-card" data-app="chat"><span>üí¨</span> <span>Chat</span></div>

    <div class="app-card" data-app="calculator"><span>üßÆ</span><span>Calc</span></div>
    <div class="app-card" data-app="browser"><span>üåê</span><span>Browser</span></div>
    <div class="app-card" data-app="settings"><span>‚öôÔ∏è</span><span>Settings</span></div>
  </div>
  <div id="windows"></div>
  <div class="taskbar">
    <div class="start-btn" id="startBtn">‚ò∞</div>
    <div class="tasks" id="taskList"></div>
    <div class="clock" id="clock"></div>
  </div>
  <div class="start-menu" id="startMenu">
    <input id="startSearch" placeholder="Search..." />
    <div class="apps-grid" id="appsGrid">
      <div class="app-card-small" data-app="explorer">üìÅ Files</div>
      <div class="app-card-small" data-app="editor">üìù Editor</div>
      <div class="app-card-small" data-app="terminal">üíª Terminal</div>
      <div class="app-card-small" data-app="paint">üé® Paint</div>
      <div class="app-card-small" data-app="games">üéÆ Games</div>
      <div class="app-card-small" data-app="screenshot">
          üì∏ Screenshot
       </div>
      <div class="app-card-small" data-app="calculator">üßÆ Calc</div>
      <div class="app-card-small" data-app="browser">üåê Browser</div>
      <div class="app-card-small" data-app="settings">‚öôÔ∏è Settings</div>
      <div class="app-card-small" data-app="about">‚ÑπÔ∏è About</div>
    </div>
  </div>
  
  <!-- NEW: Notifications Container -->
  <div class="notifications-container" id="notifications"></div>
  
  <!-- NEW: Context Menu -->
  <div class="context-menu" id="contextMenu">
    <div class="context-item" data-action="refresh">üîÑ Refresh Desktop</div>
    <div class="context-item" data-action="newFile">üìÑ New Text File</div>
    <div class="context-divider"></div>
    <div class="context-item" data-action="terminal">üíª Open Terminal</div>
    <div class="context-item" data-action="snake">üêç Play Snake</div>
    <div class="context-divider"></div>
    <div class="context-item" data-action="settings">‚öôÔ∏è Settings</div>
  </div>
</div>
<script>

const FS_KEY='webos_fs_v2';

function getFS(){
  try{
    const raw = localStorage. getItem(FS_KEY) || '';
    if(!raw){
      // bootstrap default filesystem with CORRECT structure
      const fs = {
        "/": { type: "dir", children: ["Downloads","Documents","Music","Videos","Pictures"] },
        "/Downloads": { type: "dir", children: [] },
        "/Documents": { type: "dir", children: [] },
        "/Music": { type: "dir", children: [] },
        "/Videos": { type: "dir", children: [] },
        "/Pictures": { type: "dir", children: [] }
      };
      localStorage.setItem(FS_KEY, JSON.stringify(fs));
      return fs;
    }
    
    let fs = JSON.parse(raw);
    
    const requiredFolders = ["/Downloads", "/Documents", "/Music", "/Videos", "/Pictures"];
    let needsSave = false;
    
    if(!fs["/"]) {
      fs["/"] = { type: "dir", children: [] };
      needsSave = true;
    }
    
    requiredFolders. forEach(folder => {
      if(!fs[folder]) {
        fs[folder] = { type: "dir", children: [] };
        if(! fs["/"]. children.includes(folder. slice(1))) {
          fs["/"].children.push(folder. slice(1));
        }
        needsSave = true;
      }
    });
    
    // Fix broken path references (old format: "Downloads" instead of "/Downloads")
    const oldKeys = Object.keys(fs). filter(k => ! k.startsWith('/') && k !== 'type' && k !== 'children');
    oldKeys.forEach(oldKey => {
      const newKey = '/' + oldKey;
      if(! fs[newKey]) {
        fs[newKey] = fs[oldKey];
        delete fs[oldKey];
        needsSave = true;
      }
    });
    
    if(needsSave) {
      localStorage.setItem(FS_KEY, JSON.stringify(fs));
    }
    
    return fs;
  }catch(e){
    console.error("FS read error", e);
    // HARD RESET on corruption
    console.log("Resetting filesystem.. .");
    const freshFS = {
      "/": { type: "dir", children: ["Downloads","Documents","Music","Videos","Pictures"] },
      "/Downloads": { type: "dir", children: [] },
      "/Documents": { type: "dir", children: [] },
      "/Music": { type: "dir", children: [] },
      "/Videos": { type: "dir", children: [] },
      "/Pictures": { type: "dir", children: [] }
    };
    localStorage.setItem(FS_KEY, JSON.stringify(freshFS));
    return freshFS;
  }
}
function setFS(fs){
  try{
    // Validate before saving
    if(!fs["/"] || !fs["/"].type) {
      console.warn("Invalid FS structure, skipping save");
      return;
    }
    localStorage.setItem(FS_KEY, JSON.stringify(fs));
  }catch(e){
    console.error("FS write error", e);
  }
}

// BONUS: Add this to clear everything if needed
function resetFilesystem() {
  const freshFS = {
    "/": { type: "dir", children: ["Downloads","Documents","Music","Videos","Pictures"] },
    "/Downloads": { type: "dir", children: [] },
    "/Documents": { type: "dir", children: [] },
    "/Music": { type: "dir", children: [] },
    "/Videos": { type: "dir", children: [] },
    "/Pictures": { type: "dir", children: [] }
  };
  localStorage.setItem(FS_KEY, JSON.stringify(freshFS));
  showNotification('Filesystem Reset', 'All files cleared', 'warning', 3000);
  location.reload();
}


const $=id=>document.getElementById(id);
const windowsEl=$('windows'),taskList=$('taskList'),startMenu=$('startMenu');
let zIdx=10,winCount=0;
const winTasks=new Map();

function showNotification(title, message, type = 'info', duration = 4000) {
  const notificationsContainer = $('notifications');
  
  // Don't show too many notifications
  if(notificationsContainer.children.length > 3) {
    notificationsContainer.removeChild(notificationsContainer.firstChild);
  }
  
  const notification = document.createElement('div');
  notification.className = `notification ${type}`;
  
  const icons = {
    success: '‚úÖ',
    error: '‚ùå',
    warning: '‚ö†Ô∏è',
    info: '‚ÑπÔ∏è'
  };
  
  notification. innerHTML = `
    <div class="notification-icon">${icons[type] || icons.info}</div>
    <div class="notification-content">
      <div class="notification-title">${title}</div>
      <div class="notification-message">${message}</div>
    </div>
    <button class="notification-close">√ó</button>
  `;
  
  notificationsContainer.appendChild(notification);
  
  requestAnimationFrame(() => {
    notification.classList.add('show');
  });
  
  let timeoutId = setTimeout(() => {
    hideNotification(notification);
  }, duration);
  
  notification.querySelector('.notification-close').onclick = () => {
    clearTimeout(timeoutId);
    hideNotification(notification);
  };
}

function hideNotification(notification) {
  notification.classList.remove('show');
  notification.classList.add('hide');
  setTimeout(() => {
    if (notification.parentNode) {
      notification.parentNode.removeChild(notification);
    }
  }, 300);
}


const contextMenu = $('contextMenu');
let contextMenuTarget = null;

// Simple file-manager clipboard for cut/copy/paste
const fmClipboard = { mode: null, path: null }; // mode = 'cut'|'copy', path = absolute path to item

// Utility: build a menu (array of { label, action, disabled })
function buildMenu(items) {
  contextMenu.innerHTML = ''; // clear
  items.forEach(it => {
    const el = document.createElement('div');
    el.className = 'context-item' + (it.disabled ? ' disabled' : '');
    el.textContent = it.label;
    if (it.disabled) el.style.opacity = '0.4';
    if (it.action && !it.disabled) {
      el.dataset.action = it.action;
      el.addEventListener('click', (ev) => {
        ev.stopPropagation();
        handleContextAction(it.action, it.meta);
        contextMenu.classList.remove('show');
      });
    }
    contextMenu.appendChild(el);
  });
}

// Helpers to determine explorer targets
function findExplorerTarget(el) {
  // file/folder clickable area often has data-path & data-name (renderList uses those)
  const btn = el.closest('[data-path][data-name], [data-f], [data-del], .file-item, #explorerList');
  return btn;
}

function pathFromDataset(el) {
  if (!el) return null;
  // if element has data-path & data-name
  if (el.dataset && el.dataset.name && (el.dataset.path !== undefined)) {
    const p = el.dataset.path === '/' ? '/' + el.dataset.name : el.dataset.path + '/' + el.dataset.name;
    return { path: p, name: el.dataset.name, kind: el.dataset.kind || null };
  }
  // if element has data-f (file buttons)
  if (el.dataset && el.dataset.f && el.dataset.path !== undefined) {
    const p = el.dataset.path === '/' ? '/' + el.dataset.f : el.dataset.path + '/' + el.dataset.f;
    return { path: p, name: el.dataset.f, kind: 'file' };
  }
  // fallback: if it's a .file-item, try to find inner [data-path] or [data-name]
  const inner = el.querySelector && (el.querySelector('[data-path][data-name]') || el.querySelector('[data-f]'));
  if (inner) return pathFromDataset(inner);
  return null;
}

// FS operations used by context menu
function ensureTrash() {
  const fs = getFS();
  if (!fs['/Trash']) {
    fs['/Trash'] = { type: 'dir', children: [] };
    // ensure root references
    if (fs['/'] && Array.isArray(fs['/'].children) && !fs['/'].children.includes('Trash')) {
      fs['/'].children.push('Trash');
    }
    setFS(fs);
  }
}

function moveToTrash(itemPath) {
  const fs = getFS();
  if (!fs[itemPath]) return false;
  ensureTrash();
  const name = itemPath.split('/').pop();
  const ts = Date.now();
  // create unique trash name
  let trashName = `${name}_${ts}`;
  const trashPath = '/Trash/' + trashName;
  fs[trashPath] = fs[itemPath];
  // store metadata
  fs[trashPath].meta = fs[trashPath].meta || {};
  fs[trashPath].meta.originalPath = itemPath;
  fs[trashPath].meta.deletedAt = ts;
  // add to /Trash children
  fs['/Trash'].children = fs['/Trash'].children || [];
  fs['/Trash'].children.push(trashName);
  // remove from parent children
  const parent = itemPath.split('/').slice(0, -1).join('/') || '/';
  const shortName = name;
  if (fs[parent] && Array.isArray(fs[parent].children)) {
    const idx = fs[parent].children.indexOf(shortName);
    if (idx >= 0) fs[parent].children.splice(idx, 1);
  }
  // delete original key and persist
  delete fs[itemPath];
  setFS(fs);
  return true;
}

function copyEntry(srcPath, destDir) {
  const fs = getFS();
  if (!fs[srcPath]) return false;
  const name = srcPath.split('/').pop();
  const destPath = destDir === '/' ? '/' + name : destDir + '/' + name;
  // handle collision by suffix
  if (fs[destPath]) {
    let i = 1;
    const dot = name.lastIndexOf('.');
    const ext = dot > 0 ? name.slice(dot) : '';
    const base = dot > 0 ? name.slice(0, dot) : name;
    let candidate = `${base}-${i}${ext}`;
    while (fs[destDir === '/' ? '/' + candidate : destDir + '/' + candidate]) {
      i++;
      candidate = `${base}-${i}${ext}`;
    }
    const finalPath = destDir === '/' ? '/' + candidate : destDir + '/' + candidate;
    // deep copy object
    fs[finalPath] = JSON.parse(JSON.stringify(fs[srcPath]));
    // add to children
    if (!fs[destDir]) fs[destDir] = { type: 'dir', children: [] };
    fs[destDir].children = fs[destDir].children || [];
    fs[destDir].children.push(candidate);
  } else {
    fs[destPath] = JSON.parse(JSON.stringify(fs[srcPath]));
    if (!fs[destDir]) fs[destDir] = { type: 'dir', children: [] };
    fs[destDir].children = fs[destDir].children || [];
    fs[destDir].children.push(name);
  }
  setFS(fs);
  return true;
}

function moveEntry(srcPath, destDir) {
  const fs = getFS();
  if (!fs[srcPath]) return false;
  const name = srcPath.split('/').pop();
  const destPath = destDir === '/' ? '/' + name : destDir + '/' + name;
  if (fs[destPath]) {
    alert('Destination already has a file/folder named ' + name);
    return false;
  }
  // add to dest children
  if (!fs[destDir]) fs[destDir] = { type: 'dir', children: [] };
  fs[destDir].children = fs[destDir].children || [];
  fs[destDir].children.push(name);
  // remove from old parent's children
  const oldParent = srcPath.split('/').slice(0, -1).join('/') || '/';
  if (fs[oldParent] && Array.isArray(fs[oldParent].children)) {
    const idx = fs[oldParent].children.indexOf(name);
    if (idx >= 0) fs[oldParent].children.splice(idx, 1);
  }
  // move entry (for directories, move keys recursively)
  // simple strategy: if directory, copy children keys and delete originals
  if (fs[srcPath].type === 'dir') {
    const keysToMove = Object.keys(fs).filter(k => k === srcPath || k.startsWith(srcPath + '/'));
    keysToMove.forEach(k => {
      const relative = k.slice(srcPath.length);
      const newKey = destPath + relative;
      fs[newKey] = fs[k];
      delete fs[k];
    });
  } else {
    fs[destPath] = fs[srcPath];
    delete fs[srcPath];
  }
  setFS(fs);
  return true;
}

function renameEntry(srcPath, newName) {
  const fs = getFS();
  if (!fs[srcPath]) return false;
  const parent = srcPath.split('/').slice(0, -1).join('/') || '/';
  const newPath = parent === '/' ? '/' + newName : parent + '/' + newName;
  if (fs[newPath]) {
    alert('A file with that name already exists.');
    return false;
  }
  // update parent's children
  if (fs[parent] && Array.isArray(fs[parent].children)) {
    const oldName = srcPath.split('/').pop();
    const idx = fs[parent].children.indexOf(oldName);
    if (idx >= 0) fs[parent].children[idx] = newName;
  }
  // for dirs, move keys recursively
  if (fs[srcPath].type === 'dir') {
    const keysToMove = Object.keys(fs).filter(k => k === srcPath || k.startsWith(srcPath + '/'));
    keysToMove.forEach(k => {
      const relative = k.slice(srcPath.length);
      const newKey = newPath + relative;
      fs[newKey] = fs[k];
      delete fs[k];
    });
  } else {
    fs[newPath] = fs[srcPath];
    delete fs[srcPath];
  }
  setFS(fs);
  return true;
}

// Handle external import drop (re-uses importer logic)
async function importFilesTo(files, destDir) {
  if (!files || files.length === 0) return 0;
  const fsObj = getFS();
  let importedCount = 0;
  for (const file of files) {
    const reader = new FileReader();
    await new Promise(res => {
      reader.onload = () => {
        const fileName = file.name;
        const filePath = destDir === '/' ? '/' + fileName : destDir + '/' + fileName;
        // avoid overwrite by suffixing
        if (fsObj[filePath]) {
          let i = 1;
          const dot = fileName.lastIndexOf('.');
          const ext = dot > 0 ? fileName.slice(dot) : '';
          const base = dot > 0 ? fileName.slice(0, dot) : fileName;
          let cand = base + '-' + i + ext;
          while (fsObj[destDir === '/' ? '/' + cand : destDir + '/' + cand]) { i++; cand = base + '-' + i + ext; }
          const finalPath = destDir === '/' ? '/' + cand : destDir + '/' + cand;
          fsObj[finalPath] = { type: 'file', mime: file.type || 'application/octet-stream', data: reader.result };
          fsObj[destDir] = fsObj[destDir] || { type: 'dir', children: [] };
          fsObj[destDir].children = fsObj[destDir].children || [];
          fsObj[destDir].children.push(cand);
        } else {
          fsObj[filePath] = { type: 'file', mime: file.type || 'application/octet-stream', data: reader.result };
          fsObj[destDir] = fsObj[destDir] || { type: 'dir', children: [] };
          fsObj[destDir].children = fsObj[destDir].children || [];
          fsObj[destDir].children.push(fileName);
        }
        importedCount++;
        res();
      };
      reader.onerror = () => res();
      reader.readAsDataURL(file);
    });
  }
  setFS(fsObj);
  return importedCount;
}

// Show context menu on right-click (global handler)
document.addEventListener('contextmenu', (e) => {
  e.preventDefault();
  contextMenu.classList.remove('show');
  contextMenu.style.left = e.pageX + 'px';
  contextMenu.style.top = e.pageY + 'px';
  contextMenuTarget = e.target;

  // Decide which menu to show based on target
  const explorerEl = findExplorerTarget(e.target);
  const info = pathFromDataset(explorerEl);

  // If user right-clicked on a file/folder inside Explorer
  if (info && e.target.closest && e.target.closest('#explorerList')) {
    // Determine if target is a folder or file by checking FS
    const fs = getFS();
    const entry = fs[info.path];
    if (entry && entry.type === 'dir') {
      // folder menu
      buildMenu([
        { label: 'Open', action: 'fm_open', meta: { path: info.path } },
        { label: 'New Folder', action: 'fm_newFolder', meta: { path: info.path } },
        { label: 'New File', action: 'fm_newFile', meta: { path: info.path } },
        { label: 'Paste', action: 'fm_paste', disabled: !fmClipboard.mode },
        { label: 'Rename', action: 'fm_rename', meta: { path: info.path } },
        { label: 'Delete', action: 'fm_delete', meta: { path: info.path } },
        { label: 'Properties', action: 'fm_props', meta: { path: info.path } },
      ]);
    } else {
      // file menu
      buildMenu([
        { label: 'Open', action: 'fm_open', meta: { path: info.path } },
        { label: 'Cut', action: 'fm_cut', meta: { path: info.path } },
        { label: 'Copy', action: 'fm_copy', meta: { path: info.path } },
        { label: 'Paste', action: 'fm_paste', disabled: !fmClipboard.mode },
        { label: 'Rename', action: 'fm_rename', meta: { path: info.path } },
        { label: 'Delete', action: 'fm_delete', meta: { path: info.path } },
        { label: 'Properties', action: 'fm_props', meta: { path: info.path } },
      ]);
    }
  } else if (e.target.closest && e.target.closest('#explorerList')) {
    // blank area inside explorer
    buildMenu([
      { label: 'New Folder', action: 'fm_newFolder', meta: { path: '/' } },
      { label: 'New File', action: 'fm_newFile', meta: { path: '/' } },
      { label: 'Paste', action: 'fm_paste', disabled: !fmClipboard.mode },
      { label: 'Import Files...', action: 'fm_import', meta: { path: '/' } },
      { label: 'Refresh', action: 'refresh' },
    ]);
  } else {
    // Desktop or other: keep original desktop-level menu
    buildMenu([
      { label: 'Refresh Desktop', action: 'refresh' },
      { label: 'New Text File', action: 'newFile' },
      { label: 'Open Terminal', action: 'terminal' },
      { label: 'Play Snake', action: 'snake' },
      { label: 'Settings', action: 'settings' },
    ]);
  }

  setTimeout(() => contextMenu.classList.add('show'), 10);
});

// Hide on click elsewhere
document.addEventListener('click', () => {
  contextMenu.classList.remove('show');
});

// Context actions handler (file-manager aware)
function handleContextAction(action, meta = {}) {
  const fs = getFS();
  switch (action) {
    case 'refresh':
      showNotification('Desktop', 'Desktop refreshed', 'info', 1200);
      break;
    

    case 'newFile': {
      // If meta.path is present and is a dir, use it; otherwise default to root
      const destDir = meta.path || '/';
      openEditor(); // editor saves default to /Documents; user can move later
      break;
    }

    case 'terminal':
      openTerminal();
      break;

    case 'snake':
      openSnake();
      break;

    case 'settings':
      openSettings();
      break;

    // File manager actions
    case 'fm_open': {
      const p = meta.path;
      if (!p) return;
      const entry = fs[p];
      if (!entry) { showNotification('Open', 'Item not found', 'error'); return; }
      if (entry.type === 'dir') {
        // try to open an Explorer at this path
        openExplorer(p);
      } else {
        // open by type
        if (entry.mime && entry.mime.startsWith('image/')) openImageViewer(p);
        else if (entry.mime && entry.mime.startsWith('audio/')) openMusicPlayer(p);
        else if (entry.mime && entry.mime.startsWith('video/')) openVideoPlayer(p);
        else openEditor(p);
      }
      break;
    }

    case 'fm_cut': {
      fmClipboard.mode = 'cut';
      fmClipboard.path = meta.path;
      showNotification('Cut', (meta.path || '').split('/').pop() + ' ready to move', 'info', 2000);
      break;
    }

    case 'fm_copy': {
      fmClipboard.mode = 'copy';
      fmClipboard.path = meta.path;
      showNotification('Copy', (meta.path || '').split('/').pop() + ' copied', 'info', 2000);
      break;
    }

    case 'fm_paste': {
      if (!fmClipboard.mode || !fmClipboard.path) {
        showNotification('Paste', 'Nothing to paste', 'warning', 1800);
        return;
      }
      // Determine destination directory: if meta.path is a folder, use it; otherwise find nearest explorer root
      let destDir = '/';
      if (meta.path) {
        // if meta.path is a file, convert to parent dir
        const candidate = meta.path;
        if (fs[candidate] && fs[candidate].type === 'dir') destDir = candidate;
        else destDir = candidate.split('/').slice(0, -1).join('/') || '/';
      } else if (contextMenuTarget) {
        const ex = findExplorerTarget(contextMenuTarget);
        const info = pathFromDataset(ex);
        if (info) {
          // drop onto folder -> parent is that folder
          if (fs[info.path] && fs[info.path].type === 'dir') destDir = info.path;
          else destDir = info.path.split('/').slice(0, -1).join('/') || '/';
        }
      }

      if (fmClipboard.mode === 'cut') {
        if (fmClipboard.path === destDir || (fmClipboard.path && fmClipboard.path.startsWith(destDir + '/'))) {
          showNotification('Move Failed', 'Cannot move into itself', 'error', 2500);
          return;
        }
        const ok = moveEntry(fmClipboard.path, destDir);
        if (ok) {
          showNotification('Moved', (fmClipboard.path || '').split('/').pop() + ' ‚Üí ' + destDir, 'success', 2000);
          fmClipboard.mode = null; fmClipboard.path = null;
        } else showNotification('Move Failed', 'Could not move item', 'error', 2200);
      } else if (fmClipboard.mode === 'copy') {
        const ok = copyEntry(fmClipboard.path, destDir);
        if (ok) showNotification('Copied', (fmClipboard.path || '').split('/').pop() + ' ‚Üí ' + destDir, 'success', 2000);
        else showNotification('Copy Failed', 'Could not copy item', 'error', 2200);
      }
      break;
    }

    case 'fm_rename': {
      const src = meta.path;
      if (!src) return;
      const oldName = src.split('/').pop();
      const newName = prompt('Rename', oldName);
      if (!newName || newName.trim() === '') return;
      if (newName === oldName) return;
      const ok = renameEntry(src, newName);
      if (ok) showNotification('Renamed', `${oldName} ‚Üí ${newName}`, 'success', 2000);
      else showNotification('Rename Failed', 'Could not rename', 'error', 2200);
      break;
    }

    case 'fm_delete': {
      const src = meta.path;
      if (!src) return;
      if (!confirm('Delete ' + src.split('/').pop() + '?')) return;
      const ok = moveToTrash(src);
      if (ok) showNotification('Deleted', src.split('/').pop() + ' moved to Trash', 'warning', 2500);
      else showNotification('Delete Failed', 'Could not remove item', 'error', 2200);
      break;
    }

    case 'fm_newFolder': {
      // meta.path is the folder clicked (create inside that), or root
      const baseDir = (meta.path && getFS()[meta.path] && getFS()[meta.path].type === 'dir') ? meta.path : '/';
      const name = prompt('Folder name');
      if (!name) return;
      const fs2 = getFS();
      const folderPath = baseDir === '/' ? '/' + name : baseDir + '/' + name;
      if (fs2[folderPath]) { alert('Folder exists'); return; }
      fs2[folderPath] = { type: 'dir', children: [] };
      fs2[baseDir] = fs2[baseDir] || { type: 'dir', children: [] };
      fs2[baseDir].children = fs2[baseDir].children || [];
      fs2[baseDir].children.push(name);
      setFS(fs2);
      showNotification('Folder Created', `${name} created`, 'success', 2000);
      break;
    }
    case 'fm_newFile': {
  // Get the CURRENT explorer window's path
  let baseDir = '/';
  
  // Search ALL explorer windows for the active one
  const allWindows = document.querySelectorAll('.window');
  allWindows.forEach(win => {
    const breadcrumbs = win.querySelector('#breadcrumbs');
    if(breadcrumbs) {
      // Get last span with data-path
      const spans = breadcrumbs.querySelectorAll('span[data-path]');
      if(spans. length > 0) {
        const lastSpan = spans[spans.length - 1];
        baseDir = lastSpan.dataset.path || '/';
      } else if(breadcrumbs.textContent.includes('This PC')) {
        baseDir = '/';
      }
    }
  });
  
  // If meta.path is available and valid, use it instead
  if(meta && meta.path && getFS()[meta.path] && getFS()[meta.path]. type === 'dir') {
    baseDir = meta.path;
  }
  
  console.log('üéØ fm_newFile - Opening editor with baseDir:', baseDir);
  openEditor('', baseDir);
  break;
}
    case 'fm_import': {
      // create a hidden input, click it, import into meta.path or root
      const target = meta.path || '/';
      const inp = document.createElement('input');
      inp.type = 'file';
      inp.multiple = true;
      inp.style.display = 'none';
      inp.onchange = async (ev) => {
        const files = Array.from(ev.target.files || []);
        const count = await importFilesTo(files, target);
        if (count > 0) showNotification('Import Complete', `${count} files imported`, 'success', 3000);
      };
      document.body.appendChild(inp);
      inp.click();
      setTimeout(()=>document.body.removeChild(inp), 2000);
      break;
    }

    case 'fm_props': {
      const p = meta.path;
      if (!p) return;
      const entry = getFS()[p];
      if (!entry) { showNotification('Properties', 'Not found', 'error'); return; }
      makeWin('Properties: ' + p.split('/').pop(), 420, 320, `<pre style="white-space:pre-wrap">${JSON.stringify(entry, null, 2)}</pre>`);
      break;
    }

    default:
      // noop
      break;
  }

  // Try to refresh any open Explorer windows by re-rendering lists (they all use id explorerList)
  document.querySelectorAll('#explorerList').forEach(el => {
    // attempt to call the render function if attached to the window element
    // since renderList is scoped inside openExplorer, easiest is to simulate a refresh button click on the explorer window if present
    const winEl = el.closest('.window');
    if (winEl) {
      const refreshBtn = winEl.querySelector('#btnRefresh');
      if (refreshBtn) refreshBtn.click();
    }
  });
<!-- } -->

// ---------------- SFX ----------------
const audioCtx = new (window.AudioContext||window.webkitAudioContext)();
// Performance optimization - lazy load desktop cards
let desktopCardsLoaded = false;

function lazyLoadDesktopCards() {
  if(desktopCardsLoaded) return;
  desktopCardsLoaded = true;
  
  // Desktop cards are already in DOM, just optimize rendering
  const cards = document.querySelectorAll('.app-card');
  cards.forEach(card => {
    card.style.willChange = 'transform';
  });
}

// Load when user hovers over desktop
$('desktopCards').addEventListener('mouseenter', lazyLoadDesktopCards, {once: true});
setTimeout(lazyLoadDesktopCards, 2000); // Fallback: load after 2s
function sfx(name){
  try{
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.connect(g); g.connect(audioCtx.destination);
    const now = audioCtx.currentTime;
    if(name==='click'){ o.type='square'; o.frequency.setValueAtTime(1000,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.08, now+0.005); g.gain.exponentialRampToValueAtTime(0.0001, now+0.15); }
    else if(name==='open'){ o.type='sine'; o.frequency.setValueAtTime(600,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.09, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.25); }
    else if(name==='close'){ o.type='sine'; o.frequency.setValueAtTime(250,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.08, now+0.005); g.gain.exponentialRampToValueAtTime(0.0001, now+0.18); }
    else if(name==='error'){ o.type='sawtooth'; o.frequency.setValueAtTime(180,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.12, now+0.005); g.gain.exponentialRampToValueAtTime(0.0001, now+0.35); }
    else if(name==='save'){ o.type='triangle'; o.frequency.setValueAtTime(900,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.07, now+0.005); g.gain.exponentialRampToValueAtTime(0.0001, now+0.2); }
    o.start(now); o.stop(now+0.5);
  }catch(e){}
}

// Clock
function tick(){$('clock').textContent=new Date().toLocaleTimeString([],{hour:'2-digit',minute:'2-digit'})}
tick();setInterval(tick,1000);

// Wallpaper
function applyWall(){
  const w=localStorage.getItem('wall')||'dark';
  const walls={
    dark:'linear-gradient(135deg,#071124,#0f172a)',
    ocean:'linear-gradient(135deg,#0c4a6e,#0ea5e9)',
    purple:'linear-gradient(135deg,#1e1b4b,#7c3aed)',
    sunset:'linear-gradient(135deg,#7c2d12,#f97316)',
    forest:'linear-gradient(135deg,#064e3b,#10b981)',
    space:'linear-gradient(135deg,#1e1b4b,#312e81)',
    fire:'linear-gradient(135deg,#7f1d1d,#dc2626)',
    ice:'linear-gradient(135deg,#0e7490,#22d3ee)',
    lavender:'linear-gradient(135deg,#4c1d95,#8b5cf6)',
    mint:'linear-gradient(135deg,#065f46,#34d399)',
    rose:'linear-gradient(135deg,#831843,#f472b6)',
    amber:'linear-gradient(135deg,#78350f,#f59e0b)',
    cyan:'linear-gradient(135deg,#155e75,#06b6d4)',
    emerald:'linear-gradient(135deg,#064e3b,#10b981)',
    violet:'linear-gradient(135deg,#4c1d95,#8b5cf6)',
    custom: localStorage.getItem('customWallpaper') || 'linear-gradient(135deg,#071124,#0f172a)'
  };
  
  if (w === 'custom' && localStorage.getItem('customWallpaper')) {
    $('wallpaper').style.backgroundImage = `url(${localStorage.getItem('customWallpaper')})`;
  } else {
    $('wallpaper').style.backgroundImage = walls[w] || walls.dark;
  }
}
applyWall();

// Start menu
$('startBtn').onclick=e=>{e.stopPropagation();startMenu.classList.toggle('open');sfx('click')};
window.addEventListener('click', e => {
  if (!startMenu.contains(e.target) && e.target !== $('startBtn')) startMenu.classList.remove('open');
});

// Desktop & start menu apps
$('desktopCards').onclick=e=>{const c=e.target.closest('.app-card');if(c){sfx('click');openApp(c.dataset.app)}}
$('appsGrid').onclick=e=>{const c=e.target.closest('.app-card-small');if(c){sfx('click');openApp(c.dataset.app);startMenu.classList.remove('open')}}

// Taskbar clicks
taskList.onclick=e=>{const t=e.target.closest('.task-item');if(t){const w=$(t.dataset.win);if(w){w.style.display='flex';w.classList.remove('minimizing');focus(w);sfx('open')}}};

// Make window
function makeWin(title,w,h,content){
  const id='w'+(++winCount);
  const win=document.createElement('div');
  win.className='window';win.id=id;
  win.style.cssText=`width:${w}px;height:${h}px;left:${50+winCount*20}px;top:${50+winCount*20}px;z-index:${++zIdx}`;
  win.innerHTML=`<div class="win-title"><span class="title">${title}</span><div class="win-controls"><button data-act="min">‚àí</button><button data-act="max">‚ñ°</button><button data-act="close">√ó</button></div></div><div class="win-body">${content}</div><div class="resizer">‚Üï</div>`;
  windowsEl.appendChild(win);
  
  const task=document.createElement('div');
  task.className='task-item';task.textContent=title;task.dataset.win=id;
  taskList.appendChild(task);
  winTasks.set(id,task);
  
  win.querySelectorAll('[data-act]').forEach(b=>b.onclick=()=>ctrl(b.dataset.act,win));
  
  let drag=false,sx,sy,ox,oy;
  const tb=win.querySelector('.win-title');
  tb.onmousedown=e=>{
    if(e.target.closest('.win-controls'))return;
    drag=true;
    sx=e.clientX;
    sy=e.clientY;
    ox=parseInt(win.style.left);
    oy=parseInt(win.style.top);
    focus(win);
  };
  window.addEventListener('mousemove',e=>{
    if(drag){
      // Calculate new position
      let newLeft = ox+e.clientX-sx;
      let newTop = oy+e.clientY-sy;
      
      // PREVENT GOING OFF SCREEN
      const minTop = 0;
      const minLeft = -win.offsetWidth + 100;
      const maxLeft = window.innerWidth - 100;
      const maxTop = window.innerHeight - 100;
      
      // Clamp values
      newLeft = Math.max(minLeft, Math.min(newLeft, maxLeft));
      newTop = Math.max(minTop, Math.min(newTop, maxTop));
      
      win.style.left = newLeft + 'px';
      win.style.top = newTop + 'px';
    }
  });
  window.addEventListener('mouseup',()=>drag=false);
  
  let rsz=false,rw,rh,rx,ry;
  const rs=win.querySelector('.resizer');
  rs.onmousedown=e=>{rsz=true;rw=win.offsetWidth;rh=win.offsetHeight;rx=e.clientX;ry=e.clientY;e.preventDefault()};
  window.addEventListener('mousemove',e=>{if(rsz){win.style.width=Math.max(200,rw+e.clientX-rx)+'px';win.style.height=Math.max(150,rh+e.clientY-ry)+'px'}});
  window.addEventListener('mouseup',()=>rsz=false);
  
  focus(win);
  sfx('open');
  return win;
}
function ctrl(act,win){
  const task=winTasks.get(win.id);
  if(act==='close'){
    win.classList.add('closing');
    sfx('close');
    setTimeout(()=>{win.remove();if(task)task.remove();winTasks.delete(win.id)},150);
  }else if(act==='min'){
    win.classList.add('minimizing');
    sfx('click');
    setTimeout(()=>{win.style.display='none';if(task)task.classList.remove('active')},200);
  }else if(act==='max'){
    if(win.dataset.max==='1'){
      win.style.cssText=`width:${win.dataset.ow};height:${win.dataset.oh};left:${win.dataset.ox};top:${win.dataset.oy};z-index:${++zIdx}`;
      win.dataset.max='0';
    }else{
      win.dataset.ow=win.style.width;win.dataset.oh=win.style.height;win.dataset.ox=win.style.left;win.dataset.oy=win.style.top;
      win.style.cssText=`left:0;top:0;width:100%;height:calc(100vh - 46px);z-index:${++zIdx}`;
      win.dataset.max='1';
    }
  }
}
window.makeWin = makeWin;

function focus(win){
  document.querySelectorAll('.window').forEach(w=>w.style.zIndex=10);
  document.querySelectorAll('.task-item').forEach(t=>t.classList.remove('active'));
  win.style.zIndex=++zIdx;
  const task=winTasks.get(win.id);if(task)task.classList.add('active');
}

// ---------------- Filesystem ----------------





// ---------------- APPS ----------------
function openApp(name){
  console.log('Opening app:', name); // Debug line
  
  const apps = {
    explorer: openExplorer,
    editor: openEditor,
    terminal: openTerminal,
    paint: openPaint,
    snake: openSnake,
    calculator: openCalc,
    settings: openSettings,
    about: openAbout,
    browser: openBrowser,
    imageviewer: openImageViewer,
    flappybird: openFlappyBird,
    spaceinvaders: openSpaceInvaders,
    games: openGames,
    game2048: open2048,
    pong: openPong,
	dino: openDino,
	tetris: openTetris,
    music: openMusicPlayer,
    video: openVideoPlayer,
    screenshot: openScreenshotTool,
	chat:openChat
  };
  
  if (apps[name]) {
    console.log('App function found, calling it...'); // Debug line
    apps[name]();
  } else {
    console.log('App not found:', name); // Debug line
    showNotification('Error', `App "${name}" not found`, 'error', 3000);
  }
}


// Explorer
// Explorer - Windows-style file manager
function openExplorer(startPath = "/"){
  const fs = getFS();
  let currentPath = startPath === "/" ? "/" : startPath;
  let history = ["/"];
  let historyIndex = 0;
  
  const winHtml = `
    <div style="display:flex;flex-direction:column;height:100%;background:var(--bg)">
      <div style="display:flex;align-items:center;gap:8px;padding:12px;background:rgba(255,255,255,0.03);border-bottom:1px solid rgba(255,255,255,0.05);flex-wrap:wrap">
        <button class="btn" id="btnBack" style="background:rgba(255,255,255,0.08);padding:6px 10px">‚óÄ Back</button>
        <button class="btn" id="btnForward" style="background:rgba(255,255,255,0.08);padding:6px 10px">‚ñ∂ Forward</button>
        <button class="btn" id="btnUp" style="background:rgba(255,255,255,0.08);padding:6px 10px">‚¨Ü Up</button>
        <button class="btn" id="btnHome" style="background:rgba(255,255,255,0.08);padding:6px 10px">üè† Home</button>
        <div style="flex:1"></div>
        <input type="file" id="fileImporter" multiple style="display:none" />
        <button class="btn" id="btnImport" style="padding:6px 10px">üìÅ Import</button>
        <button class="btn" id="btnNewFolder" style="padding:6px 10px">üìÇ New Folder</button>
        <button class="btn" id="btnRefresh" style="background:rgba(255,255,255,0.06);padding:6px 10px">üîÑ Refresh</button>
      </div>
      
      <div style="display:flex;align-items:center;gap:8px;padding:10px 12px;background:rgba(255,255,255,0.02);border-bottom:1px solid rgba(255,255,255,0.05);font-size:12px">
        <span style="color:var(--muted)">üìç</span>
        <div id="breadcrumbs" style="flex:1;display:flex;align-items:center;gap:4px;overflow-x:auto"></div>
      </div>
      
      <div style="display:flex;flex:1;overflow:hidden;gap:10px;padding:10px">
        <div style="width:160px; background:rgba(255,255,255,0.02); border-radius:8px; padding:10px; overflow-y:auto; border:1px solid rgba(255,255,255,0.05); position:relative; z-index:50;">
          <div style="font-size:11px;font-weight:600;color:var(--muted);text-transform:uppercase;margin-bottom:8px">Quick Access</div>
          <div class="sidebarBtn" data-path="/" style="padding:10px 12px;border-radius:6px;cursor:pointer;font-size:13px;transition:all 0.15s;display:flex;align-items:center;gap:8px;user-select:none">üè† This PC</div>
          <div class="sidebarBtn" data-path="/Downloads" style="padding:10px 12px;border-radius:6px;cursor:pointer;font-size:13px;transition:all 0.15s;display:flex;align-items:center;gap:8px;user-select:none">üì• Downloads</div>
          <div class="sidebarBtn" data-path="/Documents" style="padding:10px 12px;border-radius:6px;cursor:pointer;font-size:13px;transition:all 0.15s;display:flex;align-items:center;gap:8px;user-select:none">üìÑ Documents</div>
          <div class="sidebarBtn" data-path="/Music" style="padding:10px 12px;border-radius:6px;cursor:pointer;font-size:13px;transition:all 0.15s;display:flex;align-items:center;gap:8px;user-select:none">üéµ Music</div>
          <div class="sidebarBtn" data-path="/Videos" style="padding:10px 12px;border-radius:6px;cursor:pointer;font-size:13px;transition:all 0.15s;display:flex;align-items:center;gap:8px;user-select:none">üé¨ Videos</div>
          <div class="sidebarBtn" data-path="/Pictures" style="padding:10px 12px;border-radius:6px;cursor:pointer;font-size:13px;transition:all 0.15s;display:flex;align-items:center;gap:8px;user-select:none">üñºÔ∏è Pictures</div>
        </div>
        
        <div id="fileList" style="flex:1;overflow:auto;background:rgba(255,255,255,0.01);border-radius:8px;border:1px solid rgba(255,255,255,0.05);padding:10px;display:flex;flex-direction:column;gap:6px"></div>
      </div>
    </div>
  `;
  
  const win = window.makeWin('File Explorer', 900, 550, winHtml);
  // Make sidebar accept drag events above file list
win.querySelectorAll('.sidebarBtn').forEach(btn => {
  btn.style.position = "relative";
  btn.style.zIndex = "20";
});

  const fileListEl = win.querySelector('#fileList');
  const breadcrumbsEl = win.querySelector('#breadcrumbs');
  let draggedItem = null;
  
  function renderBreadcrumbs() {
    breadcrumbsEl.innerHTML = '';
    
    if(currentPath === "/") {
      const crumb = document.createElement('span');
      crumb.textContent = 'This PC';
      crumb.style.cssText = 'padding:4px 8px;cursor:pointer;border-radius:4px;background:rgba(59,130,246,0.1);color:var(--accent)';
      breadcrumbsEl.appendChild(crumb);
      return;
    }
    
    const parts = currentPath.split('/'). filter(p => p);
    let accumulated = '';
    
    const rootCrumb = document.createElement('span');
    rootCrumb. textContent = 'This PC';
    rootCrumb.style.cssText = 'padding:4px 8px;cursor:pointer;border-radius:4px;transition:all 0.15s';
    rootCrumb.onclick = () => navigate('/');
    rootCrumb.onmouseover = () => rootCrumb.style.background = 'rgba(59,130,246,0.2)';
    rootCrumb.onmouseout = () => rootCrumb.style.background = '';
    breadcrumbsEl.appendChild(rootCrumb);
    
    parts.forEach((part, idx) => {
      accumulated += '/' + part;
      
      const sep = document.createElement('span');
      sep.textContent = '‚Ä∫';
      sep.style.color = 'var(--muted)';
      sep.style.opacity = '0.5';
      breadcrumbsEl.appendChild(sep);
      
      const crumb = document.createElement('span');
      crumb.textContent = part;
      crumb.dataset.path = accumulated;
      const isLast = idx === parts.length - 1;
      crumb.style.cssText = 'padding:4px 8px;cursor:pointer;border-radius:4px;transition:all 0.15s;' + (isLast ? 'color:var(--accent);font-weight:600;background:rgba(59,130,246,0.1)' : '');
      crumb.onclick = () => navigate(crumb.dataset.path);
      crumb.onmouseover = () => { if(!isLast) crumb. style.background = 'rgba(59,130,246,0. 2)'; };
      crumb.onmouseout = () => { if(!isLast) crumb.style. background = ''; };
      breadcrumbsEl.appendChild(crumb);
    });
  }
  
  function navigate(path) {
    currentPath = path;
    history = history.slice(0, historyIndex + 1);
    history.push(path);
    historyIndex = history.length - 1;
    render();
  }
  
  function createFileItem(name, itemPath, entry) {
    const item = document.createElement('div');
    item.draggable = true;
    item.style.cssText = 'display:flex;align-items:center;padding:12px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);border-radius:8px;cursor:pointer;transition:all 0.15s;user-select:none';
    
    const isFolder = entry.type === 'dir';
    let icon = 'üìÑ';
    if(isFolder) icon = 'üìÅ';
    else if(entry.mime && entry.mime.startsWith('image/')) icon = 'üñºÔ∏è';
    else if(entry.mime && entry.mime. startsWith('audio/')) icon = 'üéµ';
    else if(entry. mime && entry.mime.startsWith('video/')) icon = 'üé¨';
    
    const sizeText = isFolder ? 'Folder' : (entry.data ?  Math.ceil(entry.data. length / 1024) + ' KB' : '0 KB');
    
        // inside createFileItem(...)
    item.innerHTML = `
      <div style="font-size:28px;width:40px;text-align:center;margin-right:12px">${icon}</div>
      <div style="flex:1;min-width:0">
        <div style="font-weight:600;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${name}</div>
        <div style="font-size:11px;color:var(--muted)">${sizeText}</div>
      </div>
      <div style="display:flex;gap:6px;opacity:0;transition:opacity 0.15s" class="actions">
        <button class="act-open" style="padding:4px 8px;background:rgba(59,130,246,0.2);border:none;border-radius:4px;color:inherit;cursor:pointer;font-size:11px">Open</button>
        <button class="act-delete" style="padding:4px 8px;background:rgba(239,68,68,0.2);border:none;border-radius:4px;color:inherit;cursor:pointer;font-size:11px">Delete</button>
        ${entry.mime && entry.mime.startsWith('image/') ? `<button class="act-export" style="padding:4px 8px;background:rgba(16,185,129,0.12);border:none;border-radius:4px;color:inherit;cursor:pointer;font-size:11px">Export</button>` : ''}
      </div>
    `;

    
    item.onmouseover = () => {
      item.style.background = 'rgba(255,255,255,0.08)';
      item.querySelector('.actions').style.opacity = '1';
    };
    item.onmouseout = () => {
      item.style.background = 'rgba(255,255,255,0.03)';
      item.querySelector('.actions'). style.opacity = '0';
    };
    
    item. onclick = e => {
      if(e.target.closest('.actions')) return;
      if(isFolder) navigate(itemPath);
      else if(entry.mime && entry.mime.startsWith('image/')) openImageViewer(itemPath);
      else if(entry.mime && entry. mime.startsWith('audio/')) openMusicPlayer(itemPath);
      else if(entry.mime && entry.mime.startsWith('video/')) openVideoPlayer(itemPath);
      else openEditor(itemPath, currentPath);
    };
    
    const actionBtns = item.querySelectorAll('.actions button');
    actionBtns[0].onclick = e => {
      e.stopPropagation();
      if(isFolder) navigate(itemPath);
      else if(entry. mime && entry.mime.startsWith('image/')) openImageViewer(itemPath);
      else openEditor(itemPath, currentPath);
    };
    
    actionBtns[1].onclick = e => {
      e.stopPropagation();
      if(confirm('Delete ' + name + '?')) {
        const parentPath = currentPath === "/" ? "/" : currentPath;
        if(fs[parentPath] && fs[parentPath].children) {
          const idx = fs[parentPath].children. indexOf(name);
          if(idx >= 0) fs[parentPath]. children.splice(idx, 1);
        }
        delete fs[itemPath];
        setFS(fs);
        showNotification('Deleted', name + ' removed', 'warning', 2500);
        render();
      }
    };
    const exportBtn = item.querySelector('.act-export');
    if (exportBtn) {
      exportBtn.onclick = (e) => {
        e.stopPropagation();
        const fs = getFS();
        const file = fs[itemPath];
        if(!file || !file.data) {
          showNotification('Export Failed', 'File data missing', 'error', 2500);
          return;
        }
        // download the data URL
        const a = document.createElement('a');
        a.href = file.data;
        a.download = name;
        a.click();
        showNotification('Exported', name + ' downloaded', 'success', 2500);
      };
    }
    
    item.ondragstart = () => {
      draggedItem = itemPath;
      e.dataTransfer.effectAllowed = "move";
      item.style.opacity = '0.5';
    };
    item.ondragend = () => item.style.opacity = '1';
    item.ondragover = e => {
      e.preventDefault();
      if(isFolder && draggedItem && draggedItem !== itemPath) {
        item.style.background = 'rgba(59,130,246,0.3)';
      }
    };
    item.ondragleave = () => item.style.background = 'rgba(255,255,255,0.03)';
    item.ondrop = e => {
      e. preventDefault();
      item.style.background = 'rgba(255,255,255,0.03)';
      if(isFolder && draggedItem && draggedItem !== itemPath) {
        const dragName = draggedItem.split('/'). pop();
        const newPath = itemPath + '/' + dragName;
        if(! fs[newPath]) {
          fs[newPath] = fs[draggedItem];
          if(fs[itemPath] && fs[itemPath].children) fs[itemPath].children.push(dragName);
          const oldParent = draggedItem.split('/').slice(0, -1).join('/') || '/';
          if(fs[oldParent] && fs[oldParent].children) {
            const idx = fs[oldParent].children.indexOf(dragName);
            if(idx >= 0) fs[oldParent].children.splice(idx, 1);
          }
          delete fs[draggedItem];
          setFS(fs);
          showNotification('Moved', dragName + ' moved', 'success', 2000);
          render();
        }
      }
      draggedItem = null;
    };
    
    return item;
  }
  
  function render() {
    renderBreadcrumbs();
    fileListEl.innerHTML = '';
    
    const currentDir = fs[currentPath === "/" ? "/" : currentPath];
    
    if(! currentDir || ! currentDir.children) {
      fileListEl.innerHTML = '<div style="display:flex;flex-direction:column;align-items:center;justify-content:center;height:100%;color:var(--muted);text-align:center"><div style="font-size:48px;margin-bottom:16px;opacity:0.3">üìÅ</div><div>Empty Folder</div><div style="font-size:11px;margin-top:8px">Drag files here or use Import button</div></div>';
      return;
    }
    
    const fragment = document.createDocumentFragment();
    
    if(currentPath !== "/") {
      const upItem = document.createElement('div');
      upItem.style.cssText = 'display:flex;align-items:center;padding:12px;background:rgba(255,255,255,0.03);border:1px solid rgba(255,255,255,0.08);border-radius:8px;cursor:pointer;transition:all 0. 15s';
      upItem.innerHTML = '<div style="font-size:28px;width:40px;text-align:center;margin-right:12px">üìÇ</div><div style="flex:1"><div style="font-weight:600;font-size:13px">..</div><div style="font-size:11px;color:var(--muted)">Parent Folder</div></div>';
      upItem.onmouseover = () => upItem.style.background = 'rgba(255,255,255,0.08)';
      upItem.onmouseout = () => upItem.style.background = 'rgba(255,255,255,0.03)';
      upItem.onclick = () => {
        const parts = currentPath.split('/'). filter(p => p);
        parts.pop();
        navigate(parts.length ? '/' + parts.join('/') : '/');
      };
      fragment.appendChild(upItem);
    }
    
    const children = currentDir.children || [];
    children.forEach(name => {
      const itemPath = currentPath === "/" ? "/" + name : currentPath + "/" + name;
      const entry = fs[itemPath];
      if(! entry) return;
      const item = createFileItem(name, itemPath, entry);
      fragment.appendChild(item);
    });
    
    fileListEl. appendChild(fragment);
  }
  
  // SETUP ALL BUTTON HANDLERS
  win.querySelector('#btnBack').onclick = () => {
    if(historyIndex > 0) {
      historyIndex--;
      currentPath = history[historyIndex];
      render();
    }
  };
 win.querySelectorAll('.sidebarBtn').forEach(side => {

    // CLICK WORKS AGAIN
    side.onclick = () => navigate(side.dataset.path);

    // allow drop
    side.ondragover = e => {
        e.preventDefault();
        e.dataTransfer.dropEffect = "move";
        side.style.background = 'rgba(59,130,246,0.25)';
    };

    side.ondragenter = e => {
        e.preventDefault();
        side.style.background = 'rgba(59,130,246,0.35)';
    };

    side.ondragleave = () => {
        side.style.background = '';
    };

    side.ondrop = e => {
        e.preventDefault();
        e.stopPropagation();
        side.style.background = '';

        if (!draggedItem) return;

        const fs = getFS();
        const dest = side.dataset.path;

        const name = draggedItem.split("/").pop();
        const newPath = dest === "/" ? "/" + name : dest + "/" + name;

        if (!fs[dest]) fs[dest] = { type:"dir", children:[] };

        if (!fs[newPath]) {
            fs[newPath] = fs[draggedItem];

            const old = draggedItem.split("/").slice(0,-1).join("/") || "/";
            fs[old].children = fs[old].children.filter(n => n !== name);
            fs[dest].children.push(name);

            delete fs[draggedItem];
            setFS(fs);
            render();
        }

        draggedItem = null;
    };

    // FIX CLICK BLOCKED AFTER DND
    side.onmouseup = () => {
        side.style.pointerEvents = "auto";
    };

});


  
  win.querySelector('#btnForward').onclick = () => {
    if(historyIndex < history.length - 1) {
      historyIndex++;
      currentPath = history[historyIndex];
      render();
    }
  };
  
  win.querySelector('#btnUp').onclick = () => {
    const parts = currentPath.split('/'). filter(p => p);
    parts.pop();
    navigate(parts.length ? '/' + parts.join('/') : '/');
  };
  
  win.querySelector('#btnHome').onclick = () => navigate('/');
  win.querySelector('#btnRefresh').onclick = () => render();
  
  win.querySelector('#btnNewFolder').onclick = () => {
    const name = prompt('Folder name');
    if(! name) return;
    const folderPath = currentPath === "/" ?  "/" + name : currentPath + "/" + name;
    if(fs[folderPath]) {
      alert('Already exists');
      return;
    }
    fs[folderPath] = { type: 'dir', children: [] };
    if(! fs[currentPath]) fs[currentPath] = { type: 'dir', children: [] };
    fs[currentPath].children. push(name);
    setFS(fs);
    showNotification('Created', name + ' folder created', 'success', 2500);
    render();
  };
  
  const importer = win.querySelector('#fileImporter');
  win.querySelector('#btnImport').onclick = () => importer.click();
  
  importer.onchange = async e => {
    const files = Array.from(e.target.files || []);
    for(const file of files) {
      const reader = new FileReader();
      await new Promise(res => {
        reader.onload = () => {
          const filePath = currentPath === "/" ? "/" + file. name : currentPath + "/" + file.name;
          fs[filePath] = { type: 'file', mime: file.type || 'application/octet-stream', data: reader.result };
          if(! fs[currentPath]) fs[currentPath] = { type: 'dir', children: [] };
          if(! fs[currentPath].children. includes(file.name)) fs[currentPath].children.push(file.name);
          res();
        };
        reader. readAsDataURL(file);
      });
    }
    setFS(fs);
    fileListEl.appendChild(fragment);
    showNotification('Import', files.length + ' files imported', 'success', 3000);
    render();
  };
  
  // FIXED: Sidebar buttons NOW WORK
  // --- ENABLE DROP ON SIDEBAR SHORTCUTS ---
win.querySelectorAll('.sidebarBtn').forEach(side => {

  // Allow drop
  side.ondragover = e => {
    e.preventDefault();
    side.style.background = 'rgba(59,130,246,0.3)';
  };

  side.ondragleave = () => {
    side.style.background = '';
  };

  side.ondrop = e => {
    e.preventDefault();
    side.style.background = '';

    if (!draggedItem) return;

    const dest = side.dataset.path;   // "/Documents" etc.
    const fs = getFS();
    const dragName = draggedItem.split('/').pop();
    const newPath = dest === "/" ? "/" + dragName : dest + "/" + dragName;

    // Create target folder if missing
    if (!fs[dest]) fs[dest] = { type: 'dir', children: [] };

    // Move file
    if (!fs[newPath]) {
      fs[newPath] = fs[draggedItem];

      // Add to new folder
      fs[dest].children.push(dragName);

      // Remove from old folder
      const oldParent = draggedItem.split("/").slice(0, -1).join("/") || "/";
      const idx = fs[oldParent].children.indexOf(dragName);
      if (idx >= 0) fs[oldParent].children.splice(idx, 1);

      delete fs[draggedItem];
      setFS(fs);
      showNotification('Moved', dragName + ' moved to ' + dest, 'success', 2500);
      render();
    }

    draggedItem = null;
  };
});

  
  render();
  return win;
}



// Editor
// Editor - FIXED to save to Documents folder

    
async function openEditor(name='', saveLocation=''){
  console.log('üìù openEditor called with:', {name, saveLocation});
  const fs = await getFS();
  const content = fs[name] ?   (fs[name].data || fs[name]) : '';

  
  // DETERMINE SAVE LOCATION
  let defaultSaveLocation = saveLocation || '/Documents/';
  
  const win=makeWin('Editor',600,420,`
    <div style="display:flex;flex-direction:column;height:100%">
      <div style="display:flex;gap:6px;margin-bottom:8px;align-items:center">
        <input class="input" id="fname" value="${name||'untitled. txt'}" style="flex:1" placeholder="filename">
        <div class="small" style="color:var(--muted);padding:0 8px">üìÅ ${defaultSaveLocation}</div>
        <button class="btn" id="saveF">üíæ Save</button>
      </div>
      <textarea id="farea" style="flex:1;background:rgba(0,0,0,0.3);border:1px solid rgba(255,255,255,0.05);border-radius:6px;color:inherit;padding:8px;resize:none">${content}</textarea>
    </div>
  `);
  
  win.querySelector('#saveF').onclick=async ()=>{
    const fsObj = await getFS();
    const fileName = win.querySelector('#fname').value||'untitled.txt';
    
    // IMPORTANT: Use saveLocation if provided (not empty and not default)
    let filePath;
    if (name && name. includes('/')) {
      // Editing existing file - keep original path
      filePath = name;
    } else if (saveLocation && saveLocation !== '/' && saveLocation !== '/Documents/') {
      // Use provided location (from sidebar click)
      filePath = saveLocation === '/' ? '/' + fileName : saveLocation + '/' + fileName;
    } else {
      // Default to Documents
      filePath = '/Documents/' + fileName;
    }
    
    console.log('Saving to:', filePath, 'saveLocation was:', saveLocation); // DEBUG
    
    // Save the file content
    fsObj[filePath] = { 
      type: 'file', 
      mime: 'text/plain', 
      data: win.querySelector('#farea').value 
    };
    
    // Ensure the parent folder exists
    const parentPath = filePath.split('/').slice(0, -1).join('/') || '/';
    if (!  fsObj[parentPath]) {
      fsObj[parentPath] = { type: 'dir', children: [] };
    }
    
    // Add to parent folder's children
    const fileName_only = filePath.split('/').pop();
    if (!  fsObj[parentPath].children. includes(fileName_only)) {
      fsObj[parentPath].children.push(fileName_only);
    }
    
    await setFS(fsObj);
    showNotification('File Saved', `${fileName} was saved to ${parentPath}`, 'success', 4000);
    sfx('save');
    ctrl('close', win); // Close editor after saving
  };
}


// Terminal
function openTerminal(){
  const win=makeWin('Terminal',550,340,`<div style="background:#000;height:100%;border-radius:6px;padding:8px;display:flex;flex-direction:column"><div id="tout" style="flex:1;overflow:auto;font-family:monospace;font-size:12px;white-space:pre-wrap;color:#0f0"></div><div style="display:flex;gap:6px;margin-top:6px"><input class="input" id="tin" style="flex:1;background:#111;font-family:monospace"><button class="btn" id="trun">Run</button></div></div>`);
  const out=win.querySelector('#tout'),inp=win.querySelector('#tin');
  const run=()=>{const cmd=inp.value.trim();if(!cmd)return;out.innerHTML+=`> ${cmd}\n`;exec(cmd,out);inp.value='';out.scrollTop=out.scrollHeight};
  win.querySelector('#trun').onclick=run;
  inp.onkeydown=e=>{if(e.key==='Enter')run()};
}

function exec(cmd,out){
  const p=cmd.split(' ').filter(Boolean),c=p[0];
  const fs=getFS();
  if(!c)return;
  if(c==='help'){
    out.innerHTML+='Commands: help, ls, cat, rm, touch, write, open, img, echo, clear, date, apps, theme, paint, snake, calc, weather, time, whoami, pwd, find, copy, rename, size, stats, export\n';
  }
  else if(c==='ls')out.innerHTML+=Object.keys(fs).join('\n')+'\n';
  else if(c==='cat'){const f=p[1];if(!f)return out.innerHTML+='Usage: cat <file>\n';if(fs[f])out.innerHTML+= (fs[f].startsWith && fs[f].startsWith('data:image/')? '[image file]\n' : fs[f])+'\n'; else out.innerHTML+='No such file\n';}
  else if(c==='rm'){const f=p[1];if(!f)return out.innerHTML+='Usage: rm <file>\n';if(fs[f]){delete fs[f];setFS(fs);out.innerHTML+='Deleted '+f+'\n';}else out.innerHTML+='No such file\n';}
  else if(c==='touch'){const f=p[1];if(!f)return out.innerHTML+='Usage: touch <file>\n';fs[f]='';setFS(fs);out.innerHTML+='Created '+f+'\n';}
  else if(c==='write'){const f=p[1];if(!f)return out.innerHTML+='Usage: write <file> <text>\n';const txt=p.slice(2).join(' ');fs[f]=txt;setFS(fs);out.innerHTML+='Wrote to '+f+'\n';}
  else if(c==='open'){const f=p[1];if(!f)return out.innerHTML+='Usage: open <file>\n';if(fs[f])openEditor(f);else out.innerHTML+='No such file\n';}
  else if(c==='img'){const f=p[1];if(!f)return out.innerHTML+='Usage: img <file>\n';if(fs[f]&&fs[f].startsWith && fs[f].startsWith('data:image/')){openImageViewer(f);}else out.innerHTML+='Not an image or not found\n';}
  else if(c==='theme'){const t=p[1];if(t){localStorage.setItem('wall',t);applyWall();out.innerHTML+='Theme set to '+t+'\n';}else out.innerHTML+='Usage: theme <name>\n';}
  else if(c==='calc'){openCalc();}
  else if(c==='weather'){out.innerHTML+='Weather: Sunny, 22¬∞C\n'}
  else if(c==='time'){out.innerHTML+=new Date().toString()+'\n';}
  else if(c==='pwd'){out.innerHTML+='/home/webos\n';}
  else if(c==='find'){const term=p[1];if(!term)return out.innerHTML+='Usage: find <term>\n';const results=Object.keys(fs).filter(f=>f.includes(term));out.innerHTML+=(results.length?results.join('\n'):'No matches')+'\n';}
  else if(c==='copy'){const src=p[1],dest=p[2];if(!src||!dest)return out.innerHTML+='Usage: copy <src> <dest>\n';if(fs[src]){fs[dest]=fs[src];setFS(fs);out.innerHTML+='Copied '+src+' to '+dest+'\n';}else out.innerHTML+='Source file not found\n';}
  else if(c==='rename'){const old=p[1],newName=p[2];if(!old||!newName)return out.innerHTML+='Usage: rename <old> <new>\n';if(fs[old]){fs[newName]=fs[old];delete fs[old];setFS(fs);out.innerHTML+='Renamed '+old+' to '+newName+'\n';}else out.innerHTML+='File not found\n';}
  else if(c==='size'){const f=p[1];if(!f)return out.innerHTML+='Usage: size <file>\n';if(fs[f]){out.innerHTML+='Size: '+(fs[f].length)+' bytes\n';}else out.innerHTML+='File not found\n';}
  else if(c==='stats'){const total=Object.keys(fs).length;const totalSize=Object.values(fs).reduce((a,b)=>a+b.length,0);out.innerHTML+=`Files: ${total}, Total size: ${totalSize} bytes\n`;}
  else if(c==='export'){const data="data:text/json;charset=utf-8,"+encodeURIComponent(JSON.stringify(fs));const a=document.createElement('a');a.href=data;a.download='webos_backup.json';a.click();out.innerHTML+='Exported all files to webos_backup.json\n';}
  else if(c==='echo')out.innerHTML+=p.slice(1).join(' ')+'\n';
  else if(c==='clear')out.innerHTML='';
  else if(c==='date')out.innerHTML+=new Date()+'\n';
  else out.innerHTML+='Unknown: '+c+'\n', sfx('error');
}

// Calculator
function openCalc(){
  const win=makeWin('Calculator',280,340,`<div style="display:flex;flex-direction:column;height:100%"><input class="input" id="cDisp" style="font-size:20px;text-align:right;margin-bottom:8px" readonly><div id="cBtns" style="display:grid;grid-template-columns:repeat(4,1fr);gap:4px;flex:1"></div></div>`);
  const disp=win.querySelector('#cDisp'),btns=win.querySelector('#cBtns');
  let val='';
  ['C','¬±','%','√∑','7','8','9','√ó','4','5','6','-','1','2','3','+','0','.','‚å´','='].forEach(k=>{
    const b=document.createElement('button');
    b.className='btn';b.textContent=k;
    b.style.cssText='font-size:16px;padding:10px;background:'+([ '√∑','√ó','-','+','='].includes(k)?'#f97316':'rgba(255,255,255,0.1)');
    b.onclick=()=>{
      if(k==='C'){val='';disp.value=''}
      else if(k==='‚å´'){val=val.slice(0,-1);disp.value=val}
      else if(k==='¬±'){val=val[0]==='-'?val.slice(1):'-'+val;disp.value=val}
      else if(k==='='){try{disp.value=Function('return '+val.replace(/√ó/g,'*').replace(/√∑/g,'/'))();}catch{disp.value='Error';}}
      else{val+=k;disp.value=val}
    };
    btns.appendChild(b);
  });
}

// Browser
function openBrowser(){
  const win=makeWin('Browser',760,520,`<div style="display:flex;flex-direction:column;height:100%"><div style="display:flex;gap:6px;margin-bottom:8px;align-items:center"><button class="btn" id="backBtn" style="background:rgba(255,255,255,0.1);padding:6px 10px">‚Üê</button><button class="btn" id="fwdBtn" style="background:rgba(255,255,255,0.1);padding:6px 10px">‚Üí</button><button class="btn" id="refreshBtn" style="background:rgba(255,255,255,0.1);padding:6px 10px">‚ü≥</button><input class="input" id="browserUrl" value="https://google.com" style="flex:1" placeholder="Enter URL"><button class="btn" id="goBtn">Go</button></div><div style="display:flex;gap:6px;margin-bottom:6px;flex-wrap:wrap"><button class="btn quickLink" data-url="https://google.com" style="background:rgba(255,255,255,0.05);font-size:10px">Google</button><button class="btn quickLink" data-url="https://youtube.com" style="background:rgba(255,255,255,0.05);font-size:10px">YouTube</button><button class="btn quickLink" data-url="https://github.com" style="background:rgba(255,255,255,0.05);font-size:10px">GitHub</button><button class="btn quickLink" data-url="https://wikipedia.org" style="background:rgba(255,255,255,0.05);font-size:10px">Wikipedia</button><label style="display:flex;align-items:center;gap:4px;font-size:11px;color:var(--muted);margin-left:auto"><input type="checkbox" id="useProxy" checked>Use Proxy</label></div><iframe id="browserFrame" style="flex:1;width:100%;border:none;background:#fff;border-radius:6px"></iframe><div class="small" style="margin-top:6px;color:var(--muted);text-align:center">üöÄ Proxy enabled by default - loads any website!</div></div>`);
  const urlInput=win.querySelector('#browserUrl');
  const iframe=win.querySelector('#browserFrame');
  const goBtn=win.querySelector('#goBtn');
  const backBtn=win.querySelector('#backBtn');
  const fwdBtn=win.querySelector('#fwdBtn');
  const refreshBtn=win.querySelector('#refreshBtn');
  const useProxy=win.querySelector('#useProxy');
  
  const loadUrl=()=>{
    let url=urlInput.value.trim();
    if(!url)return;
    if(!url.startsWith('http://')&&!url.startsWith('https://')){url='https://'+url;}
    if(useProxy.checked){iframe.src='https://webos-proxy-1.onrender.com/proxy?url=' + encodeURIComponent(url);}else{iframe.src=url;}
    urlInput.value=url;
  };
  
  goBtn.onclick=loadUrl;
  urlInput.onkeydown=e=>{if(e.key==='Enter')loadUrl()};
  backBtn.onclick=()=>{try{iframe.contentWindow.history.back()}catch(e){}};
  fwdBtn.onclick=()=>{try{iframe.contentWindow.history.forward()}catch(e){}};
  refreshBtn.onclick=()=>{try{iframe.contentWindow.location.reload()}catch(e){}};
  
  win.querySelectorAll('.quickLink').forEach(btn=>{btn.onclick=()=>{urlInput.value=btn.dataset.url;loadUrl();}});
  loadUrl();
}

// ---------------- Storage Management Functions ----------------
function getStorageInfo() {
  try {
    // Calculate total storage used by filesystem
    const fs = getFS();
    let totalSize = 0;
    let fileCount = 0;
    
    for(const path in fs) {
      const entry = fs[path];
      if(entry && entry.type === 'file' && entry.data) {
        totalSize += entry.data.length;
        fileCount++;
      }
    }
    
    // Convert to MB (rough estimate)
    const usedMB = Math.round((totalSize / (1024 * 1024)) * 100) / 100;
    const maxMB = 5; // 5MB limit for demo purposes
    const percent = Math.min(100, Math.round((usedMB / maxMB) * 100));
    
    let status = 'Good';
    if(percent > 90) status = 'Critical';
    else if(percent > 70) status = 'Warning';
    
    return {
      used: usedMB,
      max: maxMB,
      percent: percent,
      files: fileCount,
      status: status
    };
  } catch(e) {
    return {
      used: 0,
      max: 5,
      percent: 0,
      files: 0,
      status: 'Good'
    };
  }
}

function cleanupStorage() {
  const fs = getFS();
  let cleanedCount = 0;
  
  // Simple cleanup: remove files that are too large or empty
  for(const path in fs) {
    const entry = fs[path];
    if(entry && entry.type === 'file') {
      // Remove empty files or very large files (>1MB)
      if(!entry.data || entry.data.length === 0 || entry.data.length > 1024 * 1024) {
        // Also remove from parent directory
        const fileName = path.split('/').pop();
        const parentPath = path.split('/').slice(0, -1).join('/') || '/';
        
        if(fs[parentPath] && Array.isArray(fs[parentPath].children)) {
          const idx = fs[parentPath].children.indexOf(fileName);
          if(idx >= 0) fs[parentPath].children.splice(idx, 1);
        }
        
        delete fs[path];
        cleanedCount++;
      }
    }
  }
  
  setFS(fs);
  
  if(cleanedCount > 0) {
    showNotification('Cleanup Complete', `Removed ${cleanedCount} files`, 'success', 3000);
  } else {
    showNotification('Cleanup', 'No files needed cleanup', 'info', 3000);
  }
}

function deleteLargeFiles() {
  const fs = getFS();
  let deletedCount = 0;
  
  for(const path in fs) {
    const entry = fs[path];
    if(entry && entry.type === 'file' && entry.data && entry.data.length > 500 * 1024) { // 500KB threshold
      const fileName = path.split('/').pop();
      const parentPath = path.split('/').slice(0, -1).join('/') || '/';
      
      if(fs[parentPath] && Array.isArray(fs[parentPath].children)) {
        const idx = fs[parentPath].children.indexOf(fileName);
        if(idx >= 0) fs[parentPath].children.splice(idx, 1);
      }
      
      delete fs[path];
      deletedCount++;
    }
  }
  
  setFS(fs);
  
  if(deletedCount > 0) {
    showNotification('Large Files Removed', `Deleted ${deletedCount} large files`, 'warning', 3000);
  } else {
    showNotification('No Large Files', 'No files over 500KB found', 'info', 3000);
  }
}

// Settings
function openSettings(){
  // Get current storage info
  const storageInfo = getStorageInfo();
  
  const win = makeWin('Settings', 450, 520, `
    <div style="padding:10px">
      <!-- Storage Management Section -->
      <div style="margin-bottom:20px">
        <b>üíæ Storage Management</b>
        <div style="background:var(--panel);padding:12px;border-radius:8px;margin-top:8px">
          <!-- Storage Bar -->
          <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
            <span class="small">Storage Usage</span>
            <span class="small" id="storagePercent">${storageInfo.percent}%</span>
          </div>
          <div style="background:#1e293b;height:12px;border-radius:6px;overflow:hidden;margin-bottom:8px">
            <div id="storageBar" style="height:100%;background:${storageInfo.percent > 90 ? '#ef4444' : storageInfo.percent > 70 ? '#f59e0b' : '#10b981'};width:${storageInfo.percent}%;transition:all 0.3s"></div>
          </div>
          <div style="display:flex;justify-content:space-between;align-items:center">
            <span class="small" id="storageUsed">${storageInfo.used}MB</span>
            <span class="small">${storageInfo.max}MB</span>
          </div>
          <div class="small" style="color:var(--muted);margin-top:6px">
            ${storageInfo.files} files ‚Ä¢ ${storageInfo.status}
          </div>
        </div>
        
        <!-- Storage Actions -->
        <div style="display:grid;grid-template-columns:1fr 1fr;gap:6px;margin-top:10px">
          <button class="btn" id="btnStorageDetails" style="background:rgba(255,255,255,0.1)">üìä Details</button>
          <button class="btn" id="btnCleanup" style="background:#f59e0b">üßπ Cleanup</button>
        </div>
      </div>

      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.1);margin:16px 0">
      
      <!-- Wallpaper Section -->
      <b>üé® Wallpaper</b>
      <div class="wallpaper-grid" id="wallpaperGrid"></div>
      <div style="margin-top:8px">
        <input type="file" id="wallpaperUpload" accept="image/*" style="display:none">
        <button class="btn" id="uploadWallpaper">Upload Custom Wallpaper</button>
      </div>
      
      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.1);margin:16px 0">
      
      <!-- Backup & Restore -->
      <b>üì¶ Backup & Restore</b>
      <div style="display:flex;gap:6px;margin-top:8px;flex-wrap:wrap">
        <button class="btn" id="exportBtn">üì§ Export All</button>
        <input type="file" id="importFile" accept=".json" style="display:none">
        <button class="btn" id="importBtn" style="background:rgba(255,255,255,0.1)">üì• Import</button>
      </div>
      
      <hr style="border:none;border-top:1px solid rgba(255,255,255,0.1);margin:16px 0">
      
      <!-- Danger Zone -->
      <b>‚ö†Ô∏è Danger Zone</b>
      <div style="display:flex;gap:6px;margin-top:8px;flex-wrap:wrap">
        <button class="btn" id="clrLargeFiles" style="background:#f59e0b">Delete Large Files</button>
        <button class="btn" id="clrFS" style="background:#ef4444">Clear All Files</button>
      </div>
    </div>
  `);

  // Update storage info in real-time
  function updateStorageDisplay() {
    const info = getStorageInfo();
    win.querySelector('#storagePercent').textContent = info.percent + '%';
    win.querySelector('#storageUsed').textContent = info.used + 'MB';
    win.querySelector('#storageBar').style.width = info.percent + '%';
    win.querySelector('#storageBar').style.background = info.percent > 90 ? '#ef4444' : info.percent > 70 ? '#f59e0b' : '#10b981';
  }

  // Storage Details Button
  win.querySelector('#btnStorageDetails').onclick = () => {
    const info = getStorageInfo();
    const fs = getFS();
    
    // Analyze file types and sizes
    const fileTypes = {};
    let totalFiles = 0;
    
    for(const path in fs) {
      const entry = fs[path];
      if(entry && entry.type === 'file') {
        totalFiles++;
        const type = entry.mime ? entry.mime.split('/')[0] : 'other';
        const size = Math.ceil(entry.data.length / 1024 / 1024 * 100) / 100; // MB
        
        if(!fileTypes[type]) fileTypes[type] = { count: 0, size: 0 };
        fileTypes[type].count++;
        fileTypes[type].size += size;
      }
    }
    
    const detailsWin = makeWin('Storage Details', 350, 400, `
      <div style="padding:10px">
        <h3>üìä Storage Analysis</h3>
        
        <!-- Summary -->
        <div style="background:var(--panel);padding:12px;border-radius:8px;margin:10px 0">
          <div style="display:grid;grid-template-columns:1fr 1fr;gap:8px;font-size:12px">
            <div>Total Files: <b>${totalFiles}</b></div>
            <div>Used Space: <b>${info.used}MB</b></div>
            <div>Available: <b>${info.max - info.used}MB</b></div>
            <div>Status: <b style="color:${info.percent > 90 ? '#ef4444' : info.percent > 70 ? '#f59e0b' : '#10b981'}">${info.status}</b></div>
          </div>
        </div>
        
        <!-- File Type Breakdown -->
        <h4>File Types</h4>
        <div style="max-height:200px;overflow-y:auto">
          ${Object.entries(fileTypes).map(([type, data]) => `
            <div style="display:flex;justify-content:space-between;align-items:center;padding:8px;background:rgba(255,255,255,0.05);margin-bottom:4px;border-radius:6px">
              <div>
                <span style="font-weight:600">${type.toUpperCase()}</span>
                <div class="small">${data.count} files</div>
              </div>
              <div style="text-align:right">
                <div style="font-weight:600">${data.size.toFixed(2)}MB</div>
                <div class="small">${Math.round((data.size/info.used)*100)}% of used</div>
              </div>
            </div>
          `).join('')}
        </div>
        
        <!-- Tips -->
        <div style="background:rgba(59,130,246,0.1);padding:10px;border-radius:6px;margin-top:10px">
          <div class="small" style="color:#3b82f6">
            üí° <b>Tips:</b> Images and documents use less space. Audio/video files consume the most storage.
          </div>
        </div>
      </div>
    `);
  };

  // Cleanup Button
  win.querySelector('#btnCleanup').onclick = () => {
    cleanupStorage();
    setTimeout(updateStorageDisplay, 1000);
  };

  // Delete Large Files
  win.querySelector('#clrLargeFiles').onclick = () => {
    deleteLargeFiles();
    setTimeout(updateStorageDisplay, 1000);
  };

  // Import Button
  win.querySelector('#importBtn').onclick = () => {
    win.querySelector('#importFile').click();
  };

  // Wallpaper grid code (keep your existing wallpaper code here)
  const wallpaperGrid = win.querySelector('#wallpaperGrid');
  const wallpapers = [
    {id: 'dark', name: 'Dark'},
    {id: 'ocean', name: 'Ocean'},
    {id: 'purple', name: 'Purple'},
    {id: 'sunset', name: 'Sunset'},
    {id: 'forest', name: 'Forest'},
    {id: 'space', name: 'Space'},
    {id: 'fire', name: 'Fire'},
    {id: 'ice', name: 'Ice'},
    {id: 'lavender', name: 'Lavender'},
    {id: 'mint', name: 'Mint'},
    {id: 'rose', name: 'Rose'},
    {id: 'amber', name: 'Amber'},
    {id: 'cyan', name: 'Cyan'},
    {id: 'emerald', name: 'Emerald'},
    {id: 'violet', name: 'Violet'},
    {id: 'custom', name: 'Custom'}
  ];
  
  const currentWall = localStorage.getItem('wall') || 'dark';
  
  wallpapers.forEach(wall => {
    const wallItem = document.createElement('div');
    wallItem.className = `wallpaper-item ${wall.id === currentWall ? 'active' : ''}`;
    wallItem.dataset.wall = wall.id;
    
    if (wall.id === 'custom') {
      wallItem.classList.add('custom');
    } else {
      const walls = {
        dark: 'linear-gradient(135deg,#071124,#0f172a)',
        ocean: 'linear-gradient(135deg,#0c4a6e,#0ea5e9)',
        purple: 'linear-gradient(135deg,#1e1b4b,#7c3aed)',
        sunset: 'linear-gradient(135deg,#7c2d12,#f97316)',
        forest: 'linear-gradient(135deg,#064e3b,#10b981)',
        space: 'linear-gradient(135deg,#1e1b4b,#312e81)',
        fire: 'linear-gradient(135deg,#7f1d1d,#dc2626)',
        ice: 'linear-gradient(135deg,#0e7490,#22d3ee)',
        lavender: 'linear-gradient(135deg,#4c1d95,#8b5cf6)',
        mint: 'linear-gradient(135deg,#065f46,#34d399)',
        rose: 'linear-gradient(135deg,#831843,#f472b6)',
        amber: 'linear-gradient(135deg,#78350f,#f59e0b)',
        cyan: 'linear-gradient(135deg,#155e75,#06b6d4)',
        emerald: 'linear-gradient(135deg,#064e3b,#10b981)',
        violet: 'linear-gradient(135deg,#4c1d95,#8b5cf6)'
      };
      wallItem.style.backgroundImage = walls[wall.id];
    }
    
    wallItem.onclick = () => {
      if (wall.id === 'custom') {
        win.querySelector('#wallpaperUpload').click();
      } else {
        localStorage.setItem('wall', wall.id);
        applyWall();
        document.querySelectorAll('.wallpaper-item').forEach(item => item.classList.remove('active'));
        wallItem.classList.add('active');
      }
    };
    
    wallpaperGrid.appendChild(wallItem);
  });
  
  // Upload custom wallpaper
  const uploadInput = win.querySelector('#wallpaperUpload');
  const uploadBtn = win.querySelector('#uploadWallpaper');
  
  uploadBtn.onclick = () => uploadInput.click();
  
  uploadInput.onchange = (e) => {
    const file = e.target.files[0];
    if (file && file.type.startsWith('image/')) {
      // Check file size (max 2MB for wallpapers)
      if (file.size > 4 * 1024 * 1024) {
        showNotification('File Too Large', 'Wallpaper must be under 2MB', 'error', 3000);
        return;
      }
      
      const reader = new FileReader();
      reader.onload = (event) => {
        localStorage.setItem('customWallpaper', event.target.result);
        localStorage.setItem('wall', 'custom');
        applyWall();
        document.querySelectorAll('.wallpaper-item').forEach(item => item.classList.remove('active'));
        document.querySelector('.wallpaper-item[data-wall="custom"]').classList.add('active');
        showNotification('Wallpaper Updated', 'Custom wallpaper applied successfully', 'success', 3000);
      };
      reader.readAsDataURL(file);
    }
  };

  // Other settings
  win.querySelector('#clrFS').onclick = () => {
    if(confirm('Are you sure? This will delete ALL files and cannot be undone!')) {
      localStorage.removeItem(FS_KEY);
      showNotification('Files Cleared', 'All files have been removed', 'warning', 4000);
      sfx('close');
      setTimeout(updateStorageDisplay, 1000);
    }
  };
  
  win.querySelector('#exportBtn').onclick = () => {
    const fs = getFS();
    const data = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(fs));
    const a = document.createElement('a');
    a.href = data;
    a.download = 'webos_backup.json';
    a.click();
    showNotification('Export Complete', 'All files exported to webos_backup.json', 'success', 4000);
  };

  // Import file handler
  win.querySelector('#importFile').onchange = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = (event) => {
      try {
        const importedFS = JSON.parse(event.target.result);
        const importedSize = new Blob([event.target.result]).size / 1024 / 1024;
        const currentInfo = getStorageInfo();
        
        if (importedSize > currentInfo.max - currentInfo.used) {
          showNotification('Import Failed', `Not enough space. Need ${importedSize.toFixed(2)}MB, only ${(currentInfo.max - currentInfo.used).toFixed(2)}MB available`, 'error', 5000);
          return;
        }
        
        if (confirm(`Import backup? This will add ${importedSize.toFixed(2)}MB of data.`)) {
          const currentFS = getFS();
          // Merge file systems
          const mergedFS = { ...currentFS, ...importedFS };
          setFS(mergedFS);
          showNotification('Import Complete', 'Backup imported successfully', 'success', 4000);
          setTimeout(updateStorageDisplay, 1000);
        }
      } catch (error) {
        showNotification('Import Failed', 'Invalid backup file', 'error', 4000);
      }
    };
    reader.readAsText(file);
  };
}

function openAbout(){
  makeWin('About',210,145,`<div style="text-align:center"><h3 style="margin:0 0 8px">WebOS</h3><p class="small">A browser-based OS simulation</p><p class="small">made by Ilyes</p></div>`);
}

// Paint (FIXED: Now draws where cursor actually is)
function openPaint(){
  const win=makeWin('Paint',800,600,`<div style="display:flex;flex-direction:column;height:100%"><div style="display:flex;gap:8px;margin-bottom:8px;align-items:center"><input type="color" id="pColor" value="#3b82f6" style="width:36px;height:28px;border:none;cursor:pointer"><input type="range" id="pSize" min="2" max="40" value="6" style="width:80px"><span id="pSizeL" class="small">6</span><button class="btn" id="pBrush">üñåÔ∏è</button><button class="btn" id="pEraser">üßΩ</button><button class="btn" id="pClear">üóëÔ∏è</button><button class="btn" id="pSave">üíæ Save</button></div><canvas id="pCanvas" style="flex:1;background:#fff;border-radius:6px;cursor:crosshair"></canvas></div>`);
  const canvas=win.querySelector('#pCanvas'),ctx=canvas.getContext('2d');
  let painting=false,tool='brush',color='#3b82f6',size=6;
  
  function setupCanvas() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    ctx.fillStyle='#fff';
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.lineJoin = 'round';
    ctx.lineCap = 'round';
  }
  
  setTimeout(setupCanvas, 50);
  new ResizeObserver(setupCanvas).observe(canvas);
  
  win.querySelector('#pColor').oninput=e=>color=e.target.value;
  win.querySelector('#pSize').oninput=e=>{size=e.target.value;win.querySelector('#pSizeL').textContent=size};
  win.querySelector('#pBrush').onclick=()=>tool='brush';
  win.querySelector('#pEraser').onclick=()=>tool='eraser';
  win.querySelector('#pClear').onclick=()=>{ctx.fillStyle='#fff';ctx.fillRect(0,0,canvas.width,canvas.height);sfx('click');};
  
  win.querySelector('#pSave').onclick=()=>{
    const data = canvas.toDataURL('image/png');
    const fs=getFS();
    let i=1; let name='image.png';
    while(fs[name]){name = 'image-'+(i++)+'.png'}
    fs[name]=data; setFS(fs);
    showNotification('Image Saved', `${name} was saved to files`, 'success', 4000);
    sfx('save');
  };
  
  function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    return {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };
  }
  
  canvas.onmousedown=e=>{
    painting=true;
    const pos = getMousePos(e);
    ctx.beginPath();
    ctx.moveTo(pos.x, pos.y);
    ctx.strokeStyle = tool==='eraser'?'#fff':color;
    ctx.lineWidth = size;
  };
  
  canvas.onmousemove=e=>{
    if(!painting) return;
    const pos = getMousePos(e);
    ctx.lineTo(pos.x, pos.y);
    ctx.stroke();
  };
  
  canvas.onmouseup=canvas.onmouseleave=()=>painting=false;
}

// Image Viewer
// Image Viewer - FIXED to show correct images
function openImageViewer(nameOrNull){
  const fs = getFS();
  
  // Get ALL image files from the filesystem
  let filenames = [];
  for(const key in fs){
    if(fs[key] && fs[key].type === 'file' && 
       fs[key].mime && fs[key].mime.startsWith('image/') &&
       fs[key].data){
      filenames.push(key);
    }
  }
  
  if(!filenames.length){
    alert('No images found in files');
    return;
  }
  
  // Find the correct starting index
  let idx = 0;
  if(nameOrNull){
    idx = filenames.indexOf(nameOrNull);
    if(idx < 0) idx = 0; // Fallback if not found
  }
  
  const currentFile = filenames[idx];
  const content = fs[currentFile]?.data || '';
  
  const win = makeWin('Image Viewer',640,520,`
    <div style="display:flex;flex-direction:column;height:100%">
      <div style="display:flex;align-items:center;gap:8px;margin-bottom:8px">
        <button class="btn" id="imgPrev">‚Üê</button>
        <button class="btn" id="imgNext">‚Üí</button>
        <button class="btn" id="imgZoom">Zoom</button>
        <button class="btn" id="imgFit">Fit</button>
        <div style="flex:1;text-align:center" id="imgName">${currentFile.split('/').pop() || 'Image'}</div>
        <button class="btn" id="imgDel" style="background:#ef4444">Delete</button>
      </div>
      <div style="flex:1;display:flex;align-items:center;justify-content:center;overflow:auto;background:rgba(0,0,0,0.1);border-radius:6px">
        <img id="imgView" src="${content}" style="max-width:100%;max-height:100%;" onerror="this.style.display='none'" />
      </div>
      <div class="small" style="text-align:center;margin-top:8px;color:var(--muted)">
        ${idx + 1} of ${filenames.length} images
      </div>
    </div>
  `);
  
  const img = win.querySelector('#imgView');
  const nameEl = win.querySelector('#imgName');
  let zoomed = false;
  let currentIndex = idx;
  let imageList = filenames;
  
  function updateImage(){
    const file = imageList[currentIndex];
    const imgData = fs[file]?.data;
    
    if(imgData){
      img.src = imgData;
      img.style.display = 'block';
      nameEl.textContent = file.split('/').pop();
      
      // Update counter
      win.querySelector('.small:last-child').textContent = 
        `${currentIndex + 1} of ${imageList.length} images`;
    } else {
      img.style.display = 'none';
      nameEl.textContent = 'Image not found';
    }
    
    // Reset zoom when changing images
    if(zoomed){
      img.style.maxWidth = 'none';
      img.style.maxHeight = 'none';
      img.style.width = 'auto';
      img.style.height = 'auto';
    } else {
      img.style.maxWidth = '100%';
      img.style.maxHeight = '100%';
    }
  }
  
  win.querySelector('#imgPrev').onclick = () => {
    currentIndex = (currentIndex - 1 + imageList.length) % imageList.length;
    updateImage();
  };
  
  win.querySelector('#imgNext').onclick = () => {
    currentIndex = (currentIndex + 1) % imageList.length;
    updateImage();
  };
  
  win.querySelector('#imgZoom').onclick = () => {
    zoomed = !zoomed;
    if(zoomed){
      img.style.maxWidth = 'none';
      img.style.maxHeight = 'none';
      img.style.width = 'auto';
      img.style.height = 'auto';
    } else {
      img.style.maxWidth = '100%';
      img.style.maxHeight = '100%';
    }
  };
  
  win.querySelector('#imgFit').onclick = () => {
    img.style.maxWidth = '100%';
    img.style.maxHeight = '100%';
    zoomed = false;
  };
  
  win.querySelector('#imgDel').onclick = () => {
    const currentFile = imageList[currentIndex];
    if(!confirm('Delete '+ currentFile.split('/').pop() +'?')) return;
    
    const fs = getFS();
    delete fs[currentFile];
    
    // Remove from parent folder children
    const fileName = currentFile.split('/').pop();
    const parentPath = currentFile.split('/').slice(0,-1).join('/') || "/";
    if(fs[parentPath] && Array.isArray(fs[parentPath].children)){
      const idx = fs[parentPath].children.indexOf(fileName);
      if(idx >= 0) fs[parentPath].children.splice(idx,1);
    }
    
    setFS(fs);
    sfx('close');
    
    // Refresh image list and close or show next image
    const newFs = getFS();
    const newImageList = [];
    for(const key in newFs){
      if(newFs[key] && newFs[key].type === 'file' && 
         newFs[key].mime && newFs[key].mime.startsWith('image/') &&
         newFs[key].data){
        newImageList.push(key);
      }
    }
    
    if(newImageList.length === 0){
      ctrl('close',win);
      showNotification('Image Deleted', 'No images remaining', 'info', 3000);
    } else {
      imageList = newImageList;
      currentIndex = Math.min(currentIndex, imageList.length - 1);
      updateImage();
      showNotification('Image Deleted', 'Image removed successfully', 'warning', 3000);
    }
  };
  
  // Keyboard navigation
  win.onkeydown = (e) => {
    if(e.key === 'ArrowLeft') {
      currentIndex = (currentIndex - 1 + imageList.length) % imageList.length;
      updateImage();
    } else if(e.key === 'ArrowRight') {
      currentIndex = (currentIndex + 1) % imageList.length;
      updateImage();
    } else if(e.key === 'Escape') {
      ctrl('close', win);
    }
  };
  
  // Focus the window for keyboard events
  focus(win);
}


// Snake
function openSnake(){
  const win = makeWin('Snake', 400, 500,`<div style="text-align:center"><div style="margin-bottom:8px"><span class="small">Score: <b id="snScore">0</b></span> &nbsp; <span class="small">Best: <b id="snBest">0</b></span></div><canvas id="snCanvas" width="360" height="360" style="background:#0f172a;border-radius:6px"></canvas><div class="small" style="margin-top:8px">Arrow keys / WASD</div><button class="btn" id="snStart" style="margin-top:8px">Start Game</button></div>`);
  const canvas=win.querySelector('#snCanvas'),ctx=canvas.getContext('2d');
  const scoreEl=win.querySelector('#snScore'),bestEl=win.querySelector('#snBest');
  const G=15,C=20;
  let snake,dir,food,score,best=+localStorage.getItem('snakeBest')||0,running=false,loop;
  bestEl.textContent=best;
  
  function init(){
    snake=[{x:10,y:10}];dir={x:1,y:0};score=0;scoreEl.textContent=0;placeFood();running=true; if(loop)clearInterval(loop); loop=setInterval(update,100);
  }
  function placeFood(){food={x:Math.floor(Math.random()*C),y:Math.floor(Math.random()*C)} }
  function update(){
    if(!running)return;
    const head={x:snake[0].x+dir.x,y:snake[0].y+dir.y};
    if(head.x<0||head.x>=C||head.y<0||head.y>=C||snake.some(s=>s.x===head.x&&s.y===head.y)){
      running=false;clearInterval(loop); sfx('error'); 
      if(score>best){best=score;localStorage.setItem('snakeBest',best);bestEl.textContent=best;}
      return;
    }
    snake.unshift(head);
    if(head.x===food.x&&head.y===food.y){score++;scoreEl.textContent=score;placeFood(); sfx('save')} else snake.pop();
    draw();
  }
  function draw(){ctx.fillStyle='#0f172a';ctx.fillRect(0,0,300,300);ctx.fillStyle='#22c55e';snake.forEach(s=>ctx.fillRect(s.x*G,s.y*G,G-1,G-1));ctx.fillStyle='#ef4444';ctx.fillRect(food.x*G,food.y*G,G-1,G-1);}  
  win.querySelector('#snStart').onclick=init;
  window.addEventListener('keydown',e=>{if(!running)return; if((e.key==='ArrowUp'||e.key==='w')&&dir.y!==1)dir={x:0,y:-1}; else if((e.key==='ArrowDown'||e.key==='s')&&dir.y!==-1)dir={x:0,y:1}; else if((e.key==='ArrowLeft'||e.key==='a')&&dir.x!==1)dir={x:-1,y:0}; else if((e.key==='ArrowRight'||e.key==='d')&&dir.x!==-1)dir={x:1,y:0};});
  draw();
}
// Flappy Bird - SUPER FUN VERSION!
function openFlappyBird(){
  const win = makeWin('Flappy Bird', 400, 550,`<div style="display:flex;flex-direction:column;height:100%;position:relative;background:linear-gradient(180deg, #4ec0ca 0%, #4299ad 100%)"><div style="display:flex;justify-content:space-between;align-items:center;padding:12px;background:rgba(0,0,0,0.3);border-radius:8px;margin-bottom:8px"><div><div class="small" style="color:#fff">SCORE</div><div style="font-size:32px;font-weight:bold;color:#fff;text-shadow:2px 2px 4px rgba(0,0,0,0.5)" id="fbScore">0</div></div><div><div class="small" style="color:#fff">BEST</div><div style="font-size:32px;font-weight:bold;color:#fbbf24;text-shadow:2px 2px 4px rgba(0,0,0,0.5)" id="fbBest">0</div></div></div><div style="flex:1;position:relative;overflow:hidden;border-radius:8px;box-shadow:inset 0 0 20px rgba(0,0,0,0.3);display:flex;align-items:center;justify-content:center"><canvas id="fbCanvas" width="360" height="400" style="display:block;cursor:pointer"></canvas></div><div style="text-align:center;margin-top:12px;color:#fff;text-shadow:1px 1px 2px rgba(0,0,0,0.5)"><div class="small">Click or SPACE to flap! üê¶</div><button class="btn" id="fbStart" style="margin-top:8px;background:#fbbf24;color:#000;font-weight:bold;padding:10px 24px">START GAME</button></div></div>`);
  const canvas=win.querySelector('#fbCanvas');
  const ctx=canvas.getContext('2d');
  const scoreEl=win.querySelector('#fbScore');
  const bestEl=win.querySelector('#fbBest');
  const startBtn=win.querySelector('#fbStart');
  
  // Lock canvas size
  const CANVAS_WIDTH = 380;
  const CANVAS_HEIGHT = 500;
  canvas.width = CANVAS_WIDTH;
  canvas.height = CANVAS_HEIGHT;
  
  let bird, pipes, score, best, gameRunning, gravity, jumpPower, gameLoop, pipeTimer;
  best = +localStorage.getItem('flappyBest') || 0;
  bestEl.textContent = best;
  
  // Particle system for effects
  let particles = [];
  
  function init(){
    bird = {
      x: 80,
      y: 250,
      vy: 0,
      size: 20,
      rotation: 0
    };
    pipes = [];
    score = 0;
    gravity = 0.5;
    jumpPower = -9;
    gameRunning = true;
    scoreEl.textContent = 0;
    particles = [];
    
    if(gameLoop) cancelAnimationFrame(gameLoop);
    if(pipeTimer) clearInterval(pipeTimer);
    
    gameLoop = requestAnimationFrame(update);
    
    // Add new pipes periodically - FIXED spacing
    pipeTimer = setInterval(()=>{
      if(gameRunning) {
        const lastPipe = pipes[pipes.length - 1];
        // Only add pipe if last one is far enough
        if(!lastPipe || lastPipe.x < CANVAS_WIDTH - 200){
          createPipe(CANVAS_WIDTH);
        }
      }
    }, 1800);
    
    startBtn.textContent = 'RESTART';
    playSFX('start');
  }
  
  function createPipe(x){
    const gap = 150;
    const minHeight = 80;
    const maxHeight = 280;
    const topHeight = Math.random() * (maxHeight - minHeight) + minHeight;
    
    pipes.push({
      x: x,
      topHeight: topHeight,
      bottomY: topHeight + gap,
      width: 60,
      scored: false,
      color: `hsl(${Math.random()*60 + 80}, 70%, 50%)` // Random green shades
    });
  }
  
  function jump(){
    if(!gameRunning) return;
    bird.vy = jumpPower;
    bird.rotation = -25;
    
    // Create flap particles
    for(let i=0; i<8; i++){
      particles.push({
        x: bird.x - 10,
        y: bird.y + bird.size/2,
        vx: -Math.random() * 3 - 1,
        vy: Math.random() * 4 - 2,
        life: 1,
        size: Math.random() * 4 + 2,
        color: '#fff'
      });
    }
  }
  
  function update(){
    if(!gameRunning) return;
    
    // Update bird
    bird.vy += gravity;
    bird.y += bird.vy;
    
    // Rotation based on velocity
    bird.rotation = Math.min(Math.max(bird.vy * 3, -25), 90);
    
    // Update pipes
    for(let i = pipes.length - 1; i >= 0; i--){
      const pipe = pipes[i];
      pipe.x -= 3;
      
      // Score when passing pipe
      if(!pipe.scored && pipe.x + pipe.width < bird.x){
        pipe.scored = true;
        score++;
        scoreEl.textContent = score;
        playSFX('score');
        
        // Score particles
        for(let j=0; j<15; j++){
          particles.push({
            x: bird.x,
            y: bird.y,
            vx: Math.random() * 6 - 3,
            vy: Math.random() * 6 - 3,
            life: 1,
            size: Math.random() * 5 + 3,
            color: '#fbbf24'
          });
        }
        
        if(score > best){
          best = score;
          localStorage.setItem('flappyBest', best);
          bestEl.textContent = best;
        }
      }
      
      // Remove off-screen pipes
      if(pipe.x + pipe.width < 0){
        pipes.splice(i, 1);
      }
    }
    
    // Update particles
    particles = particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.2;
      p.life -= 0.02;
      return p.life > 0;
    });
    
    // Check collisions
    checkCollisions();
    
    // Draw everything
    draw();
    
    gameLoop = requestAnimationFrame(update);
  }
  
  function checkCollisions(){
    // Ground and ceiling
    if(bird.y + bird.size > CANVAS_HEIGHT - 50 || bird.y < 0){
      gameOver();
      return;
    }
    
    // Pipes
    pipes.forEach(pipe => {
      const birdRight = bird.x + bird.size;
      const birdBottom = bird.y + bird.size;
      
      if(birdRight > pipe.x && bird.x < pipe.x + pipe.width){
        if(bird.y < pipe.topHeight || birdBottom > pipe.bottomY){
          gameOver();
        }
      }
    });
  }
  
  function gameOver(){
    gameRunning = false;
    clearInterval(pipeTimer);
    playSFX('gameover');
    
    // Death explosion particles
    for(let i=0; i<30; i++){
      const angle = Math.random() * Math.PI * 2;
      const speed = Math.random() * 8 + 3;
      particles.push({
        x: bird.x + bird.size/2,
        y: bird.y + bird.size/2,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        life: 1,
        size: Math.random() * 6 + 4,
        color: '#ef4444'
      });
    }
    
    setTimeout(() => {
      const msg = score === best && score > 0 ? 
        `Game Over! NEW BEST: ${score} üèÜ` : 
        `Game Over! Score: ${score}`;
      showNotification('Flappy Bird', msg, score === best ? 'success' : 'info', 4000);
    }, 500);
  }
  
  function draw(){
    // Sky with clouds effect
    ctx.fillStyle = '#4ec0ca';
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
    
    // Clouds
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    for(let i=0; i<5; i++){
      const x = ((Date.now() * 0.01 + i * 100) % (CANVAS_WIDTH + 100)) - 50;
      ctx.beginPath();
      ctx.arc(x, 50 + i * 30, 20, 0, Math.PI * 2);
      ctx.arc(x + 20, 50 + i * 30, 25, 0, Math.PI * 2);
      ctx.arc(x + 40, 50 + i * 30, 20, 0, Math.PI * 2);
      ctx.fill();
    }
    
    // Draw pipes
    pipes.forEach(pipe => {
      // Pipe shadow
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.fillRect(pipe.x + 4, 0, pipe.width, pipe.topHeight + 4);
      ctx.fillRect(pipe.x + 4, pipe.bottomY + 4, pipe.width, CANVAS_HEIGHT - pipe.bottomY);
      
      // Top pipe
      ctx.fillStyle = pipe.color;
      ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight);
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.fillRect(pipe.x, 0, 8, pipe.topHeight);
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(pipe.x + pipe.width - 8, 0, 8, pipe.topHeight);
      
      // Bottom pipe
      ctx.fillStyle = pipe.color;
      ctx.fillRect(pipe.x, pipe.bottomY, pipe.width, CANVAS_HEIGHT - pipe.bottomY);
      ctx.fillStyle = 'rgba(0,0,0,0.2)';
      ctx.fillRect(pipe.x, pipe.bottomY, 8, CANVAS_HEIGHT - pipe.bottomY);
      ctx.fillStyle = 'rgba(255,255,255,0.2)';
      ctx.fillRect(pipe.x + pipe.width - 8, pipe.bottomY, 8, CANVAS_HEIGHT - pipe.bottomY);
      
      // Pipe caps
      ctx.fillStyle = pipe.color;
      ctx.fillRect(pipe.x - 5, pipe.topHeight - 30, pipe.width + 10, 30);
      ctx.fillRect(pipe.x - 5, pipe.bottomY, pipe.width + 10, 30);
    });
    
    // Draw particles
    particles.forEach(p => {
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
    
    // Draw bird with rotation
    ctx.save();
    ctx.translate(bird.x + bird.size/2, bird.y + bird.size/2);
    ctx.rotate(bird.rotation * Math.PI / 180);
    
    // Bird shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(-bird.size/2 + 2, -bird.size/2 + 2, bird.size, bird.size);
    
    // Bird body
    ctx.fillStyle = '#fbbf24';
    ctx.fillRect(-bird.size/2, -bird.size/2, bird.size, bird.size);
    
    // Bird eye
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(bird.size/4, -bird.size/4, 4, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.arc(bird.size/4, -bird.size/4, 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Bird beak
    ctx.fillStyle = '#f97316';
    ctx.beginPath();
    ctx.moveTo(bird.size/2, 0);
    ctx.lineTo(bird.size/2 + 8, -2);
    ctx.lineTo(bird.size/2 + 8, 2);
    ctx.fill();
    
    // Wing
    ctx.fillStyle = '#f59e0b';
    ctx.beginPath();
    ctx.ellipse(-2, 2, 8, 5, Math.sin(Date.now() * 0.01) * 0.5, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.restore();
    
    // Ground
    ctx.fillStyle = '#8b4513';
    ctx.fillRect(0, CANVAS_HEIGHT - 50, CANVAS_WIDTH, 50);
    ctx.fillStyle = '#6b3410';
    for(let i=0; i<CANVAS_WIDTH; i+=20){
      ctx.fillRect(i, CANVAS_HEIGHT - 50, 10, 50);
    }
  }
  
  // Sound effects
  function playSFX(type){
    const actx = audioCtx;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.connect(g);
    g.connect(actx.destination);
    const now = actx.currentTime;
    
    if(type === 'flap'){
      o.type = 'sine';
      o.frequency.setValueAtTime(400, now);
      o.frequency.exponentialRampToValueAtTime(600, now + 0.1);
      g.gain.setValueAtTime(0.15, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
    } else if(type === 'score'){
      o.type = 'square';
      o.frequency.setValueAtTime(800, now);
      o.frequency.setValueAtTime(1000, now + 0.05);
      o.frequency.setValueAtTime(1200, now + 0.1);
      g.gain.setValueAtTime(0.1, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
    } else if(type === 'gameover'){
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(400, now);
      o.frequency.exponentialRampToValueAtTime(100, now + 0.5);
      g.gain.setValueAtTime(0.2, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
    } else if(type === 'start'){
      o.type = 'sine';
      o.frequency.setValueAtTime(600, now);
      o.frequency.setValueAtTime(800, now + 0.1);
      g.gain.setValueAtTime(0.1, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
    }
    
    o.start(now);
    o.stop(now + 0.6);
  }
  
  // Controls
  canvas.onclick = jump;
  window.addEventListener('keydown', e => {
    if(e.code === 'Space' && win.style.display !== 'none'){
      e.preventDefault();
      jump();
    }
  });
  
  startBtn.onclick = init;
  
  draw();
}

// Debounce rapid renders
let renderTimeout;
function debounceRender(fn, delay = 100) {
  clearTimeout(renderTimeout);
  renderTimeout = setTimeout(fn, delay);
}

// Optimize window rendering
function requestIdleCallbackPolyfill(callback) {
  if('requestIdleCallback' in window) {
    return requestIdleCallback(callback);
  }
  return setTimeout(callback, 0);
}
// Space Invaders Game - ENHANCED VERSION
function openSpaceInvaders() {
    const win = makeWin("Space Invaders", 700, 600, "");

    const html = `
        <div style="padding:10px;display:flex;flex-direction:column;gap:10px;height:100%">
            <div style="display:flex;justify-content:space-between;align-items:center;">
                <div style="display:flex;gap:20px;font-size:16px">
                    <span>SCORE: <b id="siScore">0</b></span>
                    <span>LIVES: <b id="siLives">3</b></span>
                    <span>LEVEL: <b id="siLevel">1</b></span>
                </div>
                <button id="siStart" class="btn" style="padding:5px 12px;font-size:14px">START</button>
            </div>
            <canvas id="siCanvas" width="680" height="520" style="background:#000;border-radius:12px;border:2px solid rgba(255,255,255,0.15)"></canvas>
        </div>
    `;
    win.querySelector(".win-body").innerHTML = html;

    // Elements
    const canvas = win.querySelector("#siCanvas");
    const ctx = canvas.getContext("2d");

    const scoreEl = win.querySelector("#siScore");
    const livesEl = win.querySelector("#siLives");
    const levelEl = win.querySelector("#siLevel");
    const startBtn = win.querySelector("#siStart");

    // Game Vars
    let player, invaders, bullets, invaderBullets, particles;
    let score, lives, level;
    let gameRunning = false;
    let keys = {};
    let gameLoop;

    let canShoot = true;
    let bulletSafeTime = 0;

    // Key Input
    window.addEventListener("keydown", e => keys[e.code] = true);
    window.addEventListener("keyup", e => keys[e.code] = false);

    startBtn.onclick = init;

    function init() {
        // Player
        player = {
            x: canvas.width/2 - 20,
            y: canvas.height - 40,
            width: 40,
            height: 15,
            speed: 5
        };

        // Invaders
        invaders = [];
        const rows = 4;
        const cols = 9;
        const w = 30, h = 20;
        const gap = 12;

        for (let r = 0; r < rows; r++) {
            for (let c = 0; c < cols; c++) {
                invaders.push({
                    x: 40 + c * (w + gap),
                    y: 40 + r * (h + gap),
                    width: w,
                    height: h,
                    alive: true,
                    dx: 1,
                    type: r % 3
                });
            }
        }

        bullets = [];
        invaderBullets = [];
        particles = [];

        score = 0;
        lives = 3;
        level = 1;

        scoreEl.textContent = score;
        livesEl.textContent = lives;
        levelEl.textContent = level;

        bulletSafeTime = performance.now() + 300;

        gameRunning = true;
        cancelAnimationFrame(gameLoop);
        gameLoop = requestAnimationFrame(update);

        startBtn.textContent = "RESTART";
    }

    function update() {
        if (!gameRunning) return;

        drawStarfield();

        // Move Player
        if (keys["ArrowLeft"] || keys["KeyA"]) player.x = Math.max(0, player.x - player.speed);
        if (keys["ArrowRight"] || keys["KeyD"]) player.x = Math.min(canvas.width - player.width, player.x + player.speed);
        if (keys["Space"]) shoot();

        // Move Invaders
        let moveDown = false;
        const speed = 0.4 + level * 0.12;

        invaders.forEach(inv => {
            if (!inv.alive) return;

            inv.x += inv.dx * speed;

            if (inv.x <= 0 || inv.x + inv.width >= canvas.width) {
                moveDown = true;
            }
        });

        if (moveDown) {
            invaders.forEach(inv => {
                inv.y += 16;
                inv.dx *= -1;
            });
        }

        // Player Bullets
        bullets = bullets.filter(b => {
            b.y -= b.speed;
            return b.y > 0;
        });

        // Invader Bullets
        invaderBullets = invaderBullets.filter(b => {
            b.y += b.speed;
            return b.y < canvas.height;
        });

        // Invader shooting
        if (Math.random() < 0.02 + level * 0.005) {
            const alive = invaders.filter(i => i.alive);
            if (alive.length > 0) {
                const shooter = alive[Math.floor(Math.random() * alive.length)];

                invaderBullets.push({
                    x: shooter.x + shooter.width/2,
                    y: shooter.y + shooter.height,
                    width: 4,
                    height: 10,
                    speed: 3 + level * 0.3
                });
            }
        }

        // Bullet ‚Üí Invader collision
        bullets.forEach((b, bi) => {
            invaders.forEach(inv => {
                if (inv.alive && check(b, inv)) {
                    inv.alive = false;
                    bullets.splice(bi, 1);
                    score += 10;
                    scoreEl.textContent = score;
                    explode(inv.x, inv.y);
                }
            });
        });

        // Invader bullet ‚Üí player
        invaderBullets.forEach((b, bi) => {
            if (performance.now() > bulletSafeTime && check(b, player)) {
                invaderBullets.splice(bi, 1);
                lives--;
                livesEl.textContent = lives;
                explode(player.x, player.y);
                if (lives <= 0) return gameOver();
            }
        });

        // Invaders reach player
        if (invaders.some(i => i.alive && i.y > player.y - 30)) return gameOver();

        // Level complete
        if (invaders.every(i => !i.alive)) {
            level++;
            levelEl.textContent = level;
            setTimeout(init, 1200);
            return;
        }

        draw();
        gameLoop = requestAnimationFrame(update);
    }

    function drawStarfield() {
        ctx.fillStyle = "#000";
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    //----------------------
    // MODERN INVADER DRAW
    //----------------------
    function drawModernInvader(inv) {
        ctx.save();
        ctx.translate(inv.x + inv.width / 2, inv.y + inv.height / 2);

        const colors = ["#4ade80", "#38bdf8", "#f472b6"];
        ctx.fillStyle = colors[inv.type];
        ctx.shadowColor = colors[inv.type];
        ctx.shadowBlur = 12;

        switch (inv.type) {
            case 0: // diamond
                ctx.beginPath();
                ctx.moveTo(0, -12);
                ctx.lineTo(12, 0);
                ctx.lineTo(0, 12);
                ctx.lineTo(-12, 0);
                ctx.closePath();
                ctx.fill();
                break;

            case 1: // triangle
                ctx.beginPath();
                ctx.moveTo(0, -13);
                ctx.lineTo(13, 10);
                ctx.lineTo(-13, 10);
                ctx.closePath();
                ctx.fill();
                break;

            case 2: // hexagon
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = Math.PI / 3 * i;
                    ctx.lineTo(Math.cos(angle) * 12, Math.sin(angle) * 12);
                }
                ctx.closePath();
                ctx.fill();
                break;
        }

        ctx.restore();
    }

    function draw() {
        // Player Ship (modern V)
        ctx.save();
        ctx.translate(player.x + player.width / 2, player.y + player.height / 2);
        ctx.fillStyle = "#3b82f6";
        ctx.shadowColor = "#3b82f6";
        ctx.shadowBlur = 12;
        ctx.beginPath();
        ctx.moveTo(0, -10);
        ctx.lineTo(14, 10);
        ctx.lineTo(-14, 10);
        ctx.closePath();
        ctx.fill();
        ctx.restore();

        // Invaders
        invaders.forEach(inv => inv.alive && drawModernInvader(inv));

        // Player Bullets
        ctx.fillStyle = "#3b82f6";
        ctx.shadowColor = "#3b82f6";
        ctx.shadowBlur = 8;

        bullets.forEach(b => {
            ctx.beginPath();
            ctx.arc(b.x + 2, b.y, 3, 0, Math.PI * 2);
            ctx.fill();
        });

        ctx.shadowBlur = 0;

        // Invader Bullets
        ctx.fillStyle = "#f59e0b";
        invaderBullets.forEach(b =>
            ctx.fillRect(b.x, b.y, b.width, b.height)
        );

        // Particles
        particles = particles.filter(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.02;
            ctx.fillStyle = `rgba(255,200,80,${p.life})`;
            ctx.fillRect(p.x, p.y, 3, 3);
            return p.life > 0;
        });
    }

    //----------------------
    // SHOOT
    //----------------------
    function shoot() {
        if (!gameRunning || !canShoot) return;
        if (bullets.length >= 1) return;

        bullets.push({
            x: player.x + player.width / 2 - 2,
            y: player.y - 20,
            width: 4,
            height: 10,
            speed: 7
        });

        canShoot = false;
        setTimeout(() => (canShoot = true), 200);
    }

    function explode(x, y) {
        for (let i = 0; i < 20; i++) {
            particles.push({
                x,
                y,
                vx: (Math.random() - 0.5) * 3,
                vy: (Math.random() - 0.5) * 3,
                life: 1
            });
        }
    }

    function check(a, b) {
        return (
            a.x < b.x + b.width &&
            a.x + a.width > b.x &&
            a.y < b.y + b.height &&
            a.y + a.height > b.y
        );
    }

    function gameOver() {
        gameRunning = false;
        alert("GAME OVER\nScore: " + score);
    }
}




function openGames(){
  const scoreSnake = localStorage.getItem('snakeBest') || 0;
  const scoreFlappy = localStorage.getItem('flappyBest') || 0;
  const scoreSpace = localStorage.getItem('spaceBest') || 0;

  const content = `
    <div style="
      display:grid;
      grid-template-columns:repeat(2,1fr);
      gap:12px;
      padding:10px;
    ">

      <div class="game-tile" data-game="snake">
        <div class="game-icon">üêç</div>
        <div class="game-title">Snake</div>
        <div class="game-score">Score: <b>${scoreSnake}</b></div>
      </div>
      
      <div class="game-tile" data-game="game2048">
        <div class="game-icon">üß©</div>
        <div class="game-title">2048</div>
        <div class="game-score">Score: <b>${localStorage.getItem('g2048best') || 0}</b></div>
      </div>

      <div class="game-tile" data-game="pong">
        <div class="game-icon">üèì</div>
        <div class="game-title">Pong</div>
      </div>

      <div class="game-tile" data-game="tetris">
        <div class="game-icon">üß±</div>
        <div class="game-title">Tetris</div>
        <div class="game-score">Score: <b>${localStorage.getItem('tetrisBest') || 0}</b></div>
      </div>

      <div class="game-tile" data-game="dino">
        <div class="game-icon">ü¶ñ</div>
        <div class="game-title">Dino Chrome</div>
        <div class="game-score">Best: <b>${localStorage.getItem('dinoBest') || 0}</b></div>
      </div>

      <div class="game-tile" data-game="flappybird">
        <div class="game-icon">ü¶Ö</div>
        <div class="game-title">Flappy Bird</div>
        <div class="game-score">Score: <b>${scoreFlappy}</b></div>
      </div>

      <div class="game-tile" data-game="spaceinvaders">
        <div class="game-icon">üëæ</div>
        <div class="game-title">Space Invaders</div>
        <div class="game-score">Score: <b>${scoreSpace}</b></div>
      </div>

    </div>
  `;


  const win = makeWin('Games', 360, 480, content);

  win.querySelectorAll('.game-tile').forEach(tile => {
    tile.onclick = () => {
      const game = tile.dataset.game;
      if(game === 'snake') openSnake();
      if(game === 'flappybird') openFlappyBird();
      if(game === 'spaceinvaders') openSpaceInvaders();
      if(game === 'game2048') open2048();
      if(game === 'pong') openPong();
	  if(game === 'tetris') openTetris();
	  if(game==="dino") return openDino();
    };
  });
}
// ---------------- DINO 
function openDino(){
  // create window content
  const html = `
    <style>
      .dino-wrap { width:100%; height:100%; display:flex; align-items:center; justify-content:center; background:linear-gradient(180deg,#87CEEB 0%, #BFE9FF 60%, #9FD6FF 100%); }
      .dino-canvas { border-radius:10px; box-shadow: 0 10px 40px rgba(2,6,23,0.6); background: transparent; }
      .dino-hud { position:absolute; right:18px; top:12px; color:#07304a; font-weight:700; font-family: Inter, system-ui, sans-serif; text-shadow: 0 1px 0 rgba(255,255,255,0.4);}
      .dino-controls { position:absolute; left:18px; top:12px; color:#07304a; font-size:13px; opacity:0.85; }
      .dino-footer { position:absolute; bottom:18px; left:18px; color:#083047; font-size:12px; }
      .btn-small { background: rgba(255,255,255,0.12); padding:6px 10px; border-radius:6px; border:1px solid rgba(255,255,255,0.06); color:inherit; cursor:pointer; margin-left:8px; }
    </style>
    <div style="position:relative;height:100%;display:flex;align-items:center;justify-content:center;">
      <div class="dino-wrap" id="dinoWrap" style="width:calc(100% - 40px);height:calc(100% - 80px);">
        <canvas class="dino-canvas" id="dinoCanvas" width="1100" height="360"></canvas>
        <div class="dino-hud" id="dinoHud">SCORE: <span id="dinoScore">0</span></div>
        <div class="dino-controls">SPACE / ‚Üë Jump ¬∑ ‚Üì Duck ¬∑ TAP to jump
          <button id="dinoRestart" class="btn-small">Restart</button>
        </div>
        <div class="dino-footer" id="dinoFooter">Highscore: <span id="dinoHigh">0</span></div>
      </div>
    </div>
  `;
  const win = makeWin('Dino ‚Äî Offline Game', 1100,420, html);
  const canvas = win.querySelector('#dinoCanvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  const scoreEl = win.querySelector('#dinoScore');
  const highEl = win.querySelector('#dinoHigh');
  const restartBtn = win.querySelector('#dinoRestart');

  // --- Procedural textures (small offscreen canvases used as patterns) ---
  function makeNoisePattern(size, density=0.06, tint='#ffffff', alpha=0.06){
    const c = document.createElement('canvas');
    c.width = c.height = size;
    const g = c.getContext('2d');
    g.fillStyle = tint;
    g.globalAlpha = alpha;
    for(let i=0;i<size*size*density;i++){
      g.fillRect(Math.random()*size, Math.random()*size, Math.random()*2+0.5, Math.random()*2+0.5);
    }
    g.globalAlpha = 1;
    return ctx.createPattern(c, 'repeat');
  }
  function makeStripPattern(w, h, color1, color2, stripeWidth=6){
    const c = document.createElement('canvas');
    c.width = w; c.height = h;
    const g = c.getContext('2d');
    // stripes
    g.fillStyle = color1; g.fillRect(0,0,w,h);
    g.fillStyle = color2;
    for(let x = -w; x < w*2; x += stripeWidth*2){
      g.fillRect(x,0,stripeWidth,h);
    }
    return ctx.createPattern(c, 'repeat');
  }

  const grain = makeNoisePattern(64, 0.03, '#000000', 0.06);
  const rockPattern = makeNoisePattern(48, 0.02, '#2b2b2b', 0.07);
  const cactusBark = makeStripPattern(40,40, '#0b7a36', '#08602b', 6);
  const dinoSkin = makeStripPattern(24,24, '#1b2b12', '#22321c', 4);
  const cloudPattern = makeNoisePattern(80,0.01,'#ffffff',0.06);

  // --- Game variables ---
  const W = canvas.width, H = canvas.height;
  let running = true;
  let speed = 6;
  let gravity = 0.9;
  let groundY = H - 80;
  let score = 0;
  let high = parseInt(localStorage.getItem('webos_dino_high') || '0', 10);
  highEl.textContent = high;
  let tick = 0;

  // player
  const player = {
    x: 80,
    y: groundY - 48,
    w: 44,
    h: 48,
    vy: 0,
    jumping: false,
    ducking: false,
    runFrame: 0,
    blink: 0
  };

  // obstacles & clouds
  let obstacles = [];
  let clouds = [];
  let spawnTimer = 0;
  let nextSpawn = 80 + Math.random()*120;

  // Input
  const keys = {};
  function onKeyDown(e){
    if(e.key === ' ' || e.key === 'ArrowUp') { e.preventDefault(); jump(); }
    if(e.key === 'ArrowDown') { e.preventDefault(); duck(true); }
    if(e.key === 'p') { running = !running; }
  }
  function onKeyUp(e){
    if(e.key === 'ArrowDown') { duck(false); }
  }
  function onTouchStart(e){
    jump();
  }
  window.addEventListener('keydown', onKeyDown);
  window.addEventListener('keyup', onKeyUp);
  canvas.addEventListener('touchstart', onTouchStart, {passive:true});
  canvas.addEventListener('mousedown', onTouchStart);

  restartBtn.onclick = () => reset();

  // Utilities
  function rand(min,max){ return min + Math.random()*(max-min); }
  function rectsIntersect(a,b){
    return !(a.x + a.w < b.x || a.x > b.x + b.w || a.y + a.h < b.y || a.y > b.y + b.h);
  }

  // Spawn obstacles: cacti or pterodactyl
  function spawnObstacle(){
    const kind = Math.random() < 0.15 ? 'ptero' : 'cactus';
    if(kind === 'cactus'){
      const sizes = [{w:18,h:36},{w:30,h:46},{w:40,h:56}];
      const s = sizes[Math.floor(Math.random()*sizes.length)];
      obstacles.push({
        type:'cactus',
        x: W + 40,
        y: groundY - s.h,
        w: s.w,
        h: s.h,
        pattern: cactusBark
      });
    } else {
      // pterodactyl - variable height
      const height = groundY - 120 - Math.random()*80;
      obstacles.push({
        type:'ptero',
        x: W + 40,
        y: height,
        w: 52,
        h: 32,
        flap: 0
      });
    }
  }

  // Clouds spawn
  function spawnCloud(){
    clouds.push({
      x: W + Math.random()*200,
      y: 40 + Math.random()*120,
      w: 120 + Math.random()*80,
      h: 40 + Math.random()*30,
      speed: 0.6 + Math.random()*0.9,
      alpha: 0.5 + Math.random()*0.5
    });
  }

  // Player controls
  function jump(){
    if(player.jumping || !running) return;
    player.vy = -15 - Math.random()*2;
    player.jumping = true;
    player.ducking = false;
    sfx('jump');
  }
  function duck(on){
    player.ducking = !!on && !player.jumping;
    if(player.ducking) player.h = 28; else player.h = 48;
  }

  // Simple SFX using WebAudio (non-blocking)
  const audioCtxLocal = (window.AudioContext || window.webkitAudioContext) ? new (window.AudioContext || window.webkitAudioContext)() : null;
  function sfx(name){
    if(!audioCtxLocal) return;
    try{
      const o = audioCtxLocal.createOscillator();
      const g = audioCtxLocal.createGain();
      o.connect(g); g.connect(audioCtxLocal.destination);
      const now = audioCtxLocal.currentTime;
      if(name==='jump'){ o.type='sine'; o.frequency.setValueAtTime(700,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.06, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.3); }
      else if(name==='hit'){ o.type='sawtooth'; o.frequency.setValueAtTime(160,now); g.gain.setValueAtTime(0.0001,now); g.gain.exponentialRampToValueAtTime(0.12, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.25); }
      o.start(now); o.stop(now+0.25);
    }catch(e){}
  }

  // Reset / init
  function reset(){
    obstacles = [];
    clouds = [];
    player.y = groundY - player.h;
    player.vy = 0;
    player.jumping = false;
    player.ducking = false;
    speed = 6;
    score = 0;
    tick = 0;
    spawnTimer = 0;
    nextSpawn = 80 + Math.random()*120;
    running = true;
  }

  reset();
  // initial cloud cover
  for(let i=0;i<4;i++) spawnCloud();

  // Game loop
  let last = performance.now();
  function loop(now){
    const dt = Math.min(40, now - last);
    last = now;
    if(running){
      update(dt/16);
      render();
    } else {
      // paused - draw still
      render();
      // muting logic could be added
    }
    if(!win || !document.getElementById(win.id)) {
      // window closed -> cleanup listeners
      window.removeEventListener('keydown', onKeyDown);
      window.removeEventListener('keyup', onKeyUp);
      canvas.removeEventListener('touchstart', onTouchStart);
      canvas.removeEventListener('mousedown', onTouchStart);
      return;
    }
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function update(speedFactor){
    tick++;
    // update clouds
    for(let i=clouds.length-1;i>=0;i--){
      clouds[i].x -= clouds[i].speed * speedFactor * 0.8;
      if(clouds[i].x + clouds[i].w < -40) clouds.splice(i,1);
    }
    if(Math.random() < 0.02) spawnCloud();

    // obstacles
    spawnTimer++;
    if(spawnTimer > nextSpawn){
      spawnObstacle();
      spawnTimer = 0;
      nextSpawn = 60 + Math.random()*140 - Math.min(80, score/10);
    }

    for(let i=obstacles.length-1;i>=0;i--){
      const o = obstacles[i];
      o.x -= (speed + score*0.01) * speedFactor;
      if(o.type === 'ptero'){ o.flap += 0.2 * speedFactor; o.y += Math.sin(o.flap)*0.4; }
      if(o.x + o.w < -40){
        obstacles.splice(i,1);
        continue;
      }
      // collision with player (simple box)
      const playerBox = { x: player.x, y: player.y, w: player.w, h: player.h };
      const obsBox = { x: o.x, y: o.y, w: o.w, h: o.h };
      if(rectsIntersect(playerBox, obsBox)){
        // hit
        sfx('hit');
        running = false;
        // check highscore
        if(score > high){ high = Math.floor(score); localStorage.setItem('webos_dino_high', high.toString()); highEl.textContent = high; }
        // flash effect
        flashScreen();
      }
    }

    // player physics
    if(player.jumping){
      player.vy += gravity * (0.9 + score*0.0004) * speedFactor;
      player.y += player.vy * speedFactor;
      if(player.y >= groundY - player.h){
        player.y = groundY - player.h;
        player.vy = 0;
        player.jumping = false;
        player.blink = 30;
      }
    }

    // duck friction
    if(player.ducking) {
      player.runFrame = 0;
      player.blink = 0;
    } else {
      // run animation frame
      if(!player.jumping){
        if(tick % 6 === 0) player.runFrame = (player.runFrame + 1) % 2;
      } else {
        player.runFrame = 0;
      }
    }

    // score & speed scaling
    score += 0.08 * speedFactor;
    if(Math.floor(score) % 100 === 0 && Math.floor(score) !== 0){
      speed += 0.002 * Math.max(1, score/100); // gradual speed up
    }

    scoreEl.textContent = Math.floor(score);

    // occasionally spawn big rock
    if(Math.random() < 0.001) {
      obstacles.push({ type:'rock', x: W + 80 + Math.random()*200, y: groundY - 28, w: 36, h: 28, pattern: rockPattern });
    }
  }

  // nice flash on death
  let flashAlpha = 0;
  function flashScreen(){
    flashAlpha = 1;
    const t = setInterval(()=>{ flashAlpha -= 0.06; if(flashAlpha <= 0){ clearInterval(t); flashAlpha = 0; } }, 60);
  }

  // render everything textured & with style
  function render(){
    // background gradient (sky -> horizon)
    const g = ctx.createLinearGradient(0,0,0,H);
    g.addColorStop(0, '#87CEEB');
    g.addColorStop(0.6, '#BFE9FF');
    g.addColorStop(1, '#9FD6FF');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    // distant mountains ‚Äî procedural textured shapes
    ctx.save();
    ctx.translate(0, 0);
    for(let i=0;i<3;i++){
      const offset = i*160;
      ctx.beginPath();
      ctx.moveTo(-50 + i*120, groundY - 60);
      for(let x= -50; x < W + 50; x+=40){
        ctx.lineTo(x, groundY - 120 - Math.sin((x/120)+i)*28 - (i*12));
      }
      ctx.lineTo(W+50, H);
      ctx.lineTo(-50,H);
      ctx.closePath();
      ctx.fillStyle = `rgba(10,30,40,${0.03 + i*0.03})`;
      ctx.fill();
    }
    ctx.restore();

    // clouds (with subtle pattern)
    clouds.forEach(c=>{
      ctx.save();
      ctx.globalAlpha = c.alpha;
      // cloud body
      const cloudX = c.x, cloudY = c.y;
      ctx.beginPath();
      ctx.ellipse(cloudX, cloudY, c.w*0.45, c.h*0.5, 0, 0, Math.PI*2);
      ctx.ellipse(cloudX + c.w*0.2, cloudY - 4, c.w*0.25, c.h*0.35, 0,0,Math.PI*2);
      ctx.ellipse(cloudX - c.w*0.22, cloudY - 6, c.w*0.22, c.h*0.32,0,0,Math.PI*2);
      ctx.closePath();
      ctx.fillStyle = '#ffffff';
      ctx.fill();
      // texture overlay
      ctx.globalCompositeOperation = 'overlay';
      ctx.fillStyle = cloudPattern;
      ctx.fill();
      ctx.globalCompositeOperation = 'source-over';
      ctx.restore();
    });

    // ground (textured)
    ctx.save();
    ctx.fillStyle = '#dedede';
    ctx.fillRect(0, groundY, W, H - groundY);
    // textured overlay
    ctx.fillStyle = grain;
    ctx.globalAlpha = 0.18;
    ctx.fillRect(0, groundY, W, H - groundY);
    ctx.globalAlpha = 1;
    ctx.restore();

    // obstacles
    obstacles.forEach(o=>{
      ctx.save();
      if(o.type === 'cactus'){
        ctx.fillStyle = '#0b7a36';
        ctx.fillRect(o.x, o.y, o.w, o.h);
        // trunk texture overlay
        ctx.fillStyle = o.pattern;
        ctx.globalAlpha = 0.9;
        ctx.fillRect(o.x, o.y, o.w, o.h);
        // little spikes
        ctx.fillStyle = '#7fe29d';
        for(let i=0;i<3;i++){
          const sx = o.x + 4 + i*(o.w/3);
          ctx.beginPath();
          ctx.moveTo(sx, o.y + 4);
          ctx.lineTo(sx+6, o.y + 10);
          ctx.lineTo(sx-4, o.y + 10);
          ctx.closePath();
          ctx.fill();
        }
      } else if(o.type === 'ptero'){
        // pterodactyl stylized
        ctx.translate(o.x+o.w/2, o.y+o.h/2);
        ctx.rotate(Math.sin(tick/8 + o.x/200)*0.06);
        ctx.fillStyle = '#2f2f2f';
        ctx.beginPath();
        ctx.moveTo(-o.w/2, 0);
        ctx.quadraticCurveTo(0, -o.h, o.w/2, 0);
        ctx.quadraticCurveTo(0, o.h, -o.w/2, 0);
        ctx.closePath();
        ctx.fill();
      } else if(o.type === 'rock'){
        ctx.fillStyle = '#444';
        ctx.fillRect(o.x, o.y, o.w, o.h);
        ctx.fillStyle = o.pattern;
        ctx.globalAlpha = 0.9;
        ctx.fillRect(o.x, o.y, o.w, o.h);
      }
      ctx.restore();
    });

    // player (textured dino)
    ctx.save();
    const px = player.x, py = player.y, pw = player.w, ph = player.h;
    // body
    ctx.fillStyle = '#2b6a2e';
    if(player.ducking) {
      ctx.fillRect(px-4, py+8, pw+12, ph-12);
    } else {
      const rad = 8;
      roundRect(ctx, px-8, py, pw+16, ph, rad, true, false);
    }
    // skin pattern
    ctx.fillStyle = dinoSkin;
    ctx.globalAlpha = 0.85;
    if(player.ducking) ctx.fillRect(px-4, py+8, pw+12, ph-12);
    else roundRect(ctx, px-8, py, pw+16, ph, 8, true, false);
    ctx.globalAlpha = 1;
    // eye
    ctx.fillStyle = '#fff';
    if(!player.ducking){
      ctx.beginPath();
      ctx.ellipse(px + pw/2 + 6, py + 12, 6, 6, 0, 0, Math.PI*2);
      ctx.fill();
      ctx.fillStyle = '#0b2b10';
      ctx.beginPath();
      ctx.ellipse(px + pw/2 + 8, py + 12, 3, 3, 0, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // small shadow
    ctx.save();
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.beginPath();
    ctx.ellipse(player.x + player.w/2 + 6, groundY + 8, 28, 10, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // HUD drawn already as DOM; draw flashes on death
    if(flashAlpha > 0){
      ctx.fillStyle = `rgba(255,255,255,${flashAlpha})`;
      ctx.fillRect(0,0,W,H);
      flashAlpha -= 0.02;
      if(flashAlpha < 0) flashAlpha = 0;
    }
  }

  // handy rounded rect
  function roundRect(ctx,x,y,w,h,r,fill,stroke){
    if (typeof r === 'undefined') r = 5;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // close-detection: on window close remove listeners
  // (makeWin's close button removes DOM; loop checks for presence)

  // For mobile: simple top area tap = jump, bottom area = duck while pressed (optional)
  // NOTE: We already listen to canvas touch and click for jump

  // expose game controls to the window for debugging
  window.dinoGame = {
    reset, getScore: ()=>score, stop: ()=>running=false, resume: ()=>running=true
  };
}

function open2048(){
  const win = makeWin("2048", 350, 450, `
    <div style="padding:10px;display:flex;flex-direction:column;gap:10px">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div class="small">Score: <b id="g2048Score">0</b></div>
        <div class="small">Best: <b id="g2048Best">${localStorage.getItem('g2048best') || 0}</b></div>
      </div>
      <div id="g2048Grid" style="
        display:grid;
        grid-template-columns:repeat(4,1fr);
        gap:8px;
        background:#1e293b;
        padding:8px;
        border-radius:10px;
        position:relative;
      "></div>
      <button class="btn" id="g2048Restart">Restart</button>
    </div>
  `);

  let grid = [];
  let score = 0;

  let lastAdded = null;
  let lastMerged = [];

  const gridEl = win.querySelector("#g2048Grid");
  const scoreEl = win.querySelector("#g2048Score");
  const bestEl = win.querySelector("#g2048Best");

  function init(){
    grid = Array(4).fill().map(()=>Array(4).fill(0));
    score = 0;
    updateScore();
    addRandom();
    addRandom();
    render();
  }

  function updateScore(){
    scoreEl.textContent = score;
    const best = parseInt(localStorage.getItem('g2048best') || 0);
    if(score > best){
      localStorage.setItem("g2048best", score);
      bestEl.textContent = score;
    }
  }

  function addRandom(){
    let empty = [];
    for(let r=0;r<4;r++){
      for(let c=0;c<4;c++){
        if(grid[r][c] === 0) empty.push({r,c});
      }
    }
    if(empty.length === 0) return;
    const spot = empty[Math.floor(Math.random()*empty.length)];
    grid[spot.r][spot.c] = Math.random() < 0.9 ? 2 : 4;

    lastAdded = {r: spot.r, c: spot.c};
  }

  function render(){
    gridEl.innerHTML = "";

    for(let r=0;r<4;r++){
      for(let c=0;c<4;c++){
        const val = grid[r][c];
        const tile = document.createElement("div");

        tile.classList.add("tile");
        if(lastAdded && lastAdded.r === r && lastAdded.c === c) tile.classList.add("tile-new");
        if(lastMerged.some(m=>m.r===r && m.c===c)) tile.classList.add("tile-merge");

        tile.textContent = val || "";
        tile.style = `
          height:70px;
          border-radius:8px;
          display:flex;
          align-items:center;
          justify-content:center;
          font-size:22px;
          font-weight:bold;
          color:#fff;
          background:${getTileColor(val)};
        `;

        gridEl.appendChild(tile);
      }
    }

    lastAdded = null;
    lastMerged = [];
  }

  function getTileColor(v){
    const colors = {
      0:"rgba(255,255,255,0.07)",
      2:"#334155",
      4:"#475569",
      8:"#0ea5e9",
      16:"#38bdf8",
      32:"#6366f1",
      64:"#8b5cf6",
      128:"#f59e0b",
      256:"#fbbf24",
      512:"#f87171",
      1024:"#ef4444",
      2048:"#10b981"
    };
    return colors[v] || "#14b8a6";
  }

  function slide(row, rowIndex){
    let arr = row.filter(v=>v);

    for(let i=0;i<arr.length-1;i++){
      if(arr[i] === arr[i+1]){
        arr[i] *= 2;
        score += arr[i];
        lastMerged.push({r: rowIndex, c: i});
        arr[i+1] = 0;
      }
    }

    arr = arr.filter(v=>v);
    while(arr.length<4) arr.push(0);

    return arr;
  }

  function moveLeft(){
    for(let r=0;r<4;r++) grid[r] = slide(grid[r], r);
    finishMove();
  }

  function moveRight(){
    for(let r=0;r<4;r++) grid[r] = slide(grid[r].reverse(), r).reverse();
    finishMove();
  }

  function moveUp(){
    for(let c=0;c<4;c++){
      let col = [grid[0][c], grid[1][c], grid[2][c], grid[3][c]];
      col = slide(col, 0);
      for(let r=0;r<4;r++) grid[r][c] = col[r];
    }
    finishMove();
  }

  function moveDown(){
    for(let c=0;c<4;c++){
      let col = [grid[0][c], grid[1][c], grid[2][c], grid[3][c]].reverse();
      col = slide(col, 0).reverse();
      for(let r=0;r<4;r++) grid[r][c] = col[r];
    }
    finishMove();
  }

  function finishMove(){
    addRandom();
    updateScore();
    render();
  }

  window.addEventListener("keydown", e=>{
    if(e.key==="ArrowLeft"||e.key==="a") moveLeft();
    if(e.key==="ArrowRight"||e.key==="d") moveRight();
    if(e.key==="ArrowUp"||e.key==="w") moveUp();
    if(e.key==="ArrowDown"||e.key==="s") moveDown();
  });

  win.querySelector("#g2048Restart").onclick = init;
  init();
}
// Tetris Game
function openTetris() {
  const win = makeWin("Tetris", 400, 600, `
    <div style="display:flex;flex-direction:column;height:100%;padding:12px;gap:10px;background:linear-gradient(135deg,#1e293b,#0f172a)">
      <div style="display:flex;justify-content:space-between;align-items:center;background:rgba(255,255,255,0.05);padding:12px;border-radius:10px">
        <div>
          <div class="small" style="color:#94a3b8">SCORE</div>
          <div id="tetrisScore" style="font-size:28px;font-weight:bold;color:#fff">0</div>
        </div>
        <div>
          <div class="small" style="color:#94a3b8">LEVEL</div>
          <div id="tetrisLevel" style="font-size:28px;font-weight:bold;color:#3b82f6">1</div>
        </div>
        <div>
          <div class="small" style="color:#94a3b8">BEST</div>
          <div id="tetrisBest" style="font-size:28px;font-weight:bold;color:#fbbf24">${localStorage.getItem('tetrisBest') || 0}</div>
        </div>
      </div>
      
      <div style="display:flex;gap:10px;flex:1">
        <div style="background:rgba(0,0,0,0.3);padding:10px;border-radius:10px;display:flex;flex-direction:column;gap:8px">
          <div class="small" style="color:#94a3b8">NEXT</div>
          <canvas id="tetrisNext" width="80" height="80" style="background:rgba(0,0,0,0.5);border-radius:6px"></canvas>
          <div class="small" style="color:#94a3b8;margin-top:10px">LINES</div>
          <div id="tetrisLines" style="font-size:20px;font-weight:bold;color:#10b981">0</div>
        </div>
        
        <canvas id="tetrisCanvas" width="240" height="480" style="background:#000;border-radius:10px;box-shadow:0 8px 32px rgba(0,0,0,0.5)"></canvas>
      </div>
      
      <div style="text-align:center;color:#94a3b8;font-size:12px">
        √¢‚Ä†/√¢‚Ä†'/√¢‚Ä†"/√¢‚Ä†" or WASD to move ‚Ä¢ SPACE to hard drop
      </div>
      
      <button id="tetrisStart" class="btn" style="background:linear-gradient(135deg,#3b82f6,#1e40af);font-weight:bold;padding:12px">START GAME</button>
    </div>
  `);

  const canvas = win.querySelector("#tetrisCanvas");
  const ctx = canvas.getContext("2d");
  const nextCanvas = win.querySelector("#tetrisNext");
  const nextCtx = nextCanvas.getContext("2d");
  
  const scoreEl = win.querySelector("#tetrisScore");
  const levelEl = win.querySelector("#tetrisLevel");
  const bestEl = win.querySelector("#tetrisBest");
  const linesEl = win.querySelector("#tetrisLines");
  const startBtn = win.querySelector("#tetrisStart");

  const COLS = 10;
  const ROWS = 20;
  const BLOCK_SIZE = 24;
  
  let board = [];
  let score = 0;
  let level = 1;
  let lines = 0;
  let gameRunning = false;
  let gameLoop;
  let dropCounter = 0;
  let dropInterval = 1000;
  let lastTime = 0;

  const SHAPES = [
    [[1,1,1,1]], // I
    [[1,1],[1,1]], // O
    [[0,1,0],[1,1,1]], // T
    [[1,0,0],[1,1,1]], // L
    [[0,0,1],[1,1,1]], // J
    [[0,1,1],[1,1,0]], // S
    [[1,1,0],[0,1,1]]  // Z
  ];

  const COLORS = ['#00f0f0', '#f0f000', '#a000f0', '#f0a000', '#0000f0', '#00f000', '#f00000'];

  let currentPiece = null;
  let nextPiece = null;

  function createPiece() {
    const shapeIndex = Math.floor(Math.random() * SHAPES.length);
    return {
      shape: SHAPES[shapeIndex],
      color: COLORS[shapeIndex],
      x: Math.floor(COLS / 2) - 1,
      y: 0
    };
  }

  function drawBlock(ctx, x, y, color, size = BLOCK_SIZE) {
    ctx.fillStyle = color;
    ctx.fillRect(x * size, y * size, size, size);
    ctx.strokeStyle = 'rgba(0,0,0,0.5)';
    ctx.lineWidth = 2;
    ctx.strokeRect(x * size, y * size, size, size);
    
    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.2)';
    ctx.fillRect(x * size, y * size, size / 4, size / 4);
  }

  function drawBoard() {
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Grid
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    for (let i = 0; i <= COLS; i++) {
      ctx.beginPath();
      ctx.moveTo(i * BLOCK_SIZE, 0);
      ctx.lineTo(i * BLOCK_SIZE, canvas.height);
      ctx.stroke();
    }
    for (let i = 0; i <= ROWS; i++) {
      ctx.beginPath();
      ctx.moveTo(0, i * BLOCK_SIZE);
      ctx.lineTo(canvas.width, i * BLOCK_SIZE);
      ctx.stroke();
    }
    
    // Board pieces
    board.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value) {
          drawBlock(ctx, x, y, value);
        }
      });
    });
    
    // Current piece
    if (currentPiece) {
      currentPiece.shape.forEach((row, dy) => {
        row.forEach((value, dx) => {
          if (value) {
            drawBlock(ctx, currentPiece.x + dx, currentPiece.y + dy, currentPiece.color);
          }
        });
      });
    }
  }

  function drawNext() {
  // Clear the canvas first
  nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
  nextCtx.fillStyle = 'rgba(0,0,0,0.5)';
  nextCtx.fillRect(0, 0, nextCanvas.width, nextCanvas.height);
  
  if (nextPiece) {
    const offsetX = (4 - nextPiece.shape[0].length) / 2;
    const offsetY = (4 - nextPiece.shape.length) / 2;
    
    nextPiece.shape.forEach((row, dy) => {
      row.forEach((value, dx) => {
        if (value) {
          drawBlock(nextCtx, offsetX + dx, offsetY + dy, nextPiece.color, 20);
        }
      });
    });
  }
}

  function collide() {
    for (let y = 0; y < currentPiece.shape.length; y++) {
      for (let x = 0; x < currentPiece.shape[y].length; x++) {
        if (currentPiece.shape[y][x]) {
          const newX = currentPiece.x + x;
          const newY = currentPiece.y + y;
          
          if (newX < 0 || newX >= COLS || newY >= ROWS) return true;
          if (newY >= 0 && board[newY][newX]) return true;
        }
      }
    }
    return false;
  }

  function merge() {
    currentPiece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value) {
          const boardY = currentPiece.y + y;
          const boardX = currentPiece.x + x;
          if (boardY >= 0) {
            board[boardY][boardX] = currentPiece.color;
          }
        }
      });
    });
  }

  function rotate() {
    const rotated = currentPiece.shape[0].map((_, i) =>
      currentPiece.shape.map(row => row[i]).reverse()
    );
    
    const previousShape = currentPiece.shape;
    currentPiece.shape = rotated;
    
    if (collide()) {
      currentPiece.shape = previousShape;
    } else {
      playSFX('rotate');
    }
  }

  function clearLines() {
    let linesCleared = 0;
    
    for (let y = ROWS - 1; y >= 0; y--) {
      if (board[y].every(cell => cell !== 0)) {
        board.splice(y, 1);
        board.unshift(Array(COLS).fill(0));
        linesCleared++;
        y++;
      }
    }
    
    if (linesCleared > 0) {
      lines += linesCleared;
      linesEl.textContent = lines;
      
      const points = [0, 100, 300, 500, 800][linesCleared] * level;
      score += points;
      scoreEl.textContent = score;
      
      level = Math.floor(lines / 10) + 1;
      levelEl.textContent = level;
      dropInterval = Math.max(100, 1000 - (level - 1) * 100);
      
      if (score > parseInt(localStorage.getItem('tetrisBest') || 0)) {
        localStorage.setItem('tetrisBest', score);
        bestEl.textContent = score;
      }
      
      playSFX('clear');
    }
  }

  function drop() {
    currentPiece.y++;
    if (collide()) {
      currentPiece.y--;
      merge();
      clearLines();
      currentPiece = nextPiece;
      nextPiece = createPiece();
      drawNext();
      
      if (collide()) {
        gameOver();
      }
    }
    dropCounter = 0;
  }

  function hardDrop() {
    while (!collide()) {
      currentPiece.y++;
      score += 2;
    }
    currentPiece.y--;
    scoreEl.textContent = score;
    merge();
    clearLines();
    currentPiece = nextPiece;
    nextPiece = createPiece();
    drawNext();
    
    if (collide()) {
      gameOver();
    }
    playSFX('drop');
  }

  function move(dir) {
    currentPiece.x += dir;
    if (collide()) {
      currentPiece.x -= dir;
    }
  }

  function gameOver() {
    gameRunning = false;
    cancelAnimationFrame(gameLoop);
    playSFX('gameover');
    showNotification('Game Over', `Score: ${score} | Lines: ${lines}`, 'info', 4000);
    startBtn.textContent = 'RESTART';
  }

  function playSFX(type) {
    const actx = audioCtx;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.connect(g);
    g.connect(actx.destination);
    const now = actx.currentTime;
    
    if (type === 'rotate') {
      o.type = 'sine';
      o.frequency.setValueAtTime(400, now);
      g.gain.setValueAtTime(0.05, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
    } else if (type === 'clear') {
      o.type = 'square';
      o.frequency.setValueAtTime(600, now);
      o.frequency.setValueAtTime(800, now + 0.1);
      g.gain.setValueAtTime(0.1, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
    } else if (type === 'drop') {
      o.type = 'triangle';
      o.frequency.setValueAtTime(200, now);
      g.gain.setValueAtTime(0.08, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
    } else if (type === 'gameover') {
      o.type = 'sawtooth';
      o.frequency.setValueAtTime(300, now);
      o.frequency.exponentialRampToValueAtTime(100, now + 0.5);
      g.gain.setValueAtTime(0.15, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
    }
    
    o.start(now);
    o.stop(now + 0.6);
  }

  function update(time = 0) {
    if (!gameRunning) return;
    
    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;
    
    if (dropCounter > dropInterval) {
      drop();
    }
    
    drawBoard();
    gameLoop = requestAnimationFrame(update);
  }

  function init() {
    board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    score = 0;
    level = 1;
    lines = 0;
    dropCounter = 0;
    dropInterval = 1000;
    
    scoreEl.textContent = 0;
    levelEl.textContent = 1;
    linesEl.textContent = 0;
    
    currentPiece = createPiece();
    nextPiece = createPiece();
    
    gameRunning = true;
    startBtn.textContent = 'RESTART';
    
    drawNext();
    lastTime = 0;
    gameLoop = requestAnimationFrame(update);
  }

  // Controls
  const keys = {};
  window.addEventListener('keydown', e => {
    if (!gameRunning) return;
    keys[e.key] = true;
    
    if (e.key === 'ArrowLeft' || e.key === 'a' || e.key === 'A') {
      e.preventDefault();
      move(-1);
    } else if (e.key === 'ArrowRight' || e.key === 'd' || e.key === 'D') {
      e.preventDefault();
      move(1);
    } else if (e.key === 'ArrowDown' || e.key === 's' || e.key === 'S') {
      e.preventDefault();
      drop();
    } else if (e.key === 'ArrowUp' || e.key === 'w' || e.key === 'W') {
      e.preventDefault();
      rotate();
    } else if (e.key === ' ') {
      e.preventDefault();
      hardDrop();
    }
    
    drawBoard();
  });

  window.addEventListener('keyup', e => {
    keys[e.key] = false;
  });

  startBtn.onclick = init;
  
  drawBoard();
}

function openPong(){
  const win = makeWin("Pong", 280, 160, `
    <div style="color:white;text-align:center;padding:15px;">
      <h2 style="margin-bottom:10px;font-size:16px;">Select Mode</h2>
      <button class="btn" id="pong1p" style="margin-bottom:8px;width:90%;font-size:12px;">1 Player (vs AI)</button>
      <button class="btn" id="pong2p" style="width:90%;font-size:12px;">2 Players</button>
    </div>
  `);

  win.querySelector("#pong1p").onclick = () => {
    startPong("1p");
    win.remove();
  };

  win.querySelector("#pong2p").onclick = () => {
    startPong("2p");
    win.remove();
  };
}

function startPong(mode){
  const win = makeWin("Pong - " + (mode === "1p" ? "Single Player" : "Multiplayer"), 720, 580, `
    <div style="display:flex;flex-direction:column;height:100%;background:radial-gradient(circle at center,#0a0f2a 0%,#000 100%);padding:20px;border-radius:15px;position:relative;overflow:hidden;">
      <!-- Animated background elements -->
      <div class="bg-particle" style="position:absolute;width:4px;height:4px;background:#fff;border-radius:50%;opacity:0.6;"></div>
      
      <!-- Score Display -->
      <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:20px;z-index:2;position:relative;">
        <div style="text-align:center;background:linear-gradient(45deg,#667eea,#764ba2);padding:15px 25px;border-radius:15px;box-shadow:0 8px 25px rgba(102,126,234,0.4);border:2px solid rgba(255,255,255,0.2);">
          <div style="font-size:14px;color:#a5b4fc;margin-bottom:5px;">PLAYER 1</div>
          <div id="p1Score" style="font-size:36px;font-weight:bold;color:#fff;text-shadow:0 0 20px #667eea;">0</div>
        </div>
        
        <div style="text-align:center;background:rgba(255,255,255,0.1);padding:10px 20px;border-radius:12px;backdrop-filter:blur(10px);border:1px solid rgba(255,255,255,0.1);">
          <div style="font-size:12px;color:#94a3b8;">BEST SCORE</div>
          <div id="pongBest" style="font-size:24px;font-weight:bold;color:#feca57;">${localStorage.getItem("pongBest") || 0}</div>
        </div>
        
        <div style="text-align:center;background:linear-gradient(45deg,#f5576c,#f093fb);padding:15px 25px;border-radius:15px;box-shadow:0 8px 25px rgba(245,87,108,0.4);border:2px solid rgba(255,255,255,0.2);">
          <div style="font-size:14px;color:#f8a5c2;margin-bottom:5px;">${mode === "1p" ? "AI" : "PLAYER 2"}</div>
          <div id="p2Score" style="font-size:36px;font-weight:bold;color:#fff;text-shadow:0 0 20px #f5576c;">0</div>
        </div>
      </div>

      <!-- Game Canvas -->
      <div style="flex:1;position:relative;border-radius:20px;overflow:hidden;box-shadow:0 0 50px rgba(59,130,246,0.3);border:3px solid rgba(59,130,246,0.3);">
        <canvas id="pongCanvas" width="680" height="400" style="display:block;background:radial-gradient(ellipse at center,#1a1f3a 0%,#0a0f2a 70%);"></canvas>
        
        <!-- Center Line -->
        <div style="position:absolute;left:50%;top:0;bottom:0;width:2px;background:linear-gradient(to bottom,transparent 0%,rgba(59,130,246,0.6) 50%,transparent 100%);transform:translateX(-50%);"></div>
        
        <!-- Center Circle -->
        <div style="position:absolute;left:50%;top:50%;width:100px;height:100px;border:2px solid rgba(59,130,246,0.4);border-radius:50%;transform:translate(-50%,-50%);"></div>
      </div>

      <!-- Controls Info -->
      <div style="display:grid;grid-template-columns:1fr 1fr;gap:15px;margin-top:15px;z-index:2;position:relative;">
        <div style="background:rgba(59,130,246,0.1);padding:12px;border-radius:10px;border:1px solid rgba(59,130,246,0.3);">
          <div style="font-size:11px;color:#3b82f6;margin-bottom:4px;">PLAYER 1 CONTROLS</div>
          <div style="font-size:10px;color:#94a3b8;">W/S or ‚Üë/‚Üì Keys</div>
        </div>
        <div style="background:rgba(245,87,108,0.1);padding:12px;border-radius:10px;border:1px solid rgba(245,87,108,0.3);">
          <div style="font-size:11px;color:#f5576c;margin-bottom:4px;">${mode === "1p" ? "AI" : "PLAYER 2"} CONTROLS</div>
          <div style="font-size:10px;color:#94a3b8;">${mode === "1p" ? "Auto-play" : "W/S or ‚Üë/‚Üì Keys"}</div>
        </div>
      </div>
    </div>
  `);

  const canvas = win.querySelector("#pongCanvas");
  const ctx = canvas.getContext("2d");
  const p1ScoreEl = win.querySelector("#p1Score");
  const p2ScoreEl = win.querySelector("#p2Score");
  const bestEl = win.querySelector("#pongBest");

  // Enhanced game variables
  let p1Y = canvas.height / 2 - 50;
  let p2Y = canvas.height / 2 - 50;
  const paddleWidth = 16;
  const paddleHeight = 100;
  
  let ballX = canvas.width / 2;
  let ballY = canvas.height / 2;
  let ballDX = 5;
  let ballDY = 4;
  const ballSize = 12;
  
  let p1Score = 0;
  let p2Score = 0;
  let gameRunning = true;
  
  // Visual effects
  let particles = [];
  let trail = [];
  let glowIntensity = 0;
  let screenShake = 0;
  
  // Enhanced AI for single player
  let aiDifficulty = 0.08; // Lower = harder AI

  // Controls
  const keys = { 
    w: false, s: false, 
    ArrowUp: false, ArrowDown: false 
  };

  // Create background particles
  function createBackgroundParticles() {
    const particles = win.querySelectorAll('.bg-particle');
    particles.forEach(particle => {
      const size = Math.random() * 3 + 1;
      const x = Math.random() * 100;
      const y = Math.random() * 100;
      const duration = Math.random() * 20 + 10;
      
      particle.style.width = size + 'px';
      particle.style.height = size + 'px';
      particle.style.left = x + '%';
      particle.style.top = y + '%';
      particle.style.animation = `float ${duration}s infinite linear`;
      particle.style.opacity = Math.random() * 0.4 + 0.1;
    });
  }

  // Add CSS for animations
  const style = document.createElement('style');
  style.textContent = `
    @keyframes float {
      0% { transform: translateY(0px) rotate(0deg); }
      100% { transform: translateY(-100vh) rotate(360deg); }
    }
    @keyframes glow {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.8; }
    }
    @keyframes shake {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-5px); }
      75% { transform: translateX(5px); }
    }
  `;
  document.head.appendChild(style);

  createBackgroundParticles();

  // Enhanced paddle movement with smooth acceleration
  function updatePaddles() {
    // Player 1 movement
    if (keys.w) p1Y = Math.max(20, p1Y - 8);
    if (keys.s) p1Y = Math.min(canvas.height - paddleHeight - 20, p1Y + 8);
    
    // Player 2 movement (AI or player)
    if (mode === "2p") {
      if (keys.ArrowUp) p2Y = Math.max(20, p2Y - 8);
      if (keys.ArrowDown) p2Y = Math.min(canvas.height - paddleHeight - 20, p2Y + 8);
    } else {
      // Enhanced AI with prediction and imperfection
      const targetY = ballY - paddleHeight / 2;
      const diff = targetY - p2Y;
      p2Y += diff * aiDifficulty + (Math.random() - 0.5) * 2; // Add some randomness
      p2Y = Math.max(20, Math.min(canvas.height - paddleHeight - 20, p2Y));
    }
  }

  function createParticles(x, y, color, count) {
    for (let i = 0; i < count; i++) {
      particles.push({
        x: x,
        y: y,
        vx: (Math.random() - 0.5) * 10,
        vy: (Math.random() - 0.5) * 10,
        life: 1,
        size: Math.random() * 4 + 2,
        color: color
      });
    }
  }

  function updateParticles() {
    particles = particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vy += 0.1;
      p.life -= 0.02;
      return p.life > 0;
    });
  }

  function drawParticles() {
    particles.forEach(p => {
      ctx.globalAlpha = p.life;
      ctx.fillStyle = p.color;
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
      ctx.fill();
    });
    ctx.globalAlpha = 1;
  }

  function drawTrail() {
    for (let i = 0; i < trail.length; i++) {
      const point = trail[i];
      const alpha = i / trail.length * 0.3;
      ctx.globalAlpha = alpha;
      ctx.fillStyle = `hsl(${200 + i * 2}, 100%, 60%)`;
      ctx.beginPath();
      ctx.arc(point.x, point.y, ballSize * (i / trail.length), 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.globalAlpha = 1;
  }

  function drawPaddle(x, y, color, isPlayer1) {
    // Shadow
    ctx.shadowColor = color;
    ctx.shadowBlur = 20;
    
    // Main paddle with gradient
    const gradient = ctx.createLinearGradient(x, y, x + paddleWidth, y + paddleHeight);
    gradient.addColorStop(0, color);
    gradient.addColorStop(1, 'rgba(255,255,255,0.8)');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(x, y, paddleWidth, paddleHeight);
    
    // Inner glow
    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
    ctx.lineWidth = 2;
    ctx.strokeRect(x + 2, y + 2, paddleWidth - 4, paddleHeight - 4);
    
    // Energy lines
    ctx.strokeStyle = 'rgba(255,255,255,0.3)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 3; i++) {
      const lineY = y + 10 + i * 30;
      ctx.beginPath();
      ctx.moveTo(x + 4, lineY);
      ctx.lineTo(x + paddleWidth - 4, lineY);
      ctx.stroke();
    }
    
    ctx.shadowBlur = 0;
  }

  function drawBall() {
    // Ball trail
    trail.unshift({x: ballX, y: ballY});
    if (trail.length > 10) trail.pop();
    drawTrail();
    
    // Main ball with glow
    ctx.shadowColor = '#3b82f6';
    ctx.shadowBlur = glowIntensity;
    
    // Outer glow
    const gradient = ctx.createRadialGradient(ballX, ballY, 0, ballX, ballY, ballSize * 2);
    gradient.addColorStop(0, 'rgba(59,130,246,0.8)');
    gradient.addColorStop(1, 'rgba(59,130,246,0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(ballX, ballY, ballSize * 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Main ball
    const ballGradient = ctx.createRadialGradient(
      ballX - ballSize/3, ballY - ballSize/3, 0,
      ballX, ballY, ballSize
    );
    ballGradient.addColorStop(0, '#fff');
    ballGradient.addColorStop(0.5, '#3b82f6');
    ballGradient.addColorStop(1, '#1e40af');
    
    ctx.fillStyle = ballGradient;
    ctx.beginPath();
    ctx.arc(ballX, ballY, ballSize, 0, Math.PI * 2);
    ctx.fill();
    
    // Highlight
    ctx.fillStyle = 'rgba(255,255,255,0.6)';
    ctx.beginPath();
    ctx.arc(ballX - ballSize/3, ballY - ballSize/3, ballSize/3, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.shadowBlur = 0;
  }

  function updateBall() {
    ballX += ballDX;
    ballY += ballDY;
    
    // Ball trail effect
    glowIntensity = Math.min(50, glowIntensity + 1);
    
    // Wall collision with enhanced physics
    if (ballY < ballSize || ballY > canvas.height - ballSize) {
      ballDY *= -1;
      createParticles(ballX, ballY, '#3b82f6', 8);
      playPongSFX('wall');
      screenShake = 5;
    }
    
    // Paddle collision with enhanced physics
    const hitP1 = ballX - ballSize < 30 + paddleWidth && 
                  ballY > p1Y && ballY < p1Y + paddleHeight;
                  
    const hitP2 = ballX + ballSize > canvas.width - 30 - paddleWidth && 
                  ballY > p2Y && ballY < p2Y + paddleHeight;
    
    if (hitP1 || hitP2) {
      // Enhanced ball physics based on hit position
      const paddle = hitP1 ? p1Y : p2Y;
      const hitPos = (ballY - paddle) / paddleHeight;
      const angle = (hitPos - 0.5) * Math.PI / 2; // -45 to 45 degrees
      
      const speed = Math.sqrt(ballDX * ballDX + ballDY * ballDY);
      ballDX = hitP1 ? Math.cos(angle) * speed : -Math.cos(angle) * speed;
      ballDY = Math.sin(angle) * speed;
      
      // Speed up slightly
      ballDX *= 1.05;
      ballDY *= 1.05;
      
      // Visual effects
      createParticles(ballX, ballY, hitP1 ? '#667eea' : '#f5576c', 15);
      glowIntensity = 80;
      screenShake = 8;
      playPongSFX('paddle');
    }
    
    // Scoring
    if (ballX < 0) {
      p2Score++;
      p2ScoreEl.textContent = p2Score;
      resetBall();
      playPongSFX('score');
      createParticles(canvas.width/2, canvas.height/2, '#f5576c', 30);
    } else if (ballX > canvas.width) {
      p1Score++;
      p1ScoreEl.textContent = p1Score;
      resetBall();
      playPongSFX('score');
      createParticles(canvas.width/2, canvas.height/2, '#667eea', 30);
    }
  }

  function resetBall() {
    ballX = canvas.width / 2;
    ballY = canvas.height / 2;
    ballDX = (Math.random() > 0.5 ? 5 : -5);
    ballDY = (Math.random() - 0.5) * 8;
    trail = [];
    glowIntensity = 0;
    
    // Update best score
    const currentBest = parseInt(localStorage.getItem("pongBest") || 0);
    const maxScore = Math.max(p1Score, p2Score);
    if (maxScore > currentBest) {
      localStorage.setItem("pongBest", maxScore.toString());
      bestEl.textContent = maxScore;
    }
  }

  function draw() {
    // Clear with screen shake
    ctx.save();
    if (screenShake > 0) {
      ctx.translate((Math.random() - 0.5) * screenShake, (Math.random() - 0.5) * screenShake);
      screenShake *= 0.8;
      if (screenShake < 0.1) screenShake = 0;
    }
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw background elements
    drawBackground();
    
    // Draw game elements
    drawPaddle(30, p1Y, '#667eea', true);
    drawPaddle(canvas.width - 30 - paddleWidth, p2Y, '#f5576c', false);
    drawBall();
    drawParticles();
    
    ctx.restore();
  }

  function drawBackground() {
    // Grid pattern
    ctx.strokeStyle = 'rgba(59,130,246,0.1)';
    ctx.lineWidth = 1;
    
    for (let x = 0; x < canvas.width; x += 40) {
      ctx.beginPath();
      ctx.moveTo(x, 0);
      ctx.lineTo(x, canvas.height);
      ctx.stroke();
    }
    
    for (let y = 0; y < canvas.height; y += 40) {
      ctx.beginPath();
      ctx.moveTo(0, y);
      ctx.lineTo(canvas.width, y);
      ctx.stroke();
    }
    
    // Pulsing center dot
    const pulse = Math.sin(Date.now() * 0.005) * 3 + 5;
    ctx.fillStyle = 'rgba(59,130,246,0.3)';
    ctx.beginPath();
    ctx.arc(canvas.width/2, canvas.height/2, pulse, 0, Math.PI * 2);
    ctx.fill();
  }

  function playPongSFX(type) {
    const actx = audioCtx;
    const o = actx.createOscillator();
    const g = actx.createGain();
    o.connect(g);
    g.connect(actx.destination);
    const now = actx.currentTime;
    
    if (type === 'paddle') {
      o.type = 'sine';
      o.frequency.setValueAtTime(400, now);
      o.frequency.setValueAtTime(600, now + 0.1);
      g.gain.setValueAtTime(0.1, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
    } else if (type === 'wall') {
      o.type = 'triangle';
      o.frequency.setValueAtTime(300, now);
      o.frequency.setValueAtTime(200, now + 0.1);
      g.gain.setValueAtTime(0.08, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
    } else if (type === 'score') {
      o.type = 'square';
      o.frequency.setValueAtTime(200, now);
      o.frequency.setValueAtTime(300, now + 0.1);
      o.frequency.setValueAtTime(400, now + 0.2);
      g.gain.setValueAtTime(0.15, now);
      g.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
    }
    
    o.start(now);
    o.stop(now + 0.5);
  }

  function gameLoop() {
    if (!gameRunning) return;
    
    updatePaddles();
    updateBall();
    updateParticles();
    draw();
    
    requestAnimationFrame(gameLoop);
  }

  // Controls
  window.addEventListener("keydown", e => {
    if (['w', 's', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
      keys[e.key] = true;
      e.preventDefault();
    }
  });
  
  window.addEventListener("keyup", e => {
    if (['w', 's', 'ArrowUp', 'ArrowDown'].includes(e.key)) {
      keys[e.key] = false;
      e.preventDefault();
    }
  });

  // Start the game
  gameLoop();

  // Clean up when window closes
  const originalClose = win.querySelector('[data-act="close"]').onclick;
  win.querySelector('[data-act="close"]').onclick = () => {
    gameRunning = false;
    document.head.removeChild(style);
    originalClose();
  };
}

function openMusicPlayer(fileKey) {
  const fsObj = getFS();
  
  // If specific file requested, play it directly
  if(fileKey && fsObj[fileKey] && fsObj[fileKey].type === 'file' && fsObj[fileKey].mime && fsObj[fileKey].mime.startsWith('audio/')) {
    const audioWin = makeWin('Music Player', 480, 200, `
      <div style="display:flex;flex-direction:column;height:100%;align-items:center;gap:8px;padding:8px">
        <div id="mpTitle" class="small" style="font-weight:600">${fileKey.split('/').pop()}</div>
        <audio id="mpAudio" controls style="width:100%">
          Your browser does not support the audio element.
        </audio>
        <div style="display:flex;gap:8px">
          <button class="btn" id="mpStop">Stop</button>
          <button class="btn" id="mpLibrary" style="background:rgba(255,255,255,0.1)">Library</button>
        </div>
        <div id="mpStatus" class="small" style="color:var(--muted)"></div>
      </div>
    `);
    
    const audioEl = audioWin.querySelector('#mpAudio');
    const statusEl = audioWin.querySelector('#mpStatus');
    
    // Use the data URL directly
    audioEl.src = fsObj[fileKey].data;
    
    audioEl.onerror = () => {
      statusEl.textContent = 'Error: Could not play audio file';
      statusEl.style.color = '#ef4444';
    };
    
    audioEl.oncanplay = () => {
      statusEl.textContent = 'Ready to play';
      statusEl.style.color = '#10b981';
    };
    
    audioEl.play().catch(e => {
      statusEl.textContent = 'Click play to start audio';
      statusEl.style.color = '#f59e0b';
    });
    
    audioWin.querySelector('#mpStop').onclick = () => { 
      audioEl.pause(); 
      audioEl.currentTime = 0; 
      statusEl.textContent = 'Stopped';
    };
    
    audioWin.querySelector('#mpLibrary').onclick = () => {
      openMusicPlayer(); // Open library
      ctrl('close', audioWin);
    };
    
    return;
  }
  
  // Show music library
  const win = makeWin('Music Library', 520, 380, `
    <div style="padding:10px;display:flex;flex-direction:column;height:100%">
      <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center">
        <div style="flex:1;font-weight:600">Music Library</div>
        <input type="file" id="musicImporter" accept="audio/*" multiple style="display:none" />
        <button class="btn" id="btnImportMusic">üìÅ Import Music</button>
      </div>
      <div id="musicList" style="flex:1;overflow:auto"></div>
    </div>
  `);
  
  const list = win.querySelector('#musicList');
  const importer = win.querySelector('#musicImporter');
  
  win.querySelector('#btnImportMusic').onclick = () => importer.click();
  
  importer.onchange = async (e) => {
    const files = Array.from(e.target.files || []);
    if(files.length === 0) return;
    
    const fsObj = getFS();
    let importedCount = 0;
    
    for(const file of files) {
      const reader = new FileReader();
      await new Promise(res => {
        reader.onload = () => {
          // Create proper file path
          const fileName = file.name;
          const filePath = '/Music/' + fileName;
          
          // Check if file already exists
          if(fsObj[filePath]) {
            console.log('File already exists:', fileName);
            res();
            return;
          }
          
          // Store file with proper structure
          fsObj[filePath] = { 
            type: 'file', 
            mime: file.type || 'audio/mpeg', 
            data: reader.result
          };
          
          // Ensure Music directory exists with correct structure
          if(!fsObj['/Music']) {
            fsObj['/Music'] = { type: 'dir', children: [] };
          }
          
          // Add to Music folder's children if not already there
          if(!fsObj['/Music'].children.includes(fileName)) {
            fsObj['/Music'].children.push(fileName);
          }
          
          importedCount++;
          res();
        };
        
        reader.onerror = () => {
          console.error('Error reading file:', file.name);
          res();
        };
        
        // Read as data URL
        reader.readAsDataURL(file);
      });
    }
    
    setFS(fsObj);
    
    if(importedCount > 0) {
      showNotification('Music Imported', `${importedCount} songs added to library`, 'success', 3500);
      renderMusicList();
    } else {
      showNotification('Import Failed', 'No new files were imported', 'error', 3000);
    }
    
    importer.value = '';
  };
  
  function renderMusicList() {
    const fsObj = getFS();
    const musicFiles = [];
    
    // Find all audio files by checking directories
    function scanDirectory(path) {
      const dir = fsObj[path];
      if(dir && dir.type === 'dir' && dir.children) {
        dir.children.forEach(childName => {
          const childPath = path === '/' ? '/' + childName : path + '/' + childName;
          const childEntry = fsObj[childPath];
          
          if(childEntry && childEntry.type === 'file' && childEntry.mime && childEntry.mime.startsWith('audio/')) {
            musicFiles.push(childPath);
          } else if(childEntry && childEntry.type === 'dir') {
            scanDirectory(childPath);
          }
        });
      }
    }
    
    // Start scanning from root
    scanDirectory('/');
    
    if(musicFiles.length === 0) {
      list.innerHTML = '<div class="small" style="padding:20px;text-align:center">No music files found. Click "Import Music" to add songs.</div>';
      return;
    }
    
    list.innerHTML = '';
    musicFiles.forEach(filePath => {
      const entry = fsObj[filePath];
      const fileName = filePath.split('/').pop();
      
      const item = document.createElement('div');
      item.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:12px;border-radius:6px;background:rgba(255,255,255,0.02);margin-bottom:6px';
      item.innerHTML = `
        <div style="display:flex;align-items:center;gap:10px">
          <div style="font-size:24px">üéµ</div>
          <div style="flex:1">
            <div style="font-weight:600">${fileName}</div>
            <div class="small">${entry.mime} ‚Ä¢ ${Math.ceil((entry.data.length || 0) / 1024)} KB</div>
          </div>
        </div>
        <div style="display:flex;gap:6px">
          <button class="btn playM" data-k="${filePath}">Play</button>
          <button class="btn" style="background:#ef4444" data-del="${filePath}">Delete</button>
        </div>
      `;
      
      list.appendChild(item);
    });
    
    list.querySelectorAll('.playM').forEach(b => {
      b.onclick = () => openMusicPlayer(b.dataset.k);
    });
    
    list.querySelectorAll('[data-del]').forEach(b => {
      b.onclick = () => {
        if(!confirm('Delete this song?')) return;
        const filePath = b.dataset.del;
        const fileName = filePath.split('/').pop();
        const parentPath = filePath.split('/').slice(0, -1).join('/') || '/';
        
        const fs2 = getFS();
        
        // Remove from parent directory
        if(fs2[parentPath] && Array.isArray(fs2[parentPath].children)) {
          const idx = fs2[parentPath].children.indexOf(fileName);
          if(idx >= 0) fs2[parentPath].children.splice(idx, 1);
        }
        
        // Delete the file
        delete fs2[filePath];
        
        setFS(fs2);
        showNotification('Deleted', fileName, 'warning', 2500);
        renderMusicList();
      };
    });
  }
  
  renderMusicList();
}

function openVideoPlayer(fileKey) {
  const fsObj = getFS();
  
  // If specific file requested, play it directly
  if(fileKey && fsObj[fileKey] && fsObj[fileKey].type === 'file' && fsObj[fileKey].mime && fsObj[fileKey].mime.startsWith('video/')) {
    const vwin = makeWin('Video Player', 720, 420, `
      <div style="display:flex;flex-direction:column;height:100%">
        <div style="padding:8px;background:rgba(0,0,0,0.3);border-radius:6px 6px 0 0">
          <div class="small" style="text-align:center">${fileKey.split('/').pop()}</div>
        </div>
        <video id="vid" controls style="width:100%;height:100%;background:#000"></video>
      </div>
    `);
    const vid = vwin.querySelector('#vid');
    vid.src = fsObj[fileKey].data;
    vid.play().catch(() => {});
    return;
  }
  
  // Show video library
  const win = makeWin('Video Library', 520, 380, `
    <div style="padding:10px;display:flex;flex-direction:column;height:100%">
      <div style="display:flex;gap:8px;margin-bottom:8px;align-items:center">
        <div style="flex:1;font-weight:600">Video Library</div>
        <input type="file" id="videoImporter" accept="video/*" multiple style="display:none" />
        <button class="btn" id="btnImportVideo">üìÅ Import Videos</button>
      </div>
      <div id="videoList" style="flex:1;overflow:auto"></div>
    </div>
  `);
  
  const list = win.querySelector('#videoList');
  const importer = win.querySelector('#videoImporter');
  
  win.querySelector('#btnImportVideo').onclick = () => importer.click();
  
  importer.onchange = async (e) => {
    const files = Array.from(e.target.files || []);
    if(files.length === 0) return;
    
    const fsObj = getFS();
    let importedCount = 0;
    
    for(const file of files) {
      const reader = new FileReader();
      await new Promise(res => {
        reader.onload = () => {
          const fileName = file.name;
          const filePath = '/Videos/' + fileName;
          
          // Check if file already exists
          if(fsObj[filePath]) {
            console.log('File already exists:', fileName);
            res();
            return;
          }
          
          // Store file
          fsObj[filePath] = { 
            type: 'file', 
            mime: file.type || 'video/mp4', 
            data: reader.result 
          };
          
          // Ensure Videos directory exists
          if(!fsObj['/Videos']) {
            fsObj['/Videos'] = { type: 'dir', children: [] };
          }
          
          // Add to Videos folder's children
          if(!fsObj['/Videos'].children.includes(fileName)) {
            fsObj['/Videos'].children.push(fileName);
          }
          
          importedCount++;
          res();
        };
        reader.readAsDataURL(file);
      });
    }
    
    setFS(fsObj);
    
    if(importedCount > 0) {
      showNotification('Videos Imported', `${importedCount} videos added to library`, 'success', 3500);
      renderVideoList();
    } else {
      showNotification('Import Failed', 'No new files were imported', 'error', 3000);
    }
    
    importer.value = '';
  };
  
  function renderVideoList() {
    const fsObj = getFS();
    const videoFiles = [];
    
    // Find all video files by checking directories
    function scanDirectory(path) {
      const dir = fsObj[path];
      if(dir && dir.type === 'dir' && dir.children) {
        dir.children.forEach(childName => {
          const childPath = path === '/' ? '/' + childName : path + '/' + childName;
          const childEntry = fsObj[childPath];
          
          if(childEntry && childEntry.type === 'file' && childEntry.mime && childEntry.mime.startsWith('video/')) {
            videoFiles.push(childPath);
          } else if(childEntry && childEntry.type === 'dir') {
            scanDirectory(childPath);
          }
        });
      }
    }
    
    // Start scanning from root
    scanDirectory('/');
    
    if(videoFiles.length === 0) {
      list.innerHTML = '<div class="small" style="padding:20px;text-align:center">No videos found. Click "Import Videos" to add videos.</div>';
      return;
    }
    
    list.innerHTML = '';
    videoFiles.forEach(filePath => {
      const entry = fsObj[filePath];
      const fileName = filePath.split('/').pop();
      
      const item = document.createElement('div');
      item.style.cssText = 'display:flex;align-items:center;justify-content:space-between;padding:12px;border-radius:6px;background:rgba(255,255,255,0.02);margin-bottom:6px';
      item.innerHTML = `
        <div style="display:flex;align-items:center;gap:10px">
          <div style="font-size:24px">üé¨</div>
          <div>
            <div style="font-weight:600">${fileName}</div>
            <div class="small">${entry.mime} ‚Ä¢ ${Math.ceil(entry.data.length / 1024)} KB</div>
          </div>
        </div>
        <div style="display:flex;gap:6px">
          <button class="btn playV" data-k="${filePath}">Play</button>
          <button class="btn" style="background:#ef4444" data-del="${filePath}">Delete</button>
        </div>
      `;
      
      list.appendChild(item);
    });
    
    list.querySelectorAll('.playV').forEach(b => {
      b.onclick = () => openVideoPlayer(b.dataset.k);
    });
    
    list.querySelectorAll('[data-del]').forEach(b => {
      b.onclick = () => {
        if(!confirm('Delete this video?')) return;
        const filePath = b.dataset.del;
        const fileName = filePath.split('/').pop();
        const parentPath = filePath.split('/').slice(0, -1).join('/') || '/';
        
        const fs2 = getFS();
        
        // Remove from parent directory
        if(fs2[parentPath] && Array.isArray(fs2[parentPath].children)) {
          const idx = fs2[parentPath].children.indexOf(fileName);
          if(idx >= 0) fs2[parentPath].children.splice(idx, 1);
        }
        
        // Delete the file
        delete fs2[filePath];
        
        setFS(fs2);
        showNotification('Deleted', fileName, 'warning', 2500);
        renderVideoList();
      };
    });
  }
  
  renderVideoList();
}


// ---------------- Screenshot App (capture + editor) ----------------

// ---------------- Screenshot App (capture + editor) ----------------

function openScreenshotTool() {

    startRegionCapture();

    function startRegionCapture() {

        const overlay = document.createElement("div");
        overlay.style.position = "fixed";
        overlay.style.left = "0";
        overlay.style.top = "0";
        overlay.style.width = "100vw";
        overlay.style.height = "100vh";
        overlay.style.cursor = "crosshair";
        overlay.style.background = "rgba(0,0,0,0.1)";
        overlay.style.zIndex = "999999999";
        document.body.appendChild(overlay);

        let startX = 0, startY = 0, endX = 0, endY = 0;
        let dragging = false;

        const box = document.createElement("div");
        box.style.position = "fixed";
        box.style.border = "2px solid #3b82f6";
        box.style.background = "rgba(59,130,246,0.2)";
        box.style.zIndex = "9999999999";
        box.style.display = "none";
        document.body.appendChild(box);

        overlay.addEventListener("mousedown", e => {
            dragging = true;
            startX = e.clientX;
            startY = e.clientY;
            box.style.display = "block";
        });

        overlay.addEventListener("mousemove", e => {
            if (!dragging) return;

            endX = e.clientX;
            endY = e.clientY;

            const x = Math.min(startX, endX);
            const y = Math.min(startY, endY);
            const w = Math.abs(startX - endX);
            const h = Math.abs(startY - endY);

            box.style.left = x + "px";
            box.style.top = y + "px";
            box.style.width = w + "px";
            box.style.height = h + "px";
        });

        overlay.addEventListener("mouseup", async () => {
            dragging = false;
            box.style.display = "none";

            const x = parseInt(box.style.left);
            const y = parseInt(box.style.top);
            const w = parseInt(box.style.width);
            const h = parseInt(box.style.height);

            // Remove overlays BEFORE capture
            overlay.remove();
            box.remove();
            document.body.classList.add("screenshot-clean");

            // Disable blur to avoid screenshot glitches
            document.body.classList.add("screenshot-clean");

            // Wait one frame so browser repaints cleanly
            await new Promise(r => requestAnimationFrame(r));
            await new Promise(r => requestAnimationFrame(r));

            // Capture ONLY the selected region
            const capture = await html2canvas(document.body, {
                x: x,
                y: y,
                width: w,
                height: h,
                scrollX: 0,
                scrollY: 0,
                backgroundColor: null,
                useCORS: true,
                scale: 1
            });

            // Restore blur
            document.body.classList.remove("screenshot-clean");

            openScreenshotEditor(capture);

        });
    }
}

function openScreenshotEditor(imageCanvas) {
    const win = makeWin("Screenshot Editor", 1000, 600, `
        <div style="display:flex;height:100%;padding:10px;gap:10px;">
            <div style="display:flex;flex-direction:column;gap:10px;width:150px;">
                <button id="toolBrush" class="btn">üñåÔ∏è Brush</button>
                <button id="toolText" class="btn">üî§ Text</button>
                <input id="textSize" type="number" value="32" min="10" style="padding:5px;border-radius:5px;">
                <button id="saveImg" class="btn" style="background:#22c55e;">üíæ Save</button>
            </div>
            <div style="flex:1;background:#111;border-radius:10px;overflow:auto;">
                <canvas id="editCanvas"></canvas>
            </div>
        </div>
    `);

    const canvas = win.querySelector("#editCanvas");
    const ctx = canvas.getContext("2d");

    canvas.width = imageCanvas.width;
    canvas.height = imageCanvas.height;

    ctx.drawImage(imageCanvas, 0, 0);

    let tool = "brush";
    let drawing = false;

    win.querySelector("#toolBrush").onclick = () => tool = "brush";
    win.querySelector("#toolText").onclick = () => tool = "text";

    canvas.onmousedown = (e) => {
        if (tool === "brush") {
            drawing = true;
            ctx.lineWidth = 4;
            ctx.lineCap = "round";
            ctx.strokeStyle = "#ffffff";
            ctx.beginPath();
            ctx.moveTo(e.offsetX, e.offsetY);

        } else if (tool === "text") {
            const size = parseInt(win.querySelector("#textSize").value);
            ctx.font = size + "px Arial";
            ctx.fillStyle = "white";
            const t = prompt("Enter text:");
            if (t) ctx.fillText(t, e.offsetX, e.offsetY);
        }
    };

    canvas.onmousemove = (e) => {
        if (tool === "brush" && drawing) {
            ctx.lineTo(e.offsetX, e.offsetY);
            ctx.stroke();
        }
    };

    canvas.onmouseup = () => drawing = false;

    // Save button
    win.querySelector("#saveImg").onclick = () => {
        const dataURL = canvas.toDataURL("image/png");
        const fileName = "Screenshot_" + Date.now() + ".png";

        const fs = getFS();

        if (!fs['/Pictures']) {
            fs['/Pictures'] = { type: 'dir', children: [] };
            fs['/'].children.push('Pictures');
        }

        if (!fs['/Pictures/Screenshots']) {
            fs['/Pictures/Screenshots'] = { type: 'dir', children: [] };
            fs['/Pictures'].children.push('Screenshots');
        }

        const path = "/Pictures/Screenshots/" + fileName;
        fs[path] = { type: 'file', mime: 'image/png', data: dataURL };

        fs['/Pictures/Screenshots'].children.push(fileName);

        setFS(fs);

        showNotification("Screenshot Saved", fileName, "success", 3000);
        ctrl("close", win);
    };
}




// Search
$('startSearch').onkeydown=e=>{
  if(e.key==='Enter'){
    const q=e.target.value.toLowerCase();
    const apps=['explorer','editor','terminal','paint','snake','calculator','settings','about','browser'];
    const found=apps.find(a=>a.includes(q));
    if(found){
      openApp(found);
    }
    startMenu.classList.remove('open');
    e.target.value='';
    sfx('click');
  }
};
}


</script>
<script type="module">

import { initializeApp } from "https://www.gstatic.com/firebasejs/9.22.2/firebase-app.js";

import {
  getFirestore, doc, setDoc, getDoc, collection, addDoc, deleteDoc,
  query, orderBy, onSnapshot, runTransaction, where, getDocs, updateDoc,
  arrayUnion
} from "https://www.gstatic.com/firebasejs/9.22.2/firebase-firestore.js";

import {
  getAuth, signInAnonymously, onAuthStateChanged
} from "https://www.gstatic.com/firebasejs/9.22.2/firebase-auth.js";

// ------------------------------------------------------
// STYLES (inject)
const style = document.createElement('style');
style.textContent = `
/* --- chat styles (kept same as you provided, slightly tuned) --- */
.chat-wrap { display:flex; height:100%; width:100%; gap:12px; padding:12px; box-sizing:border-box; }
.friends-col { width:240px; display:flex; flex-direction:column; gap:8px; background:rgba(255,255,255,0.04); padding:12px; border-radius:12px; overflow:auto; }
.friend-item { display:flex; gap:10px; align-items:center; padding:10px; border-radius:10px; cursor:pointer; transition:all .12s; color: #fff; }
.friend-item:hover { transform: translateY(-2px); background: rgba(255,255,255,0.03); }
.friend-item.active { background: linear-gradient(135deg,#667eea,#764ba2); box-shadow:0 6px 18px rgba(0,0,0,0.25); }
.friend-name { font-weight:700; font-size:14px; color:inherit; }
.friend-sub { font-size:12px; opacity:0.8; color:inherit; }
.chat-col { flex:1; display:flex; flex-direction:column; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); border-radius:12px; overflow:hidden; }
.chat-header { padding:14px; display:flex; justify-content:space-between; align-items:center; gap:12px; backdrop-filter:blur(6px); border-bottom:1px solid rgba(255,255,255,0.03); }
.chat-title { font-weight:800; color:#fff; }
.messages-area { flex:1; padding:16px; display:flex; flex-direction:column; gap:10px; overflow:auto; background:linear-gradient(180deg, rgba(0,0,0,0), rgba(255,255,255,0.01)); }
.input-area { display:flex; gap:8px; padding:12px; border-top:1px solid rgba(255,255,255,0.03); align-items:center; }
.modern-input { padding:10px 12px; border-radius:10px; border:none; outline:none; flex:1; }
.send-btn, .record-btn { width:44px; height:44px; border-radius:50%; border:none; cursor:pointer; }
.message-wrapper { max-width:70%; display:flex; align-items:flex-end; gap:8px; position:relative; }
.message-wrapper.sent { margin-left:auto; }
.message-bubble { padding:10px 14px; border-radius:14px; font-size:14px; }
.message-bubble.sent { background:linear-gradient(135deg,#667eea,#764ba2); color:#fff; }
.message-bubble.received { background:rgba(255,255,255,0.95); color:#222; }
.voice-player { min-width: 200px; max-width: 420px; padding:10px; border-radius:14px; display:flex; gap:8px; align-items:center; }
.context-menu { position:fixed; background:#111; color:#fff; padding:6px; border-radius:6px; z-index:99999; box-shadow:0 6px 20px rgba(0,0,0,0.5); }
.context-menu button { display:block; width:100%; text-align:left; padding:6px 8px; border:none; background:transparent; color:inherit; cursor:pointer; }
.empty-state { text-align:center; opacity:0.8; padding:40px; }
.typing-indicator { font-size:13px; color:rgba(255,255,255,0.8); margin-bottom:6px; }

/* delete icon on hover */
.msg-del { opacity: 0; cursor:pointer; transition: opacity .15s ease; margin-left:6px; user-select:none; }
.message-wrapper:hover .msg-del { opacity: 1; }

/* friend item small adjustments */
.friend-item .friend-sub { font-size:12px; opacity:0.7; }

/* compact media queries */
@media (max-width:700px) {
  .friends-col { display:none; }
  .chat-col { border-radius:0; padding:0; }
}
`;
document.head.appendChild(style);

// ------------------------------------------------------
// GLOBALS
let myUid = null;
let db;
const firebaseConfig = {
  apiKey: "AIzaSyBgZJthL9SsgS3kxw-nr8d5Pqrufru3-1A",
  authDomain: "webos-chat.firebaseapp.com",
  projectId: "webos-chat",
  storageBucket: "webos-chat.firebasestorage.app",
  messagingSenderId: "864010564614",
  appId: "1:864010564614:web:6bc59f10b8f61a5222ff87"
};

const appFirebase = initializeApp(firebaseConfig);
const auth = getAuth(appFirebase);

// ---------------- Auth + helpers ----------------
async function login() {
  return new Promise((res) => {
    onAuthStateChanged(auth, async (user) => {
      if (user) return res(user);
      const u = await signInAnonymously(auth);
      res(u.user);
    });
  });
}

async function pickUsername(myUid) {
  const myRef = doc(db, "users", myUid);
  const snap = await getDoc(myRef);
  if (snap.exists() && snap.data().username) return snap.data().username;

  let username = null;
  while (!username) {
    let chosen = prompt("Choose a username:");
    if (!chosen) continue;
    chosen = chosen.trim().toLowerCase();
    const nameRef = doc(db, "usernames", chosen);
    try {
      await runTransaction(db, async (tx) => {
        const exists = await tx.get(nameRef);
        if (exists.exists()) throw "taken";
        tx.set(nameRef, { uid: myUid });
        tx.set(myRef, { username: chosen, friends: [] }, { merge: true });
      });
      username = chosen;
      alert("Username created: " + chosen);
    } catch (e) {
      alert("Username is taken. Try another.");
    }
  }
  return username;
}

async function addFriendByName(myUid, friendName) {
  const q = query(collection(db, "users"), where("username", "==", friendName));
  const snap = await getDocs(q);
  if (snap.empty) return { ok:false, reason:"User not found" };
  const user = snap.docs[0];
  const friendUid = user.id;
  if (friendUid === myUid) return { ok:false, reason:"You can't add yourself" };
  const ref1 = doc(db, "friends", `${myUid}_${friendUid}`);
  const ref2 = doc(db, "friends", `${friendUid}_${myUid}`);
  const snap1 = await getDoc(ref1);
  const snap2 = await getDoc(ref2);
  if (snap1.exists() || snap2.exists()) {
    return { ok:false, reason:"Already friends or pending request" };
  }
  await setDoc(ref1, {
    from: myUid,
    to: friendUid,
    status: "pending",
    ts: Date.now()
  });
  return { ok:true };
}

// ----------------- MEDIUM modern voice player (version C) -----------------
function createVoicePlayer(audioSrc, isSent) {
  // inject CSS once
  if (!document.getElementById('vp-medium-css')) {
    const css = document.createElement('style');
    css.id = 'vp-medium-css';
    css.textContent = `
      .vp-med { display:flex; gap:10px; align-items:center; padding:8px 10px; border-radius:12px; box-shadow: 0 8px 20px rgba(0,0,0,0.12); max-width:460px; }
      .vp-med.sent { background: linear-gradient(135deg,#6ea0ff, #8367e6); color:#fff; }
      .vp-med.received { background: rgba(255,255,255,0.95); color:#222; }

      .vp-btn { width:48px; height:48px; border-radius:50%; border:none; display:flex; align-items:center; justify-content:center; font-size:18px; cursor:pointer; box-shadow: 0 6px 14px rgba(0,0,0,0.12); }
      .vp-btn.playing { transform: scale(1.02); }
      .vp-btn.gradient { background: linear-gradient(135deg,#667eea 0%, #764ba2 100%); color:#fff; }

      .vp-body { flex:1; min-width:0; display:flex; flex-direction:column; gap:6px; }
      .vp-row { display:flex; align-items:center; gap:8px; }
      .vp-progress-wrap { position:relative; height:6px; background: rgba(255,255,255,0.12); border-radius:999px; cursor:pointer; overflow:hidden; flex:1; }
      .vp-progress { height:100%; width:0%; background: linear-gradient(90deg,#fff,#dfe8ff); border-radius:999px; transition: width 0.08s linear; }

      .vp-time { font-size:12px; opacity:0.9; min-width:60px; text-align:right; }
      .vp-wave { display:flex; gap:4px; align-items:flex-end; height:22px; width:110px; }
      .vp-wave .bar { width:4px; background: rgba(255,255,255,0.22); border-radius:2px; transition: height 0.12s ease; }
      .vp-wave.playing .bar { background: linear-gradient(135deg,#fff,#dfe8ff); }
      .vp-med.received .vp-wave .bar { background: rgba(0,0,0,0.08); }
    `;
    document.head.appendChild(css);
  }

  const container = document.createElement('div');
  container.className = 'vp-med ' + (isSent ? 'sent' : 'received');

  const audio = document.createElement('audio');
  audio.src = audioSrc;
  audio.preload = 'metadata';
  audio.style.display = 'none';

  const btn = document.createElement('button');
  btn.className = 'vp-btn gradient';
  btn.textContent = '‚ñ∂';

  const body = document.createElement('div');
  body.className = 'vp-body';

  const row = document.createElement('div');
  row.className = 'vp-row';

  const progressWrap = document.createElement('div');
  progressWrap.className = 'vp-progress-wrap';
  const progress = document.createElement('div');
  progress.className = 'vp-progress';
  progressWrap.appendChild(progress);

  const time = document.createElement('div');
  time.className = 'vp-time';
  time.textContent = '0:00 / 0:00';

  row.appendChild(progressWrap);
  row.appendChild(time);

  const wave = document.createElement('div');
  wave.className = 'vp-wave';
  for (let i = 0; i < 7; i++) {
    const bar = document.createElement('div');
    bar.className = 'bar';
    bar.style.height = `${4 + Math.floor(Math.random() * 8)}px`;
    wave.appendChild(bar);
  }

  body.appendChild(row);
  body.appendChild(wave);

  container.appendChild(btn);
  container.appendChild(body);
  container.appendChild(audio);

  let anim = null;

  function startWave() {
    if (anim) return;
    wave.classList.add('playing');
    anim = setInterval(() => {
      wave.querySelectorAll('.bar').forEach((b, i) => {
        const h = 4 + Math.round(Math.random() * (10 + (i % 3) * 4));
        b.style.height = h + 'px';
      });
    }, 120);
    btn.classList.add('playing');
  }

  function stopWave() {
    wave.classList.remove('playing');
    if (anim) { clearInterval(anim); anim = null; }
    wave.querySelectorAll('.bar').forEach((b, idx) => b.style.height = (4 + (idx % 4)) + 'px');
    btn.classList.remove('playing');
  }

  btn.onclick = () => {
    if (audio.paused) {
      audio.play().catch(()=>{});
      btn.textContent = '‚è∏';
      startWave();
    } else {
      audio.pause();
      btn.textContent = '‚ñ∂';
      stopWave();
    }
  };

  audio.onloadedmetadata = () => {
    const total = Math.floor(audio.duration || 0);
    time.textContent = `0:00 / ${Math.floor(total/60)}:${(total%60).toString().padStart(2,'0')}`;
  };

  audio.ontimeupdate = () => {
    const cur = Math.floor(audio.currentTime || 0);
    const total = Math.floor(audio.duration || 0) || 1;
    time.textContent = `${Math.floor(cur/60)}:${(cur%60).toString().padStart(2,'0')} / ${Math.floor(total/60)}:${(total%60).toString().padStart(2,'0')}`;
    const pct = (audio.currentTime / total) * 100;
    progress.style.width = `${pct}%`;
  };

  audio.onended = () => {
    btn.textContent = '‚ñ∂';
    stopWave();
    progress.style.width = '0%';
    audio.currentTime = 0;
  };

  progressWrap.onclick = (e) => {
    const rect = progressWrap.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const pct = x / rect.width;
    if (!isFinite(audio.duration) || audio.duration === 0) return;
    audio.currentTime = pct * audio.duration;
  };

  audio.onpause = () => { stopWave(); btn.textContent = '‚ñ∂'; };

  return container;
}

// ----------------- openChat (main) -----------------
async function openChat() {
  const user = await login();
  myUid = user.uid;
  db = getFirestore(appFirebase);
  const myUsername = await pickUsername(myUid);

  // Watch friend requests
  const reqRef = collection(db, "friends");
  const qReq = query(reqRef, where("to", "==", myUid), where("status", "==", "pending"));
  onSnapshot(qReq, snap => {
    snap.forEach(docSnap => {
      const data = docSnap.data();
      showFriendRequest(docSnap.id, data.from);
    });
  });

  // --- window markup: friends column + chat column ---
  const win = makeWin("Chat ‚Äî " + myUsername, 760, 520, `
    <div style="height:100%; display:flex; gap:12px;">
      <div id="friendsPanel" class="friends-col">
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px;">
          <input id="addFriendName" class="modern-input" placeholder="Add friend by username" style="flex:1;" />
          <button id="addFriendBtn" class="modern-btn">Add</button>
        </div>
        <div id="friendsListInner" style="display:flex;flex-direction:column;gap:6px;"></div>
      </div>

      <div class="chat-col" style="flex:1;">
        <div class="chat-header">
          <div>
            <div class="chat-title" id="chatTitle">Select a friend</div>
            <div id="chatSubtitle" style="font-size:12px; opacity:0.75; color:rgba(255,255,255,0.85)">Online</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;">
            <button id="refreshFriends" class="modern-btn">‚ü≥</button>
          </div>
        </div>

        <div id="messages" class="messages-area">
          <div id="typingIndicator" class="typing-indicator" style="display:none;">‚úçÔ∏è Typing...</div>
          <div id="emptyState" class="empty-state">
            <div style="font-size:40px; margin-bottom:10px;">üí¨</div>
            Start a conversation by selecting a friend
          </div>
        </div>

        <div class="input-area">
          <button id="recBtn" class="record-btn" title="Record voice">üé§</button>
          <input id="msg" class="modern-input" placeholder="Type a message..." />
          <button id="sendMsg" class="send-btn">‚û§</button>
        </div>
      </div>
    </div>
  `);

  // --- elements & state ---
  const addFriendName = win.querySelector("#addFriendName");
  const addFriendBtn = win.querySelector("#addFriendBtn");
  const friendsListInner = win.querySelector("#friendsListInner");
  const refreshFriends = win.querySelector("#refreshFriends");
  const messagesEl = win.querySelector("#messages");
  const msgInput = win.querySelector("#msg");
  const sendMsgBtn = win.querySelector("#sendMsg");
  const recBtn = win.querySelector("#recBtn");
  const chatTitle = win.querySelector("#chatTitle");
  const emptyState = win.querySelector("#emptyState");

  let selectedFriend = null; // uid of currently opened friend
  let unsub = null;
  let localTypingTimeout = null;
  let mediaStream = null, mediaRecorder = null, recordedChunks = [], isRecording = false;

  // --- recording UI ---
  function setRecUI(recording){
    if(recording){
      recBtn.classList.add('recording');
      recBtn.textContent = '‚è∫';
    } else {
      recBtn.classList.remove('recording');
      recBtn.textContent = 'üé§';
    }
  }

  async function startRecording() {
    if (isRecording) return;
    try {
      mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    } catch (e) {
      alert("Microphone access denied or not available.");
      return;
    }
    recordedChunks = [];
    const mime = MediaRecorder.isTypeSupported('audio/webm') ? 'audio/webm' : (MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : '');
    mediaRecorder = mime ? new MediaRecorder(mediaStream, { mimeType: mime }) : new MediaRecorder(mediaStream);
    mediaRecorder.ondataavailable = (e) => { if (e.data && e.data.size > 0) recordedChunks.push(e.data); };
    mediaRecorder.onstop = async () => {
      const blob = new Blob(recordedChunks, { type: mediaRecorder.mimeType || 'audio/webm' });
      await uploadAndSendVoice(blob, mediaRecorder.mimeType || 'audio/webm');
      try { mediaStream.getTracks().forEach(t => t.stop()); } catch(e){}
      mediaStream = null; mediaRecorder = null; recordedChunks = []; isRecording = false; setRecUI(false);
    };
    mediaRecorder.start();
    isRecording = true; setRecUI(true);
    setTimeout(() => { if (isRecording) stopRecording(); }, 60_000);
  }

  function stopRecording() { if (!isRecording || !mediaRecorder) return; mediaRecorder.stop(); }

  async function uploadAndSendVoice(blob, contentType) {
    try {
      if (!selectedFriend) return alert("Pick a friend first.");
      const id = chatId(myUid, selectedFriend);
      const msgsRef = collection(db, "chats", id, "messages");

      const reader = new FileReader();
      reader.onload = async () => {
        const base64Audio = reader.result; // data:...;base64,...
        await addDoc(msgsRef, {
          from: myUid,
          audioBase64: base64Audio,
          audioType: contentType,
          ts: Date.now()
        });
      };
      reader.readAsDataURL(blob);

    } catch (err) {
      console.error("Voice DB error:", err);
      alert("Failed to send voice message.");
    }
  }

  recBtn.onclick = async () => {
    if (!isRecording) await startRecording();
    else stopRecording();
  };

  // ---------------- friends list (left column)
  async function loadFriendsPanel() {
    friendsListInner.innerHTML = '';
    const meRef = doc(db, "users", myUid);
    const snap = await getDoc(meRef);
    if (!snap.exists()) return;
    const friends = snap.data().friends || [];

    // remove duplicates using Set and preserve order
    const unique = [...new Set(friends)];

    // show placeholder if empty
    if (unique.length === 0) {
      friendsListInner.innerHTML = `<div style="opacity:0.8">No friends yet</div>`;
      return;
    }

    // For each friend, create a list item
    for (const f of unique) {
      const fUser = await getDoc(doc(db, "users", f));
      const uname = fUser.exists() ? fUser.data().username : f;

      const item = document.createElement('div');
      item.className = 'friend-item';
      item.dataset.uid = f;

      const name = document.createElement('div');
      name.className = 'friend-name';
      name.textContent = uname;

      const sub = document.createElement('div');
      sub.className = 'friend-sub';
      sub.textContent = 'Tap to chat';

      item.appendChild(name);
      item.appendChild(sub);

      item.onclick = () => {
        // mark active
        document.querySelectorAll('.friend-item').forEach(i=>i.classList.remove('active'));
        item.classList.add('active');
        openConversation(f, uname);
      };

      friendsListInner.appendChild(item);
    }
  }

  // Use a single snapshot listener to load friends (prevents duplicates)
  const friendDoc = doc(db, "users", myUid);
  onSnapshot(friendDoc, () => { loadFriendsPanel(); });

  window.loadFriends = loadFriendsPanel;

  addFriendBtn.onclick = async () => {
    const name = addFriendName.value.trim();
    if (!name) return;
    const res = await addFriendByName(myUid, name);
    if (!res.ok) return alert("Could not add friend: " + res.reason);
    addFriendName.value = "";
    alert("Friend request sent!");
  };

  refreshFriends.onclick = loadFriendsPanel;

  // chat helpers
  function chatId(a,b){ return [a,b].sort().join("_"); }

  // ---------- typing indicator (SHORT typing) ----------
  function setTypingState(targetId, val) {
    const id = chatId(myUid, targetId);
    const typingRef = doc(db, "chats", id, "typing", myUid);
    setDoc(typingRef, { typing: val });
  }

  msgInput.oninput = () => {
    if (!selectedFriend) return;
    setTypingState(selectedFriend, true);
    if (localTypingTimeout) clearTimeout(localTypingTimeout);
    localTypingTimeout = setTimeout(() => {
      setTypingState(selectedFriend, false);
    }, 900); // short typing window
  };

  // ---------- open conversation (loads messages for friend) ----------
  async function openConversation(friendUid, friendName) {
    selectedFriend = friendUid;
    chatTitle.textContent = friendName || friendUid;
    emptyState.style.display = 'none';
    messagesEl.querySelectorAll('.message-wrapper').forEach(n=>n.remove());

    const id = chatId(myUid, friendUid);
    const cRef = doc(db, "chats", id);
    const cSnap = await getDoc(cRef);
    if (!cSnap.exists()) await setDoc(cRef, { participants:[myUid, friendUid] });

    // unsubscribe previous
    if (unsub) unsub();

    // subscribe typing sub and messages combined
    const msgsRef = collection(db, "chats", id, "messages");
    const q = query(msgsRef, orderBy("ts","asc"));
    unsub = onSnapshot(q, (snap) => {
      messagesEl.innerHTML = '';
      // typing indicator subscribe
      const typingRef = collection(db, "chats", id, "typing");
      onSnapshot(typingRef, (tSnap) => {
        let friendTyping = false;
        tSnap.forEach((docSnap) => {
          if (docSnap.id !== myUid && docSnap.data().typing) friendTyping = true;
        });
        const typingEl = document.getElementById("typingIndicator");
        if (!typingEl) return;
        typingEl.style.display = friendTyping ? "block" : "none";
      });

      snap.forEach((m) => {
        const d = m.data();
        const wrapper = document.createElement('div');
        wrapper.className = `message-wrapper ${d.from === myUid ? 'sent' : 'received'}`;
        wrapper.dataset.msgId = m.id;

        // construct content
        if (d.audioBase64) {
          const player = createVoicePlayer(d.audioBase64, d.from === myUid);
          wrapper.appendChild(player);
        } else if (d.text) {
          const bubble = document.createElement("div");
          bubble.className = `message-bubble ${d.from === myUid ? 'sent' : 'received'}`;
          bubble.textContent = d.text;
          wrapper.appendChild(bubble);
        } else {
          const bubble = document.createElement("div");
          bubble.className = `message-bubble ${d.from === myUid ? 'sent' : 'received'}`;
          bubble.textContent = "(unknown message)";
          wrapper.appendChild(bubble);
        }

        // small delete icon (hover to reveal)
        const del = document.createElement('div');
        del.className = 'msg-del';
        del.textContent = 'üóëÔ∏è';
        del.title = 'Delete';

        del.onclick = async (ev) => {
          ev.stopPropagation();
          const confirmEveryone = d.from === myUid ? confirm("Delete for everyone? (OK = yes, Cancel = delete locally)") : null;
          const chatIdVal = chatId(myUid, friendUid);

          if (d.from === myUid && confirmEveryone) {
            try {
              await deleteDoc(doc(db, "chats", chatIdVal, "messages", m.id));
            } catch (err) {
              console.error("Delete failed", err);
              alert("Could not delete for everyone.");
            }
          } else {
            // local only: remove DOM node
            wrapper.remove();
          }
        };

        wrapper.appendChild(del);

        // Right-click context menu for extra options (keeps old behavior)
        wrapper.oncontextmenu = (ev) => {
          ev.preventDefault();
          showContextMenu(ev.clientX, ev.clientY, {
            deleteLocal: () => { wrapper.remove(); },
            deleteForEveryone: async () => {
              if (d.from !== myUid) return alert("Only message sender can delete for everyone.");
              try {
                await deleteDoc(doc(db, "chats", id, "messages", m.id));
              } catch (err) {
                console.error(err);
                alert("Could not delete for everyone.");
              }
            }
          }, d.from === myUid);
        };

        messagesEl.appendChild(wrapper);
      });

      // scroll bottom
      messagesEl.scrollTop = messagesEl.scrollHeight;
    });
  }

  // ---------- send text message ----------
  sendMsgBtn.onclick = async () => {
    if (!selectedFriend) return alert("Pick a friend first!");
    const text = msgInput.value.trim();
    if (!text) return;
    const id = chatId(myUid, selectedFriend);
    const msgsRef = collection(db, "chats", id, "messages");
    await addDoc(msgsRef, { from: myUid, text, ts: Date.now() });
    msgInput.value = '';
    // turn off typing quickly
    setTypingState(selectedFriend, false);
  };

  msgInput.onkeypress = (e) => { if (e.key === 'Enter') sendMsgBtn.click(); };

  // ---------- context menu helper ----------
  function showContextMenu(x, y, actions, canDeleteForEveryone) {
    document.querySelectorAll('.context-menu').forEach(n=>n.remove());
    const menu = document.createElement('div');
    menu.className = 'context-menu';
    menu.style.left = x + 'px';
    menu.style.top = y + 'px';

    const btnLocal = document.createElement('button');
    btnLocal.textContent = 'Delete locally';
    btnLocal.onclick = () => { actions.deleteLocal(); menu.remove(); };
    menu.appendChild(btnLocal);

    if (canDeleteForEveryone) {
      const btnEveryone = document.createElement('button');
      btnEveryone.textContent = 'Delete for everyone';
      btnEveryone.onclick = () => { actions.deleteForEveryone(); menu.remove(); };
      menu.appendChild(btnEveryone);
    }

    const btnCancel = document.createElement('button');
    btnCancel.textContent = 'Cancel';
    btnCancel.onclick = () => { menu.remove(); };
    menu.appendChild(btnCancel);

    document.body.appendChild(menu);

    const rm = (ev) => { if (!menu.contains(ev.target)) menu.remove(); document.removeEventListener('click', rm); };
    setTimeout(()=>document.addEventListener('click', rm), 30);
  }

  // ---------- utility: friend requests UI ----------
  function showFriendRequest(reqId, fromUid) {
    const winFr = makeWin("Friend Request", 300, 160, `
      <div style="padding:10px;">
        <p><b>${fromUid}</b> wants to be your friend.</p>
        <button id="acc">Accept</button>
        <button id="rej">Reject</button>
      </div>
    `);
    winFr.setAttribute("data-friend-req", reqId);
    winFr.querySelector("#acc").onclick = async () => {
      await updateDoc(doc(db, "friends", reqId), { status: "accepted" });
      const meRef = doc(db, "users", myUid);
      const himRef = doc(db, "users", fromUid);
      await updateDoc(meRef, { friends: arrayUnion(fromUid) });
      await updateDoc(himRef, { friends: arrayUnion(myUid) });
      window.loadFriends();
      winFr.remove();
    };
    winFr.querySelector("#rej").onclick = async () => {
      await updateDoc(doc(db, "friends", reqId), { status: "rejected" });
      winFr.remove();
    };
  }

  // ---------- (do NOT call loadFriendsPanel() manually here; snapshot will call it) ----------
  // loadFriendsPanel();

}

window.openChat = openChat;

</script>
</body>
</html>
